(function () {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var uikit = createCommonjsModule(function (module, exports) {
	/*! UIkit 3.4.2 | https://www.getuikit.com | (c) 2014 - 2020 YOOtheme | MIT License */
	(function (global, factory) {
	   module.exports = factory() ;
	})(commonjsGlobal, function () {

	  var objPrototype = Object.prototype;
	  var hasOwnProperty = objPrototype.hasOwnProperty;

	  function hasOwn(obj, key) {
	    return hasOwnProperty.call(obj, key);
	  }

	  var hyphenateCache = {};
	  var hyphenateRe = /([a-z\d])([A-Z])/g;

	  function hyphenate(str) {
	    if (!(str in hyphenateCache)) {
	      hyphenateCache[str] = str.replace(hyphenateRe, '$1-$2').toLowerCase();
	    }

	    return hyphenateCache[str];
	  }

	  var camelizeRe = /-(\w)/g;

	  function camelize(str) {
	    return str.replace(camelizeRe, toUpper);
	  }

	  function toUpper(_, c) {
	    return c ? c.toUpperCase() : '';
	  }

	  function ucfirst(str) {
	    return str.length ? toUpper(null, str.charAt(0)) + str.slice(1) : '';
	  }

	  var strPrototype = String.prototype;

	  var startsWithFn = strPrototype.startsWith || function (search) {
	    return this.lastIndexOf(search, 0) === 0;
	  };

	  function startsWith(str, search) {
	    return startsWithFn.call(str, search);
	  }

	  var endsWithFn = strPrototype.endsWith || function (search) {
	    return this.substr(-search.length) === search;
	  };

	  function endsWith(str, search) {
	    return endsWithFn.call(str, search);
	  }

	  var arrPrototype = Array.prototype;

	  var includesFn = function (search, i) {
	    return !!~this.indexOf(search, i);
	  };

	  var includesStr = strPrototype.includes || includesFn;
	  var includesArray = arrPrototype.includes || includesFn;

	  function includes(obj, search) {
	    return obj && (isString(obj) ? includesStr : includesArray).call(obj, search);
	  }

	  var findIndexFn = arrPrototype.findIndex || function (predicate) {
	    var arguments$1 = arguments;

	    for (var i = 0; i < this.length; i++) {
	      if (predicate.call(arguments$1[1], this[i], i, this)) {
	        return i;
	      }
	    }

	    return -1;
	  };

	  function findIndex(array, predicate) {
	    return findIndexFn.call(array, predicate);
	  }

	  var isArray = Array.isArray;

	  function isFunction(obj) {
	    return typeof obj === 'function';
	  }

	  function isObject(obj) {
	    return obj !== null && typeof obj === 'object';
	  }

	  var toString = objPrototype.toString;

	  function isPlainObject(obj) {
	    return toString.call(obj) === '[object Object]';
	  }

	  function isWindow(obj) {
	    return isObject(obj) && obj === obj.window;
	  }

	  function isDocument(obj) {
	    return isObject(obj) && obj.nodeType === 9;
	  }

	  function isJQuery(obj) {
	    return isObject(obj) && !!obj.jquery;
	  }

	  function isNode(obj) {
	    return isObject(obj) && obj.nodeType >= 1;
	  }

	  function isElement(obj) {
	    return isObject(obj) && obj.nodeType === 1;
	  }

	  function isNodeCollection(obj) {
	    return toString.call(obj).match(/^\[object (NodeList|HTMLCollection)\]$/);
	  }

	  function isBoolean(value) {
	    return typeof value === 'boolean';
	  }

	  function isString(value) {
	    return typeof value === 'string';
	  }

	  function isNumber(value) {
	    return typeof value === 'number';
	  }

	  function isNumeric(value) {
	    return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value));
	  }

	  function isEmpty(obj) {
	    return !(isArray(obj) ? obj.length : isObject(obj) ? Object.keys(obj).length : false);
	  }

	  function isUndefined(value) {
	    return value === void 0;
	  }

	  function toBoolean(value) {
	    return isBoolean(value) ? value : value === 'true' || value === '1' || value === '' ? true : value === 'false' || value === '0' ? false : value;
	  }

	  function toNumber(value) {
	    var number = Number(value);
	    return !isNaN(number) ? number : false;
	  }

	  function toFloat(value) {
	    return parseFloat(value) || 0;
	  }

	  function toNode(element) {
	    return isNode(element) ? element : isNodeCollection(element) || isJQuery(element) ? element[0] : isArray(element) ? toNode(element[0]) : null;
	  }

	  function toNodes(element) {
	    return isNode(element) ? [element] : isNodeCollection(element) ? arrPrototype.slice.call(element) : isArray(element) ? element.map(toNode).filter(Boolean) : isJQuery(element) ? element.toArray() : [];
	  }

	  function toWindow(element) {
	    if (isWindow(element)) {
	      return element;
	    }

	    element = toNode(element);
	    return element ? (isDocument(element) ? element : element.ownerDocument).defaultView : window;
	  }

	  function toList(value) {
	    return isArray(value) ? value : isString(value) ? value.split(/,(?![^(]*\))/).map(function (value) {
	      return isNumeric(value) ? toNumber(value) : toBoolean(value.trim());
	    }) : [value];
	  }

	  function toMs(time) {
	    return !time ? 0 : endsWith(time, 'ms') ? toFloat(time) : toFloat(time) * 1000;
	  }

	  function isEqual(value, other) {
	    return value === other || isObject(value) && isObject(other) && Object.keys(value).length === Object.keys(other).length && each(value, function (val, key) {
	      return val === other[key];
	    });
	  }

	  function swap(value, a, b) {
	    return value.replace(new RegExp(a + "|" + b, 'g'), function (match) {
	      return match === a ? b : a;
	    });
	  }

	  var assign = Object.assign || function (target) {
	    var args = [],
	        len = arguments.length - 1;

	    while (len-- > 0) args[len] = arguments[len + 1];

	    target = Object(target);

	    for (var i = 0; i < args.length; i++) {
	      var source = args[i];

	      if (source !== null) {
	        for (var key in source) {
	          if (hasOwn(source, key)) {
	            target[key] = source[key];
	          }
	        }
	      }
	    }

	    return target;
	  };

	  function last(array) {
	    return array[array.length - 1];
	  }

	  function each(obj, cb) {
	    for (var key in obj) {
	      if (false === cb(obj[key], key)) {
	        return false;
	      }
	    }

	    return true;
	  }

	  function sortBy(array, prop) {
	    return array.sort(function (ref, ref$1) {
	      var propA = ref[prop];
	      if (propA === void 0) propA = 0;
	      var propB = ref$1[prop];
	      if (propB === void 0) propB = 0;
	      return propA > propB ? 1 : propB > propA ? -1 : 0;
	    });
	  }

	  function uniqueBy(array, prop) {
	    var seen = new Set();
	    return array.filter(function (ref) {
	      var check = ref[prop];
	      return seen.has(check) ? false : seen.add(check) || true;
	    } // IE 11 does not return the Set object
	    );
	  }

	  function clamp(number, min, max) {
	    if (min === void 0) min = 0;
	    if (max === void 0) max = 1;
	    return Math.min(Math.max(toNumber(number) || 0, min), max);
	  }

	  function noop() {}

	  function intersectRect(r1, r2) {
	    return r1.left < r2.right && r1.right > r2.left && r1.top < r2.bottom && r1.bottom > r2.top;
	  }

	  function pointInRect(point, rect) {
	    return point.x <= rect.right && point.x >= rect.left && point.y <= rect.bottom && point.y >= rect.top;
	  }

	  var Dimensions = {
	    ratio: function (dimensions, prop, value) {
	      var obj;
	      var aProp = prop === 'width' ? 'height' : 'width';
	      return obj = {}, obj[aProp] = dimensions[prop] ? Math.round(value * dimensions[aProp] / dimensions[prop]) : dimensions[aProp], obj[prop] = value, obj;
	    },
	    contain: function (dimensions, maxDimensions) {
	      var this$1 = this;
	      dimensions = assign({}, dimensions);
	      each(dimensions, function (_, prop) {
	        return dimensions = dimensions[prop] > maxDimensions[prop] ? this$1.ratio(dimensions, prop, maxDimensions[prop]) : dimensions;
	      });
	      return dimensions;
	    },
	    cover: function (dimensions, maxDimensions) {
	      var this$1 = this;
	      dimensions = this.contain(dimensions, maxDimensions);
	      each(dimensions, function (_, prop) {
	        return dimensions = dimensions[prop] < maxDimensions[prop] ? this$1.ratio(dimensions, prop, maxDimensions[prop]) : dimensions;
	      });
	      return dimensions;
	    }
	  };

	  function attr(element, name, value) {
	    if (isObject(name)) {
	      for (var key in name) {
	        attr(element, key, name[key]);
	      }

	      return;
	    }

	    if (isUndefined(value)) {
	      element = toNode(element);
	      return element && element.getAttribute(name);
	    } else {
	      toNodes(element).forEach(function (element) {
	        if (isFunction(value)) {
	          value = value.call(element, attr(element, name));
	        }

	        if (value === null) {
	          removeAttr(element, name);
	        } else {
	          element.setAttribute(name, value);
	        }
	      });
	    }
	  }

	  function hasAttr(element, name) {
	    return toNodes(element).some(function (element) {
	      return element.hasAttribute(name);
	    });
	  }

	  function removeAttr(element, name) {
	    element = toNodes(element);
	    name.split(' ').forEach(function (name) {
	      return element.forEach(function (element) {
	        return element.hasAttribute(name) && element.removeAttribute(name);
	      });
	    });
	  }

	  function data(element, attribute) {
	    for (var i = 0, attrs = [attribute, "data-" + attribute]; i < attrs.length; i++) {
	      if (hasAttr(element, attrs[i])) {
	        return attr(element, attrs[i]);
	      }
	    }
	  }
	  /* global DocumentTouch */


	  var isIE = /msie|trident/i.test(window.navigator.userAgent);
	  var isRtl = attr(document.documentElement, 'dir') === 'rtl';
	  var hasTouchEvents = ('ontouchstart' in window);
	  var hasPointerEvents = window.PointerEvent;
	  var hasTouch = hasTouchEvents || window.DocumentTouch && document instanceof DocumentTouch || navigator.maxTouchPoints; // IE >=11

	  var pointerDown = hasPointerEvents ? 'pointerdown' : hasTouchEvents ? 'touchstart' : 'mousedown';
	  var pointerMove = hasPointerEvents ? 'pointermove' : hasTouchEvents ? 'touchmove' : 'mousemove';
	  var pointerUp = hasPointerEvents ? 'pointerup' : hasTouchEvents ? 'touchend' : 'mouseup';
	  var pointerEnter = hasPointerEvents ? 'pointerenter' : hasTouchEvents ? '' : 'mouseenter';
	  var pointerLeave = hasPointerEvents ? 'pointerleave' : hasTouchEvents ? '' : 'mouseleave';
	  var pointerCancel = hasPointerEvents ? 'pointercancel' : 'touchcancel';

	  function query(selector, context) {
	    return toNode(selector) || find(selector, getContext(selector, context));
	  }

	  function queryAll(selector, context) {
	    var nodes = toNodes(selector);
	    return nodes.length && nodes || findAll(selector, getContext(selector, context));
	  }

	  function getContext(selector, context) {
	    if (context === void 0) context = document;
	    return isContextSelector(selector) || isDocument(context) ? context : context.ownerDocument;
	  }

	  function find(selector, context) {
	    return toNode(_query(selector, context, 'querySelector'));
	  }

	  function findAll(selector, context) {
	    return toNodes(_query(selector, context, 'querySelectorAll'));
	  }

	  function _query(selector, context, queryFn) {
	    if (context === void 0) context = document;

	    if (!selector || !isString(selector)) {
	      return null;
	    }

	    selector = selector.replace(contextSanitizeRe, '$1 *');
	    var removes;

	    if (isContextSelector(selector)) {
	      removes = [];
	      selector = splitSelector(selector).map(function (selector, i) {
	        var ctx = context;

	        if (selector[0] === '!') {
	          var selectors = selector.substr(1).trim().split(' ');
	          ctx = closest(parent(context), selectors[0]);
	          selector = selectors.slice(1).join(' ').trim();
	        }

	        if (selector[0] === '-') {
	          var selectors$1 = selector.substr(1).trim().split(' ');
	          var prev = (ctx || context).previousElementSibling;
	          ctx = matches(prev, selector.substr(1)) ? prev : null;
	          selector = selectors$1.slice(1).join(' ');
	        }

	        if (!ctx) {
	          return null;
	        }

	        if (!ctx.id) {
	          ctx.id = "uk-" + Date.now() + i;
	          removes.push(function () {
	            return removeAttr(ctx, 'id');
	          });
	        }

	        return "#" + escape(ctx.id) + " " + selector;
	      }).filter(Boolean).join(',');
	      context = document;
	    }

	    try {
	      return context[queryFn](selector);
	    } catch (e) {
	      return null;
	    } finally {
	      removes && removes.forEach(function (remove) {
	        return remove();
	      });
	    }
	  }

	  var contextSelectorRe = /(^|[^\\],)\s*[!>+~-]/;
	  var contextSanitizeRe = /([!>+~-])(?=\s+[!>+~-]|\s*$)/g;

	  function isContextSelector(selector) {
	    return isString(selector) && selector.match(contextSelectorRe);
	  }

	  var selectorRe = /.*?[^\\](?:,|$)/g;

	  function splitSelector(selector) {
	    return selector.match(selectorRe).map(function (selector) {
	      return selector.replace(/,$/, '').trim();
	    });
	  }

	  var elProto = Element.prototype;
	  var matchesFn = elProto.matches || elProto.webkitMatchesSelector || elProto.msMatchesSelector;

	  function matches(element, selector) {
	    return toNodes(element).some(function (element) {
	      return matchesFn.call(element, selector);
	    });
	  }

	  var closestFn = elProto.closest || function (selector) {
	    var ancestor = this;

	    do {
	      if (matches(ancestor, selector)) {
	        return ancestor;
	      }
	    } while (ancestor = parent(ancestor));
	  };

	  function closest(element, selector) {
	    if (startsWith(selector, '>')) {
	      selector = selector.slice(1);
	    }

	    return isElement(element) ? closestFn.call(element, selector) : toNodes(element).map(function (element) {
	      return closest(element, selector);
	    }).filter(Boolean);
	  }

	  function parent(element) {
	    element = toNode(element);
	    return element && isElement(element.parentNode) && element.parentNode;
	  }

	  var escapeFn = window.CSS && CSS.escape || function (css) {
	    return css.replace(/([^\x7f-\uFFFF\w-])/g, function (match) {
	      return "\\" + match;
	    });
	  };

	  function escape(css) {
	    return isString(css) ? escapeFn.call(null, css) : '';
	  }

	  var voidElements = {
	    area: true,
	    base: true,
	    br: true,
	    col: true,
	    embed: true,
	    hr: true,
	    img: true,
	    input: true,
	    keygen: true,
	    link: true,
	    menuitem: true,
	    meta: true,
	    param: true,
	    source: true,
	    track: true,
	    wbr: true
	  };

	  function isVoidElement(element) {
	    return toNodes(element).some(function (element) {
	      return voidElements[element.tagName.toLowerCase()];
	    });
	  }

	  function isVisible(element) {
	    return toNodes(element).some(function (element) {
	      return element.offsetWidth || element.offsetHeight || element.getClientRects().length;
	    });
	  }

	  var selInput = 'input,select,textarea,button';

	  function isInput(element) {
	    return toNodes(element).some(function (element) {
	      return matches(element, selInput);
	    });
	  }

	  function filter(element, selector) {
	    return toNodes(element).filter(function (element) {
	      return matches(element, selector);
	    });
	  }

	  function within(element, selector) {
	    return !isString(selector) ? element === selector || (isDocument(selector) ? selector.documentElement : toNode(selector)).contains(toNode(element)) // IE 11 document does not implement contains
	    : matches(element, selector) || closest(element, selector);
	  }

	  function parents(element, selector) {
	    var elements = [];

	    while (element = parent(element)) {
	      if (!selector || matches(element, selector)) {
	        elements.push(element);
	      }
	    }

	    return elements;
	  }

	  function children(element, selector) {
	    element = toNode(element);
	    var children = element ? toNodes(element.children) : [];
	    return selector ? filter(children, selector) : children;
	  }

	  function on() {
	    var args = [],
	        len = arguments.length;

	    while (len--) args[len] = arguments[len];

	    var ref = getArgs(args);
	    var targets = ref[0];
	    var type = ref[1];
	    var selector = ref[2];
	    var listener = ref[3];
	    var useCapture = ref[4];
	    targets = toEventTargets(targets);

	    if (listener.length > 1) {
	      listener = detail(listener);
	    }

	    if (useCapture && useCapture.self) {
	      listener = selfFilter(listener);
	    }

	    if (selector) {
	      listener = delegate(targets, selector, listener);
	    }

	    useCapture = useCaptureFilter(useCapture);
	    type.split(' ').forEach(function (type) {
	      return targets.forEach(function (target) {
	        return target.addEventListener(type, listener, useCapture);
	      });
	    });
	    return function () {
	      return off(targets, type, listener, useCapture);
	    };
	  }

	  function off(targets, type, listener, useCapture) {
	    if (useCapture === void 0) useCapture = false;
	    useCapture = useCaptureFilter(useCapture);
	    targets = toEventTargets(targets);
	    type.split(' ').forEach(function (type) {
	      return targets.forEach(function (target) {
	        return target.removeEventListener(type, listener, useCapture);
	      });
	    });
	  }

	  function once() {
	    var args = [],
	        len = arguments.length;

	    while (len--) args[len] = arguments[len];

	    var ref = getArgs(args);
	    var element = ref[0];
	    var type = ref[1];
	    var selector = ref[2];
	    var listener = ref[3];
	    var useCapture = ref[4];
	    var condition = ref[5];
	    var off = on(element, type, selector, function (e) {
	      var result = !condition || condition(e);

	      if (result) {
	        off();
	        listener(e, result);
	      }
	    }, useCapture);
	    return off;
	  }

	  function trigger(targets, event, detail) {
	    return toEventTargets(targets).reduce(function (notCanceled, target) {
	      return notCanceled && target.dispatchEvent(createEvent(event, true, true, detail));
	    }, true);
	  }

	  function createEvent(e, bubbles, cancelable, detail) {
	    if (bubbles === void 0) bubbles = true;
	    if (cancelable === void 0) cancelable = false;

	    if (isString(e)) {
	      var event = document.createEvent('CustomEvent'); // IE 11

	      event.initCustomEvent(e, bubbles, cancelable, detail);
	      e = event;
	    }

	    return e;
	  }

	  function getArgs(args) {
	    if (isFunction(args[2])) {
	      args.splice(2, 0, false);
	    }

	    return args;
	  }

	  function delegate(delegates, selector, listener) {
	    var this$1 = this;
	    return function (e) {
	      delegates.forEach(function (delegate) {
	        var current = selector[0] === '>' ? findAll(selector, delegate).reverse().filter(function (element) {
	          return within(e.target, element);
	        })[0] : closest(e.target, selector);

	        if (current) {
	          e.delegate = delegate;
	          e.current = current;
	          listener.call(this$1, e);
	        }
	      });
	    };
	  }

	  function detail(listener) {
	    return function (e) {
	      return isArray(e.detail) ? listener.apply(void 0, [e].concat(e.detail)) : listener(e);
	    };
	  }

	  function selfFilter(listener) {
	    return function (e) {
	      if (e.target === e.currentTarget || e.target === e.current) {
	        return listener.call(null, e);
	      }
	    };
	  }

	  function useCaptureFilter(options) {
	    return options && isIE && !isBoolean(options) ? !!options.capture : options;
	  }

	  function isEventTarget(target) {
	    return target && 'addEventListener' in target;
	  }

	  function toEventTarget(target) {
	    return isEventTarget(target) ? target : toNode(target);
	  }

	  function toEventTargets(target) {
	    return isArray(target) ? target.map(toEventTarget).filter(Boolean) : isString(target) ? findAll(target) : isEventTarget(target) ? [target] : toNodes(target);
	  }

	  function isTouch(e) {
	    return e.pointerType === 'touch' || !!e.touches;
	  }

	  function getEventPos(e) {
	    var touches = e.touches;
	    var changedTouches = e.changedTouches;
	    var ref = touches && touches[0] || changedTouches && changedTouches[0] || e;
	    var x = ref.clientX;
	    var y = ref.clientY;
	    return {
	      x: x,
	      y: y
	    };
	  }
	  /* global setImmediate */


	  var Promise = 'Promise' in window ? window.Promise : PromiseFn;

	  var Deferred = function () {
	    var this$1 = this;
	    this.promise = new Promise(function (resolve, reject) {
	      this$1.reject = reject;
	      this$1.resolve = resolve;
	    });
	  };
	  /**
	   * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
	   */


	  var RESOLVED = 0;
	  var REJECTED = 1;
	  var PENDING = 2;
	  var async = 'setImmediate' in window ? setImmediate : setTimeout;

	  function PromiseFn(executor) {
	    this.state = PENDING;
	    this.value = undefined;
	    this.deferred = [];
	    var promise = this;

	    try {
	      executor(function (x) {
	        promise.resolve(x);
	      }, function (r) {
	        promise.reject(r);
	      });
	    } catch (e) {
	      promise.reject(e);
	    }
	  }

	  PromiseFn.reject = function (r) {
	    return new PromiseFn(function (resolve, reject) {
	      reject(r);
	    });
	  };

	  PromiseFn.resolve = function (x) {
	    return new PromiseFn(function (resolve, reject) {
	      resolve(x);
	    });
	  };

	  PromiseFn.all = function all(iterable) {
	    return new PromiseFn(function (resolve, reject) {
	      var result = [];
	      var count = 0;

	      if (iterable.length === 0) {
	        resolve(result);
	      }

	      function resolver(i) {
	        return function (x) {
	          result[i] = x;
	          count += 1;

	          if (count === iterable.length) {
	            resolve(result);
	          }
	        };
	      }

	      for (var i = 0; i < iterable.length; i += 1) {
	        PromiseFn.resolve(iterable[i]).then(resolver(i), reject);
	      }
	    });
	  };

	  PromiseFn.race = function race(iterable) {
	    return new PromiseFn(function (resolve, reject) {
	      for (var i = 0; i < iterable.length; i += 1) {
	        PromiseFn.resolve(iterable[i]).then(resolve, reject);
	      }
	    });
	  };

	  var p = PromiseFn.prototype;

	  p.resolve = function resolve(x) {
	    var promise = this;

	    if (promise.state === PENDING) {
	      if (x === promise) {
	        throw new TypeError('Promise settled with itself.');
	      }

	      var called = false;

	      try {
	        var then = x && x.then;

	        if (x !== null && isObject(x) && isFunction(then)) {
	          then.call(x, function (x) {
	            if (!called) {
	              promise.resolve(x);
	            }

	            called = true;
	          }, function (r) {
	            if (!called) {
	              promise.reject(r);
	            }

	            called = true;
	          });
	          return;
	        }
	      } catch (e) {
	        if (!called) {
	          promise.reject(e);
	        }

	        return;
	      }

	      promise.state = RESOLVED;
	      promise.value = x;
	      promise.notify();
	    }
	  };

	  p.reject = function reject(reason) {
	    var promise = this;

	    if (promise.state === PENDING) {
	      if (reason === promise) {
	        throw new TypeError('Promise settled with itself.');
	      }

	      promise.state = REJECTED;
	      promise.value = reason;
	      promise.notify();
	    }
	  };

	  p.notify = function notify() {
	    var this$1 = this;
	    async(function () {
	      if (this$1.state !== PENDING) {
	        while (this$1.deferred.length) {
	          var ref = this$1.deferred.shift();
	          var onResolved = ref[0];
	          var onRejected = ref[1];
	          var resolve = ref[2];
	          var reject = ref[3];

	          try {
	            if (this$1.state === RESOLVED) {
	              if (isFunction(onResolved)) {
	                resolve(onResolved.call(undefined, this$1.value));
	              } else {
	                resolve(this$1.value);
	              }
	            } else if (this$1.state === REJECTED) {
	              if (isFunction(onRejected)) {
	                resolve(onRejected.call(undefined, this$1.value));
	              } else {
	                reject(this$1.value);
	              }
	            }
	          } catch (e) {
	            reject(e);
	          }
	        }
	      }
	    });
	  };

	  p.then = function then(onResolved, onRejected) {
	    var this$1 = this;
	    return new PromiseFn(function (resolve, reject) {
	      this$1.deferred.push([onResolved, onRejected, resolve, reject]);
	      this$1.notify();
	    });
	  };

	  p.catch = function (onRejected) {
	    return this.then(undefined, onRejected);
	  };

	  function ajax(url, options) {
	    return new Promise(function (resolve, reject) {
	      var env = assign({
	        data: null,
	        method: 'GET',
	        headers: {},
	        xhr: new XMLHttpRequest(),
	        beforeSend: noop,
	        responseType: ''
	      }, options);
	      env.beforeSend(env);
	      var xhr = env.xhr;

	      for (var prop in env) {
	        if (prop in xhr) {
	          try {
	            xhr[prop] = env[prop];
	          } catch (e) {}
	        }
	      }

	      xhr.open(env.method.toUpperCase(), url);

	      for (var header in env.headers) {
	        xhr.setRequestHeader(header, env.headers[header]);
	      }

	      on(xhr, 'load', function () {
	        if (xhr.status === 0 || xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {
	          resolve(xhr);
	        } else {
	          reject(assign(Error(xhr.statusText), {
	            xhr: xhr,
	            status: xhr.status
	          }));
	        }
	      });
	      on(xhr, 'error', function () {
	        return reject(assign(Error('Network Error'), {
	          xhr: xhr
	        }));
	      });
	      on(xhr, 'timeout', function () {
	        return reject(assign(Error('Network Timeout'), {
	          xhr: xhr
	        }));
	      });
	      xhr.send(env.data);
	    });
	  }

	  function getImage(src, srcset, sizes) {
	    return new Promise(function (resolve, reject) {
	      var img = new Image();
	      img.onerror = reject;

	      img.onload = function () {
	        return resolve(img);
	      };

	      sizes && (img.sizes = sizes);
	      srcset && (img.srcset = srcset);
	      img.src = src;
	    });
	  }

	  function ready(fn) {
	    if (document.readyState !== 'loading') {
	      fn();
	      return;
	    }

	    var unbind = on(document, 'DOMContentLoaded', function () {
	      unbind();
	      fn();
	    });
	  }

	  function index(element, ref) {
	    return ref ? toNodes(element).indexOf(toNode(ref)) : children(parent(element)).indexOf(element);
	  }

	  function getIndex(i, elements, current, finite) {
	    if (current === void 0) current = 0;
	    if (finite === void 0) finite = false;
	    elements = toNodes(elements);
	    var length = elements.length;
	    i = isNumeric(i) ? toNumber(i) : i === 'next' ? current + 1 : i === 'previous' ? current - 1 : index(elements, i);

	    if (finite) {
	      return clamp(i, 0, length - 1);
	    }

	    i %= length;
	    return i < 0 ? i + length : i;
	  }

	  function empty(element) {
	    element = $(element);
	    element.innerHTML = '';
	    return element;
	  }

	  function html(parent, html) {
	    parent = $(parent);
	    return isUndefined(html) ? parent.innerHTML : append(parent.hasChildNodes() ? empty(parent) : parent, html);
	  }

	  function prepend(parent, element) {
	    parent = $(parent);

	    if (!parent.hasChildNodes()) {
	      return append(parent, element);
	    } else {
	      return insertNodes(element, function (element) {
	        return parent.insertBefore(element, parent.firstChild);
	      });
	    }
	  }

	  function append(parent, element) {
	    parent = $(parent);
	    return insertNodes(element, function (element) {
	      return parent.appendChild(element);
	    });
	  }

	  function before(ref, element) {
	    ref = $(ref);
	    return insertNodes(element, function (element) {
	      return ref.parentNode.insertBefore(element, ref);
	    });
	  }

	  function after(ref, element) {
	    ref = $(ref);
	    return insertNodes(element, function (element) {
	      return ref.nextSibling ? before(ref.nextSibling, element) : append(ref.parentNode, element);
	    });
	  }

	  function insertNodes(element, fn) {
	    element = isString(element) ? fragment(element) : element;
	    return element ? 'length' in element ? toNodes(element).map(fn) : fn(element) : null;
	  }

	  function remove(element) {
	    toNodes(element).map(function (element) {
	      return element.parentNode && element.parentNode.removeChild(element);
	    });
	  }

	  function wrapAll(element, structure) {
	    structure = toNode(before(element, structure));

	    while (structure.firstChild) {
	      structure = structure.firstChild;
	    }

	    append(structure, element);
	    return structure;
	  }

	  function wrapInner(element, structure) {
	    return toNodes(toNodes(element).map(function (element) {
	      return element.hasChildNodes ? wrapAll(toNodes(element.childNodes), structure) : append(element, structure);
	    }));
	  }

	  function unwrap(element) {
	    toNodes(element).map(parent).filter(function (value, index, self) {
	      return self.indexOf(value) === index;
	    }).forEach(function (parent) {
	      before(parent, parent.childNodes);
	      remove(parent);
	    });
	  }

	  var fragmentRe = /^\s*<(\w+|!)[^>]*>/;
	  var singleTagRe = /^<(\w+)\s*\/?>(?:<\/\1>)?$/;

	  function fragment(html) {
	    var matches = singleTagRe.exec(html);

	    if (matches) {
	      return document.createElement(matches[1]);
	    }

	    var container = document.createElement('div');

	    if (fragmentRe.test(html)) {
	      container.insertAdjacentHTML('beforeend', html.trim());
	    } else {
	      container.textContent = html;
	    }

	    return container.childNodes.length > 1 ? toNodes(container.childNodes) : container.firstChild;
	  }

	  function apply(node, fn) {
	    if (!isElement(node)) {
	      return;
	    }

	    fn(node);
	    node = node.firstElementChild;

	    while (node) {
	      var next = node.nextElementSibling;
	      apply(node, fn);
	      node = next;
	    }
	  }

	  function $(selector, context) {
	    return !isString(selector) ? toNode(selector) : isHtml(selector) ? toNode(fragment(selector)) : find(selector, context);
	  }

	  function $$(selector, context) {
	    return !isString(selector) ? toNodes(selector) : isHtml(selector) ? toNodes(fragment(selector)) : findAll(selector, context);
	  }

	  function isHtml(str) {
	    return str[0] === '<' || str.match(/^\s*</);
	  }

	  function addClass(element) {
	    var args = [],
	        len = arguments.length - 1;

	    while (len-- > 0) args[len] = arguments[len + 1];

	    apply$1(element, args, 'add');
	  }

	  function removeClass(element) {
	    var args = [],
	        len = arguments.length - 1;

	    while (len-- > 0) args[len] = arguments[len + 1];

	    apply$1(element, args, 'remove');
	  }

	  function removeClasses(element, cls) {
	    attr(element, 'class', function (value) {
	      return (value || '').replace(new RegExp("\\b" + cls + "\\b", 'g'), '');
	    });
	  }

	  function replaceClass(element) {
	    var args = [],
	        len = arguments.length - 1;

	    while (len-- > 0) args[len] = arguments[len + 1];

	    args[0] && removeClass(element, args[0]);
	    args[1] && addClass(element, args[1]);
	  }

	  function hasClass(element, cls) {
	    return cls && toNodes(element).some(function (element) {
	      return element.classList.contains(cls.split(' ')[0]);
	    });
	  }

	  function toggleClass(element) {
	    var args = [],
	        len = arguments.length - 1;

	    while (len-- > 0) args[len] = arguments[len + 1];

	    if (!args.length) {
	      return;
	    }

	    args = getArgs$1(args);
	    var force = !isString(last(args)) ? args.pop() : []; // in iOS 9.3 force === undefined evaluates to false

	    args = args.filter(Boolean);
	    toNodes(element).forEach(function (ref) {
	      var classList = ref.classList;

	      for (var i = 0; i < args.length; i++) {
	        supports.Force ? classList.toggle.apply(classList, [args[i]].concat(force)) : classList[(!isUndefined(force) ? force : !classList.contains(args[i])) ? 'add' : 'remove'](args[i]);
	      }
	    });
	  }

	  function apply$1(element, args, fn) {
	    args = getArgs$1(args).filter(Boolean);
	    args.length && toNodes(element).forEach(function (ref) {
	      var classList = ref.classList;
	      supports.Multiple ? classList[fn].apply(classList, args) : args.forEach(function (cls) {
	        return classList[fn](cls);
	      });
	    });
	  }

	  function getArgs$1(args) {
	    return args.reduce(function (args, arg) {
	      return args.concat.call(args, isString(arg) && includes(arg, ' ') ? arg.trim().split(' ') : arg);
	    }, []);
	  } // IE 11


	  var supports = {
	    get Multiple() {
	      return this.get('_multiple');
	    },

	    get Force() {
	      return this.get('_force');
	    },

	    get: function (key) {
	      if (!hasOwn(this, key)) {
	        var ref = document.createElement('_');
	        var classList = ref.classList;
	        classList.add('a', 'b');
	        classList.toggle('c', false);
	        this._multiple = classList.contains('b');
	        this._force = !classList.contains('c');
	      }

	      return this[key];
	    }
	  };
	  var cssNumber = {
	    'animation-iteration-count': true,
	    'column-count': true,
	    'fill-opacity': true,
	    'flex-grow': true,
	    'flex-shrink': true,
	    'font-weight': true,
	    'line-height': true,
	    'opacity': true,
	    'order': true,
	    'orphans': true,
	    'stroke-dasharray': true,
	    'stroke-dashoffset': true,
	    'widows': true,
	    'z-index': true,
	    'zoom': true
	  };

	  function css(element, property, value) {
	    return toNodes(element).map(function (element) {
	      if (isString(property)) {
	        property = propName(property);

	        if (isUndefined(value)) {
	          return getStyle(element, property);
	        } else if (!value && !isNumber(value)) {
	          element.style.removeProperty(property);
	        } else {
	          element.style[property] = isNumeric(value) && !cssNumber[property] ? value + "px" : value;
	        }
	      } else if (isArray(property)) {
	        var styles = getStyles(element);
	        return property.reduce(function (props, property) {
	          props[property] = styles[propName(property)];
	          return props;
	        }, {});
	      } else if (isObject(property)) {
	        each(property, function (value, property) {
	          return css(element, property, value);
	        });
	      }

	      return element;
	    })[0];
	  }

	  function getStyles(element, pseudoElt) {
	    element = toNode(element);
	    return element.ownerDocument.defaultView.getComputedStyle(element, pseudoElt);
	  }

	  function getStyle(element, property, pseudoElt) {
	    return getStyles(element, pseudoElt)[property];
	  }

	  var vars = {};

	  function getCssVar(name) {
	    var docEl = document.documentElement;

	    if (!isIE) {
	      return getStyles(docEl).getPropertyValue("--uk-" + name);
	    }

	    if (!(name in vars)) {
	      /* usage in css: .uk-name:before { content:"xyz" } */
	      var element = append(docEl, document.createElement('div'));
	      addClass(element, "uk-" + name);
	      vars[name] = getStyle(element, 'content', ':before').replace(/^["'](.*)["']$/, '$1');
	      remove(element);
	    }

	    return vars[name];
	  }

	  var cssProps = {};

	  function propName(name) {
	    var ret = cssProps[name];

	    if (!ret) {
	      ret = cssProps[name] = vendorPropName(name) || name;
	    }

	    return ret;
	  }

	  var cssPrefixes = ['webkit', 'moz', 'ms'];

	  function vendorPropName(name) {
	    name = hyphenate(name);
	    var ref = document.documentElement;
	    var style = ref.style;

	    if (name in style) {
	      return name;
	    }

	    var i = cssPrefixes.length,
	        prefixedName;

	    while (i--) {
	      prefixedName = "-" + cssPrefixes[i] + "-" + name;

	      if (prefixedName in style) {
	        return prefixedName;
	      }
	    }
	  }

	  function transition(element, props, duration, timing) {
	    if (duration === void 0) duration = 400;
	    if (timing === void 0) timing = 'linear';
	    return Promise.all(toNodes(element).map(function (element) {
	      return new Promise(function (resolve, reject) {
	        for (var name in props) {
	          var value = css(element, name);

	          if (value === '') {
	            css(element, name, value);
	          }
	        }

	        var timer = setTimeout(function () {
	          return trigger(element, 'transitionend');
	        }, duration);
	        once(element, 'transitionend transitioncanceled', function (ref) {
	          var type = ref.type;
	          clearTimeout(timer);
	          removeClass(element, 'uk-transition');
	          css(element, {
	            transitionProperty: '',
	            transitionDuration: '',
	            transitionTimingFunction: ''
	          });
	          type === 'transitioncanceled' ? reject() : resolve();
	        }, {
	          self: true
	        });
	        addClass(element, 'uk-transition');
	        css(element, assign({
	          transitionProperty: Object.keys(props).map(propName).join(','),
	          transitionDuration: duration + "ms",
	          transitionTimingFunction: timing
	        }, props));
	      });
	    }));
	  }

	  var Transition = {
	    start: transition,
	    stop: function (element) {
	      trigger(element, 'transitionend');
	      return Promise.resolve();
	    },
	    cancel: function (element) {
	      trigger(element, 'transitioncanceled');
	    },
	    inProgress: function (element) {
	      return hasClass(element, 'uk-transition');
	    }
	  };
	  var animationPrefix = 'uk-animation-';
	  var clsCancelAnimation = 'uk-cancel-animation';

	  function animate(element, animation, duration, origin, out) {
	    var arguments$1 = arguments;
	    if (duration === void 0) duration = 200;
	    return Promise.all(toNodes(element).map(function (element) {
	      return new Promise(function (resolve, reject) {
	        if (hasClass(element, clsCancelAnimation)) {
	          requestAnimationFrame(function () {
	            return Promise.resolve().then(function () {
	              return animate.apply(void 0, arguments$1).then(resolve, reject);
	            });
	          });
	          return;
	        }

	        var cls = animation + " " + animationPrefix + (out ? 'leave' : 'enter');

	        if (startsWith(animation, animationPrefix)) {
	          if (origin) {
	            cls += " uk-transform-origin-" + origin;
	          }

	          if (out) {
	            cls += " " + animationPrefix + "reverse";
	          }
	        }

	        reset();
	        once(element, 'animationend animationcancel', function (ref) {
	          var type = ref.type;
	          var hasReset = false;

	          if (type === 'animationcancel') {
	            reject();
	            reset();
	          } else {
	            resolve();
	            Promise.resolve().then(function () {
	              hasReset = true;
	              reset();
	            });
	          }

	          requestAnimationFrame(function () {
	            if (!hasReset) {
	              addClass(element, clsCancelAnimation);
	              requestAnimationFrame(function () {
	                return removeClass(element, clsCancelAnimation);
	              });
	            }
	          });
	        }, {
	          self: true
	        });
	        css(element, 'animationDuration', duration + "ms");
	        addClass(element, cls);

	        function reset() {
	          css(element, 'animationDuration', '');
	          removeClasses(element, animationPrefix + "\\S*");
	        }
	      });
	    }));
	  }

	  var inProgress = new RegExp(animationPrefix + "(enter|leave)");
	  var Animation = {
	    in: function (element, animation, duration, origin) {
	      return animate(element, animation, duration, origin, false);
	    },
	    out: function (element, animation, duration, origin) {
	      return animate(element, animation, duration, origin, true);
	    },
	    inProgress: function (element) {
	      return inProgress.test(attr(element, 'class'));
	    },
	    cancel: function (element) {
	      trigger(element, 'animationcancel');
	    }
	  };
	  var dirs = {
	    width: ['x', 'left', 'right'],
	    height: ['y', 'top', 'bottom']
	  };

	  function positionAt(element, target, elAttach, targetAttach, elOffset, targetOffset, flip, boundary) {
	    elAttach = getPos(elAttach);
	    targetAttach = getPos(targetAttach);
	    var flipped = {
	      element: elAttach,
	      target: targetAttach
	    };

	    if (!element || !target) {
	      return flipped;
	    }

	    var dim = getDimensions(element);
	    var targetDim = getDimensions(target);
	    var position = targetDim;
	    moveTo(position, elAttach, dim, -1);
	    moveTo(position, targetAttach, targetDim, 1);
	    elOffset = getOffsets(elOffset, dim.width, dim.height);
	    targetOffset = getOffsets(targetOffset, targetDim.width, targetDim.height);
	    elOffset['x'] += targetOffset['x'];
	    elOffset['y'] += targetOffset['y'];
	    position.left += elOffset['x'];
	    position.top += elOffset['y'];

	    if (flip) {
	      var boundaries = [getDimensions(toWindow(element))];

	      if (boundary) {
	        boundaries.unshift(getDimensions(boundary));
	      }

	      each(dirs, function (ref, prop) {
	        var dir = ref[0];
	        var align = ref[1];
	        var alignFlip = ref[2];

	        if (!(flip === true || includes(flip, dir))) {
	          return;
	        }

	        boundaries.some(function (boundary) {
	          var elemOffset = elAttach[dir] === align ? -dim[prop] : elAttach[dir] === alignFlip ? dim[prop] : 0;
	          var targetOffset = targetAttach[dir] === align ? targetDim[prop] : targetAttach[dir] === alignFlip ? -targetDim[prop] : 0;

	          if (position[align] < boundary[align] || position[align] + dim[prop] > boundary[alignFlip]) {
	            var centerOffset = dim[prop] / 2;
	            var centerTargetOffset = targetAttach[dir] === 'center' ? -targetDim[prop] / 2 : 0;
	            return elAttach[dir] === 'center' && (apply(centerOffset, centerTargetOffset) || apply(-centerOffset, -centerTargetOffset)) || apply(elemOffset, targetOffset);
	          }

	          function apply(elemOffset, targetOffset) {
	            var newVal = position[align] + elemOffset + targetOffset - elOffset[dir] * 2;

	            if (newVal >= boundary[align] && newVal + dim[prop] <= boundary[alignFlip]) {
	              position[align] = newVal;
	              ['element', 'target'].forEach(function (el) {
	                flipped[el][dir] = !elemOffset ? flipped[el][dir] : flipped[el][dir] === dirs[prop][1] ? dirs[prop][2] : dirs[prop][1];
	              });
	              return true;
	            }
	          }
	        });
	      });
	    }

	    offset(element, position);
	    return flipped;
	  }

	  function offset(element, coordinates) {
	    if (!coordinates) {
	      return getDimensions(element);
	    }

	    var currentOffset = offset(element);
	    var pos = css(element, 'position');
	    ['left', 'top'].forEach(function (prop) {
	      if (prop in coordinates) {
	        var value = css(element, prop);
	        css(element, prop, coordinates[prop] - currentOffset[prop] + toFloat(pos === 'absolute' && value === 'auto' ? position(element)[prop] : value));
	      }
	    });
	  }

	  function getDimensions(element) {
	    if (!element) {
	      return {};
	    }

	    var ref = toWindow(element);
	    var top = ref.pageYOffset;
	    var left = ref.pageXOffset;

	    if (isWindow(element)) {
	      var height = element.innerHeight;
	      var width = element.innerWidth;
	      return {
	        top: top,
	        left: left,
	        height: height,
	        width: width,
	        bottom: top + height,
	        right: left + width
	      };
	    }

	    var style, hidden;

	    if (!isVisible(element) && css(element, 'display') === 'none') {
	      style = attr(element, 'style');
	      hidden = attr(element, 'hidden');
	      attr(element, {
	        style: (style || '') + ";display:block !important;",
	        hidden: null
	      });
	    }

	    element = toNode(element);
	    var rect = element.getBoundingClientRect();

	    if (!isUndefined(style)) {
	      attr(element, {
	        style: style,
	        hidden: hidden
	      });
	    }

	    return {
	      height: rect.height,
	      width: rect.width,
	      top: rect.top + top,
	      left: rect.left + left,
	      bottom: rect.bottom + top,
	      right: rect.right + left
	    };
	  }

	  function position(element, parent) {
	    parent = parent || toNode(element).offsetParent || toWindow(element).document.documentElement;
	    var elementOffset = offset(element);
	    var parentOffset = offset(parent);
	    return {
	      top: elementOffset.top - parentOffset.top - toFloat(css(parent, 'borderTopWidth')),
	      left: elementOffset.left - parentOffset.left - toFloat(css(parent, 'borderLeftWidth'))
	    };
	  }

	  function offsetPosition(element) {
	    var offset = [0, 0];
	    element = toNode(element);

	    do {
	      offset[0] += element.offsetTop;
	      offset[1] += element.offsetLeft;

	      if (css(element, 'position') === 'fixed') {
	        var win = toWindow(element);
	        offset[0] += win.pageYOffset;
	        offset[1] += win.pageXOffset;
	        return offset;
	      }
	    } while (element = element.offsetParent);

	    return offset;
	  }

	  var height = dimension('height');
	  var width = dimension('width');

	  function dimension(prop) {
	    var propName = ucfirst(prop);
	    return function (element, value) {
	      if (isUndefined(value)) {
	        if (isWindow(element)) {
	          return element["inner" + propName];
	        }

	        if (isDocument(element)) {
	          var doc = element.documentElement;
	          return Math.max(doc["offset" + propName], doc["scroll" + propName]);
	        }

	        element = toNode(element);
	        value = css(element, prop);
	        value = value === 'auto' ? element["offset" + propName] : toFloat(value) || 0;
	        return value - boxModelAdjust(element, prop);
	      } else {
	        css(element, prop, !value && value !== 0 ? '' : +value + boxModelAdjust(element, prop) + 'px');
	      }
	    };
	  }

	  function boxModelAdjust(element, prop, sizing) {
	    if (sizing === void 0) sizing = 'border-box';
	    return css(element, 'boxSizing') === sizing ? dirs[prop].slice(1).map(ucfirst).reduce(function (value, prop) {
	      return value + toFloat(css(element, "padding" + prop)) + toFloat(css(element, "border" + prop + "Width"));
	    }, 0) : 0;
	  }

	  function moveTo(position, attach, dim, factor) {
	    each(dirs, function (ref, prop) {
	      var dir = ref[0];
	      var align = ref[1];
	      var alignFlip = ref[2];

	      if (attach[dir] === alignFlip) {
	        position[align] += dim[prop] * factor;
	      } else if (attach[dir] === 'center') {
	        position[align] += dim[prop] * factor / 2;
	      }
	    });
	  }

	  function getPos(pos) {
	    var x = /left|center|right/;
	    var y = /top|center|bottom/;
	    pos = (pos || '').split(' ');

	    if (pos.length === 1) {
	      pos = x.test(pos[0]) ? pos.concat('center') : y.test(pos[0]) ? ['center'].concat(pos) : ['center', 'center'];
	    }

	    return {
	      x: x.test(pos[0]) ? pos[0] : 'center',
	      y: y.test(pos[1]) ? pos[1] : 'center'
	    };
	  }

	  function getOffsets(offsets, width, height) {
	    var ref = (offsets || '').split(' ');
	    var x = ref[0];
	    var y = ref[1];
	    return {
	      x: x ? toFloat(x) * (endsWith(x, '%') ? width / 100 : 1) : 0,
	      y: y ? toFloat(y) * (endsWith(y, '%') ? height / 100 : 1) : 0
	    };
	  }

	  function flipPosition(pos) {
	    switch (pos) {
	      case 'left':
	        return 'right';

	      case 'right':
	        return 'left';

	      case 'top':
	        return 'bottom';

	      case 'bottom':
	        return 'top';

	      default:
	        return pos;
	    }
	  }

	  function toPx(value, property, element) {
	    if (property === void 0) property = 'width';
	    if (element === void 0) element = window;
	    return isNumeric(value) ? +value : endsWith(value, 'vh') ? percent(height(toWindow(element)), value) : endsWith(value, 'vw') ? percent(width(toWindow(element)), value) : endsWith(value, '%') ? percent(getDimensions(element)[property], value) : toFloat(value);
	  }

	  function percent(base, value) {
	    return base * toFloat(value) / 100;
	  }
	  /*
	      Based on:
	      Copyright (c) 2016 Wilson Page wilsonpage@me.com
	      https://github.com/wilsonpage/fastdom
	  */


	  var fastdom = {
	    reads: [],
	    writes: [],
	    read: function (task) {
	      this.reads.push(task);
	      scheduleFlush();
	      return task;
	    },
	    write: function (task) {
	      this.writes.push(task);
	      scheduleFlush();
	      return task;
	    },
	    clear: function (task) {
	      return remove$1(this.reads, task) || remove$1(this.writes, task);
	    },
	    flush: flush
	  };

	  function flush(recursion) {
	    if (recursion === void 0) recursion = 1;
	    runTasks(fastdom.reads);
	    runTasks(fastdom.writes.splice(0, fastdom.writes.length));
	    fastdom.scheduled = false;

	    if (fastdom.reads.length || fastdom.writes.length) {
	      scheduleFlush(recursion + 1);
	    }
	  }

	  var RECURSION_LIMIT = 5;

	  function scheduleFlush(recursion) {
	    if (!fastdom.scheduled) {
	      fastdom.scheduled = true;

	      if (recursion > RECURSION_LIMIT) {
	        throw new Error('Maximum recursion limit reached.');
	      } else if (recursion) {
	        Promise.resolve().then(function () {
	          return flush(recursion);
	        });
	      } else {
	        requestAnimationFrame(function () {
	          return flush();
	        });
	      }
	    }
	  }

	  function runTasks(tasks) {
	    var task;

	    while (task = tasks.shift()) {
	      task();
	    }
	  }

	  function remove$1(array, item) {
	    var index = array.indexOf(item);
	    return !!~index && !!array.splice(index, 1);
	  }

	  function MouseTracker() {}

	  MouseTracker.prototype = {
	    positions: [],
	    init: function () {
	      var this$1 = this;
	      this.positions = [];
	      var position;
	      this.unbind = on(document, 'mousemove', function (e) {
	        return position = getEventPos(e);
	      });
	      this.interval = setInterval(function () {
	        if (!position) {
	          return;
	        }

	        this$1.positions.push(position);

	        if (this$1.positions.length > 5) {
	          this$1.positions.shift();
	        }
	      }, 50);
	    },
	    cancel: function () {
	      this.unbind && this.unbind();
	      this.interval && clearInterval(this.interval);
	    },
	    movesTo: function (target) {
	      if (this.positions.length < 2) {
	        return false;
	      }

	      var p = target.getBoundingClientRect();
	      var left = p.left;
	      var right = p.right;
	      var top = p.top;
	      var bottom = p.bottom;
	      var ref = this.positions;
	      var prevPosition = ref[0];
	      var position = last(this.positions);
	      var path = [prevPosition, position];

	      if (pointInRect(position, p)) {
	        return false;
	      }

	      var diagonals = [[{
	        x: left,
	        y: top
	      }, {
	        x: right,
	        y: bottom
	      }], [{
	        x: left,
	        y: bottom
	      }, {
	        x: right,
	        y: top
	      }]];
	      return diagonals.some(function (diagonal) {
	        var intersection = intersect(path, diagonal);
	        return intersection && pointInRect(intersection, p);
	      });
	    }
	  }; // Inspired by http://paulbourke.net/geometry/pointlineplane/

	  function intersect(ref, ref$1) {
	    var ref_0 = ref[0];
	    var x1 = ref_0.x;
	    var y1 = ref_0.y;
	    var ref_1 = ref[1];
	    var x2 = ref_1.x;
	    var y2 = ref_1.y;
	    var ref$1_0 = ref$1[0];
	    var x3 = ref$1_0.x;
	    var y3 = ref$1_0.y;
	    var ref$1_1 = ref$1[1];
	    var x4 = ref$1_1.x;
	    var y4 = ref$1_1.y;
	    var denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1); // Lines are parallel

	    if (denominator === 0) {
	      return false;
	    }

	    var ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;

	    if (ua < 0) {
	      return false;
	    } // Return a object with the x and y coordinates of the intersection


	    return {
	      x: x1 + ua * (x2 - x1),
	      y: y1 + ua * (y2 - y1)
	    };
	  }

	  var strats = {};
	  strats.events = strats.created = strats.beforeConnect = strats.connected = strats.beforeDisconnect = strats.disconnected = strats.destroy = concatStrat; // args strategy

	  strats.args = function (parentVal, childVal) {
	    return childVal !== false && concatStrat(childVal || parentVal);
	  }; // update strategy


	  strats.update = function (parentVal, childVal) {
	    return sortBy(concatStrat(parentVal, isFunction(childVal) ? {
	      read: childVal
	    } : childVal), 'order');
	  }; // property strategy


	  strats.props = function (parentVal, childVal) {
	    if (isArray(childVal)) {
	      childVal = childVal.reduce(function (value, key) {
	        value[key] = String;
	        return value;
	      }, {});
	    }

	    return strats.methods(parentVal, childVal);
	  }; // extend strategy


	  strats.computed = strats.methods = function (parentVal, childVal) {
	    return childVal ? parentVal ? assign({}, parentVal, childVal) : childVal : parentVal;
	  }; // data strategy


	  strats.data = function (parentVal, childVal, vm) {
	    if (!vm) {
	      if (!childVal) {
	        return parentVal;
	      }

	      if (!parentVal) {
	        return childVal;
	      }

	      return function (vm) {
	        return mergeFnData(parentVal, childVal, vm);
	      };
	    }

	    return mergeFnData(parentVal, childVal, vm);
	  };

	  function mergeFnData(parentVal, childVal, vm) {
	    return strats.computed(isFunction(parentVal) ? parentVal.call(vm, vm) : parentVal, isFunction(childVal) ? childVal.call(vm, vm) : childVal);
	  } // concat strategy


	  function concatStrat(parentVal, childVal) {
	    parentVal = parentVal && !isArray(parentVal) ? [parentVal] : parentVal;
	    return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
	  } // default strategy


	  function defaultStrat(parentVal, childVal) {
	    return isUndefined(childVal) ? parentVal : childVal;
	  }

	  function mergeOptions(parent, child, vm) {
	    var options = {};

	    if (isFunction(child)) {
	      child = child.options;
	    }

	    if (child.extends) {
	      parent = mergeOptions(parent, child.extends, vm);
	    }

	    if (child.mixins) {
	      for (var i = 0, l = child.mixins.length; i < l; i++) {
	        parent = mergeOptions(parent, child.mixins[i], vm);
	      }
	    }

	    for (var key in parent) {
	      mergeKey(key);
	    }

	    for (var key$1 in child) {
	      if (!hasOwn(parent, key$1)) {
	        mergeKey(key$1);
	      }
	    }

	    function mergeKey(key) {
	      options[key] = (strats[key] || defaultStrat)(parent[key], child[key], vm);
	    }

	    return options;
	  }

	  function parseOptions(options, args) {
	    var obj;
	    if (args === void 0) args = [];

	    try {
	      return !options ? {} : startsWith(options, '{') ? JSON.parse(options) : args.length && !includes(options, ':') ? (obj = {}, obj[args[0]] = options, obj) : options.split(';').reduce(function (options, option) {
	        var ref = option.split(/:(.*)/);
	        var key = ref[0];
	        var value = ref[1];

	        if (key && !isUndefined(value)) {
	          options[key.trim()] = value.trim();
	        }

	        return options;
	      }, {});
	    } catch (e) {
	      return {};
	    }
	  }

	  var id = 0;

	  var Player = function (el) {
	    this.id = ++id;
	    this.el = toNode(el);
	  };

	  Player.prototype.isVideo = function () {
	    return this.isYoutube() || this.isVimeo() || this.isHTML5();
	  };

	  Player.prototype.isHTML5 = function () {
	    return this.el.tagName === 'VIDEO';
	  };

	  Player.prototype.isIFrame = function () {
	    return this.el.tagName === 'IFRAME';
	  };

	  Player.prototype.isYoutube = function () {
	    return this.isIFrame() && !!this.el.src.match(/\/\/.*?youtube(-nocookie)?\.[a-z]+\/(watch\?v=[^&\s]+|embed)|youtu\.be\/.*/);
	  };

	  Player.prototype.isVimeo = function () {
	    return this.isIFrame() && !!this.el.src.match(/vimeo\.com\/video\/.*/);
	  };

	  Player.prototype.enableApi = function () {
	    var this$1 = this;

	    if (this.ready) {
	      return this.ready;
	    }

	    var youtube = this.isYoutube();
	    var vimeo = this.isVimeo();
	    var poller;

	    if (youtube || vimeo) {
	      return this.ready = new Promise(function (resolve) {
	        once(this$1.el, 'load', function () {
	          if (youtube) {
	            var listener = function () {
	              return post(this$1.el, {
	                event: 'listening',
	                id: this$1.id
	              });
	            };

	            poller = setInterval(listener, 100);
	            listener();
	          }
	        });
	        listen(function (data) {
	          return youtube && data.id === this$1.id && data.event === 'onReady' || vimeo && Number(data.player_id) === this$1.id;
	        }).then(function () {
	          resolve();
	          poller && clearInterval(poller);
	        });
	        attr(this$1.el, 'src', "" + this$1.el.src + (includes(this$1.el.src, '?') ? '&' : '?') + (youtube ? 'enablejsapi=1' : "api=1&player_id=" + this$1.id));
	      });
	    }

	    return Promise.resolve();
	  };

	  Player.prototype.play = function () {
	    var this$1 = this;

	    if (!this.isVideo()) {
	      return;
	    }

	    if (this.isIFrame()) {
	      this.enableApi().then(function () {
	        return post(this$1.el, {
	          func: 'playVideo',
	          method: 'play'
	        });
	      });
	    } else if (this.isHTML5()) {
	      try {
	        var promise = this.el.play();

	        if (promise) {
	          promise.catch(noop);
	        }
	      } catch (e) {}
	    }
	  };

	  Player.prototype.pause = function () {
	    var this$1 = this;

	    if (!this.isVideo()) {
	      return;
	    }

	    if (this.isIFrame()) {
	      this.enableApi().then(function () {
	        return post(this$1.el, {
	          func: 'pauseVideo',
	          method: 'pause'
	        });
	      });
	    } else if (this.isHTML5()) {
	      this.el.pause();
	    }
	  };

	  Player.prototype.mute = function () {
	    var this$1 = this;

	    if (!this.isVideo()) {
	      return;
	    }

	    if (this.isIFrame()) {
	      this.enableApi().then(function () {
	        return post(this$1.el, {
	          func: 'mute',
	          method: 'setVolume',
	          value: 0
	        });
	      });
	    } else if (this.isHTML5()) {
	      this.el.muted = true;
	      attr(this.el, 'muted', '');
	    }
	  };

	  function post(el, cmd) {
	    try {
	      el.contentWindow.postMessage(JSON.stringify(assign({
	        event: 'command'
	      }, cmd)), '*');
	    } catch (e) {}
	  }

	  function listen(cb) {
	    return new Promise(function (resolve) {
	      return once(window, 'message', function (_, data) {
	        return resolve(data);
	      }, false, function (ref) {
	        var data = ref.data;

	        if (!data || !isString(data)) {
	          return;
	        }

	        try {
	          data = JSON.parse(data);
	        } catch (e) {
	          return;
	        }

	        return data && cb(data);
	      });
	    });
	  }

	  function isInView(element, offsetTop, offsetLeft) {
	    if (offsetTop === void 0) offsetTop = 0;
	    if (offsetLeft === void 0) offsetLeft = 0;

	    if (!isVisible(element)) {
	      return false;
	    }

	    var parents = overflowParents(element).concat(element);

	    for (var i = 0; i < parents.length - 1; i++) {
	      var ref = offset(getViewport(parents[i]));
	      var top = ref.top;
	      var left = ref.left;
	      var bottom = ref.bottom;
	      var right = ref.right;
	      var vp = {
	        top: top - offsetTop,
	        left: left - offsetLeft,
	        bottom: bottom + offsetTop,
	        right: right + offsetLeft
	      };
	      var client = offset(parents[i + 1]);

	      if (!intersectRect(client, vp) && !pointInRect({
	        x: client.left,
	        y: client.top
	      }, vp)) {
	        return false;
	      }
	    }

	    return true;
	  }

	  function scrollTop(element, top) {
	    if (isWindow(element) || isDocument(element)) {
	      element = getScrollingElement(element);
	    } else {
	      element = toNode(element);
	    }

	    element.scrollTop = top;
	  }

	  function scrollIntoView(element, ref) {
	    if (ref === void 0) ref = {};
	    var offsetBy = ref.offset;
	    if (offsetBy === void 0) offsetBy = 0;

	    if (!isVisible(element)) {
	      return;
	    }

	    var parents = overflowParents(element).concat(element);
	    var promise = Promise.resolve();

	    var loop = function (i) {
	      promise = promise.then(function () {
	        return new Promise(function (resolve) {
	          var scrollElement = parents[i];
	          var element = parents[i + 1];
	          var scroll = scrollElement.scrollTop;
	          var top = Math.ceil(position(element, getViewport(scrollElement)).top - offsetBy);
	          var duration = getDuration(Math.abs(top));
	          var start = Date.now();

	          var step = function () {
	            var percent = ease(clamp((Date.now() - start) / duration));
	            scrollTop(scrollElement, scroll + top * percent); // scroll more if we have not reached our destination

	            if (percent !== 1) {
	              requestAnimationFrame(step);
	            } else {
	              resolve();
	            }
	          };

	          step();
	        });
	      });
	    };

	    for (var i = 0; i < parents.length - 1; i++) loop(i);

	    return promise;

	    function getDuration(dist) {
	      return 40 * Math.pow(dist, .375);
	    }

	    function ease(k) {
	      return 0.5 * (1 - Math.cos(Math.PI * k));
	    }
	  }

	  function scrolledOver(element, heightOffset) {
	    if (heightOffset === void 0) heightOffset = 0;

	    if (!isVisible(element)) {
	      return 0;
	    }

	    var scrollElement = last(scrollParents(element));
	    var scrollHeight = scrollElement.scrollHeight;
	    var scrollTop = scrollElement.scrollTop;
	    var viewport = getViewport(scrollElement);
	    var viewportHeight = offset(viewport).height;
	    var viewportTop = offsetPosition(element)[0] - scrollTop - offsetPosition(scrollElement)[0];
	    var viewportDist = Math.min(viewportHeight, viewportTop + scrollTop);
	    var top = viewportTop - viewportDist;
	    var dist = Math.min(offset(element).height + heightOffset + viewportDist, scrollHeight - (viewportTop + scrollTop), scrollHeight - viewportHeight);
	    return clamp(-1 * top / dist);
	  }

	  function scrollParents(element, overflowRe) {
	    if (overflowRe === void 0) overflowRe = /auto|scroll/;
	    var scrollEl = getScrollingElement(element);
	    var scrollParents = parents(element).filter(function (parent) {
	      return parent === scrollEl || overflowRe.test(css(parent, 'overflow')) && parent.scrollHeight > Math.round(offset(parent).height);
	    }).reverse();
	    return scrollParents.length ? scrollParents : [scrollEl];
	  }

	  function getViewport(scrollElement) {
	    return scrollElement === getScrollingElement(scrollElement) ? window : scrollElement;
	  }

	  function overflowParents(element) {
	    return scrollParents(element, /auto|scroll|hidden/);
	  }

	  function getScrollingElement(element) {
	    var ref = toWindow(element);
	    var document = ref.document;
	    return document.scrollingElement || document.documentElement;
	  }

	  var IntersectionObserver = 'IntersectionObserver' in window ? window.IntersectionObserver : /*@__PURE__*/function () {
	    function IntersectionObserverClass(callback, ref) {
	      var this$1 = this;
	      if (ref === void 0) ref = {};
	      var rootMargin = ref.rootMargin;
	      if (rootMargin === void 0) rootMargin = '0 0';
	      this.targets = [];
	      var ref$1 = (rootMargin || '0 0').split(' ').map(toFloat);
	      var offsetTop = ref$1[0];
	      var offsetLeft = ref$1[1];
	      this.offsetTop = offsetTop;
	      this.offsetLeft = offsetLeft;
	      var pending;

	      this.apply = function () {
	        if (pending) {
	          return;
	        }

	        pending = requestAnimationFrame(function () {
	          return setTimeout(function () {
	            var records = this$1.takeRecords();

	            if (records.length) {
	              callback(records, this$1);
	            }

	            pending = false;
	          });
	        });
	      };

	      this.off = on(window, 'scroll resize load', this.apply, {
	        passive: true,
	        capture: true
	      });
	    }

	    IntersectionObserverClass.prototype.takeRecords = function () {
	      var this$1 = this;
	      return this.targets.filter(function (entry) {
	        var inView = isInView(entry.target, this$1.offsetTop, this$1.offsetLeft);

	        if (entry.isIntersecting === null || inView ^ entry.isIntersecting) {
	          entry.isIntersecting = inView;
	          return true;
	        }
	      });
	    };

	    IntersectionObserverClass.prototype.observe = function (target) {
	      this.targets.push({
	        target: target,
	        isIntersecting: null
	      });
	      this.apply();
	    };

	    IntersectionObserverClass.prototype.disconnect = function () {
	      this.targets = [];
	      this.off();
	    };

	    return IntersectionObserverClass;
	  }();
	  var util = /*#__PURE__*/Object.freeze({
	    __proto__: null,
	    ajax: ajax,
	    getImage: getImage,
	    transition: transition,
	    Transition: Transition,
	    animate: animate,
	    Animation: Animation,
	    attr: attr,
	    hasAttr: hasAttr,
	    removeAttr: removeAttr,
	    data: data,
	    addClass: addClass,
	    removeClass: removeClass,
	    removeClasses: removeClasses,
	    replaceClass: replaceClass,
	    hasClass: hasClass,
	    toggleClass: toggleClass,
	    positionAt: positionAt,
	    offset: offset,
	    position: position,
	    offsetPosition: offsetPosition,
	    height: height,
	    width: width,
	    boxModelAdjust: boxModelAdjust,
	    flipPosition: flipPosition,
	    toPx: toPx,
	    ready: ready,
	    index: index,
	    getIndex: getIndex,
	    empty: empty,
	    html: html,
	    prepend: prepend,
	    append: append,
	    before: before,
	    after: after,
	    remove: remove,
	    wrapAll: wrapAll,
	    wrapInner: wrapInner,
	    unwrap: unwrap,
	    fragment: fragment,
	    apply: apply,
	    $: $,
	    $$: $$,
	    isIE: isIE,
	    isRtl: isRtl,
	    hasTouch: hasTouch,
	    pointerDown: pointerDown,
	    pointerMove: pointerMove,
	    pointerUp: pointerUp,
	    pointerEnter: pointerEnter,
	    pointerLeave: pointerLeave,
	    pointerCancel: pointerCancel,
	    on: on,
	    off: off,
	    once: once,
	    trigger: trigger,
	    createEvent: createEvent,
	    toEventTargets: toEventTargets,
	    isTouch: isTouch,
	    getEventPos: getEventPos,
	    fastdom: fastdom,
	    isVoidElement: isVoidElement,
	    isVisible: isVisible,
	    selInput: selInput,
	    isInput: isInput,
	    filter: filter,
	    within: within,
	    parents: parents,
	    children: children,
	    hasOwn: hasOwn,
	    hyphenate: hyphenate,
	    camelize: camelize,
	    ucfirst: ucfirst,
	    startsWith: startsWith,
	    endsWith: endsWith,
	    includes: includes,
	    findIndex: findIndex,
	    isArray: isArray,
	    isFunction: isFunction,
	    isObject: isObject,
	    isPlainObject: isPlainObject,
	    isWindow: isWindow,
	    isDocument: isDocument,
	    isJQuery: isJQuery,
	    isNode: isNode,
	    isElement: isElement,
	    isNodeCollection: isNodeCollection,
	    isBoolean: isBoolean,
	    isString: isString,
	    isNumber: isNumber,
	    isNumeric: isNumeric,
	    isEmpty: isEmpty,
	    isUndefined: isUndefined,
	    toBoolean: toBoolean,
	    toNumber: toNumber,
	    toFloat: toFloat,
	    toNode: toNode,
	    toNodes: toNodes,
	    toWindow: toWindow,
	    toList: toList,
	    toMs: toMs,
	    isEqual: isEqual,
	    swap: swap,
	    assign: assign,
	    last: last,
	    each: each,
	    sortBy: sortBy,
	    uniqueBy: uniqueBy,
	    clamp: clamp,
	    noop: noop,
	    intersectRect: intersectRect,
	    pointInRect: pointInRect,
	    Dimensions: Dimensions,
	    MouseTracker: MouseTracker,
	    mergeOptions: mergeOptions,
	    parseOptions: parseOptions,
	    Player: Player,
	    Promise: Promise,
	    Deferred: Deferred,
	    IntersectionObserver: IntersectionObserver,
	    query: query,
	    queryAll: queryAll,
	    find: find,
	    findAll: findAll,
	    matches: matches,
	    closest: closest,
	    parent: parent,
	    escape: escape,
	    css: css,
	    getStyles: getStyles,
	    getStyle: getStyle,
	    getCssVar: getCssVar,
	    propName: propName,
	    isInView: isInView,
	    scrollTop: scrollTop,
	    scrollIntoView: scrollIntoView,
	    scrolledOver: scrolledOver,
	    scrollParents: scrollParents,
	    getViewport: getViewport
	  });

	  function globalAPI(UIkit) {
	    var DATA = UIkit.data;

	    UIkit.use = function (plugin) {
	      if (plugin.installed) {
	        return;
	      }

	      plugin.call(null, this);
	      plugin.installed = true;
	      return this;
	    };

	    UIkit.mixin = function (mixin, component) {
	      component = (isString(component) ? UIkit.component(component) : component) || this;
	      component.options = mergeOptions(component.options, mixin);
	    };

	    UIkit.extend = function (options) {
	      options = options || {};
	      var Super = this;

	      var Sub = function UIkitComponent(options) {
	        this._init(options);
	      };

	      Sub.prototype = Object.create(Super.prototype);
	      Sub.prototype.constructor = Sub;
	      Sub.options = mergeOptions(Super.options, options);
	      Sub.super = Super;
	      Sub.extend = Super.extend;
	      return Sub;
	    };

	    UIkit.update = function (element, e) {
	      element = element ? toNode(element) : document.body;
	      parents(element).reverse().forEach(function (element) {
	        return update(element[DATA], e);
	      });
	      apply(element, function (element) {
	        return update(element[DATA], e);
	      });
	    };

	    var container;
	    Object.defineProperty(UIkit, 'container', {
	      get: function () {
	        return container || document.body;
	      },
	      set: function (element) {
	        container = $(element);
	      }
	    });

	    function update(data, e) {
	      if (!data) {
	        return;
	      }

	      for (var name in data) {
	        if (data[name]._connected) {
	          data[name]._callUpdate(e);
	        }
	      }
	    }
	  }

	  function hooksAPI(UIkit) {
	    UIkit.prototype._callHook = function (hook) {
	      var this$1 = this;
	      var handlers = this.$options[hook];

	      if (handlers) {
	        handlers.forEach(function (handler) {
	          return handler.call(this$1);
	        });
	      }
	    };

	    UIkit.prototype._callConnected = function () {
	      if (this._connected) {
	        return;
	      }

	      this._data = {};
	      this._computeds = {};
	      this._frames = {
	        reads: {},
	        writes: {}
	      };

	      this._initProps();

	      this._callHook('beforeConnect');

	      this._connected = true;

	      this._initEvents();

	      this._initObserver();

	      this._callHook('connected');

	      this._callUpdate();
	    };

	    UIkit.prototype._callDisconnected = function () {
	      if (!this._connected) {
	        return;
	      }

	      this._callHook('beforeDisconnect');

	      if (this._observer) {
	        this._observer.disconnect();

	        this._observer = null;
	      }

	      this._unbindEvents();

	      this._callHook('disconnected');

	      this._connected = false;
	    };

	    UIkit.prototype._callUpdate = function (e) {
	      var this$1 = this;
	      if (e === void 0) e = 'update';
	      var type = e.type || e;

	      if (includes(['update', 'resize'], type)) {
	        this._callWatches();
	      }

	      var updates = this.$options.update;
	      var ref = this._frames;
	      var reads = ref.reads;
	      var writes = ref.writes;

	      if (!updates) {
	        return;
	      }

	      updates.forEach(function (ref, i) {
	        var read = ref.read;
	        var write = ref.write;
	        var events = ref.events;

	        if (type !== 'update' && !includes(events, type)) {
	          return;
	        }

	        if (read && !includes(fastdom.reads, reads[i])) {
	          reads[i] = fastdom.read(function () {
	            var result = this$1._connected && read.call(this$1, this$1._data, type);

	            if (result === false && write) {
	              fastdom.clear(writes[i]);
	            } else if (isPlainObject(result)) {
	              assign(this$1._data, result);
	            }
	          });
	        }

	        if (write && !includes(fastdom.writes, writes[i])) {
	          writes[i] = fastdom.write(function () {
	            return this$1._connected && write.call(this$1, this$1._data, type);
	          });
	        }
	      });
	    };

	    UIkit.prototype._callWatches = function () {
	      var this$1 = this;
	      var ref = this;
	      var _frames = ref._frames;

	      if (_frames.watch) {
	        return;
	      }

	      var initital = !hasOwn(_frames, 'watch');
	      _frames.watch = fastdom.read(function () {
	        if (!this$1._connected) {
	          return;
	        }

	        var ref = this$1;
	        var computed = ref.$options.computed;
	        var _computeds = ref._computeds;

	        for (var key in computed) {
	          var hasPrev = hasOwn(_computeds, key);
	          var prev = _computeds[key];
	          delete _computeds[key];
	          var ref$1 = computed[key];
	          var watch = ref$1.watch;
	          var immediate = ref$1.immediate;

	          if (watch && (initital && immediate || hasPrev && !isEqual(prev, this$1[key]))) {
	            watch.call(this$1, this$1[key], prev);
	          }
	        }

	        _frames.watch = null;
	      });
	    };
	  }

	  function stateAPI(UIkit) {
	    var uid = 0;

	    UIkit.prototype._init = function (options) {
	      options = options || {};
	      options.data = normalizeData(options, this.constructor.options);
	      this.$options = mergeOptions(this.constructor.options, options, this);
	      this.$el = null;
	      this.$props = {};
	      this._uid = uid++;

	      this._initData();

	      this._initMethods();

	      this._initComputeds();

	      this._callHook('created');

	      if (options.el) {
	        this.$mount(options.el);
	      }
	    };

	    UIkit.prototype._initData = function () {
	      var ref = this.$options;
	      var data = ref.data;
	      if (data === void 0) data = {};

	      for (var key in data) {
	        this.$props[key] = this[key] = data[key];
	      }
	    };

	    UIkit.prototype._initMethods = function () {
	      var ref = this.$options;
	      var methods = ref.methods;

	      if (methods) {
	        for (var key in methods) {
	          this[key] = methods[key].bind(this);
	        }
	      }
	    };

	    UIkit.prototype._initComputeds = function () {
	      var ref = this.$options;
	      var computed = ref.computed;
	      this._computeds = {};

	      if (computed) {
	        for (var key in computed) {
	          registerComputed(this, key, computed[key]);
	        }
	      }
	    };

	    UIkit.prototype._initProps = function (props) {
	      var key;
	      props = props || getProps(this.$options, this.$name);

	      for (key in props) {
	        if (!isUndefined(props[key])) {
	          this.$props[key] = props[key];
	        }
	      }

	      var exclude = [this.$options.computed, this.$options.methods];

	      for (key in this.$props) {
	        if (key in props && notIn(exclude, key)) {
	          this[key] = this.$props[key];
	        }
	      }
	    };

	    UIkit.prototype._initEvents = function () {
	      var this$1 = this;
	      this._events = [];
	      var ref = this.$options;
	      var events = ref.events;

	      if (events) {
	        events.forEach(function (event) {
	          if (!hasOwn(event, 'handler')) {
	            for (var key in event) {
	              registerEvent(this$1, event[key], key);
	            }
	          } else {
	            registerEvent(this$1, event);
	          }
	        });
	      }
	    };

	    UIkit.prototype._unbindEvents = function () {
	      this._events.forEach(function (unbind) {
	        return unbind();
	      });

	      delete this._events;
	    };

	    UIkit.prototype._initObserver = function () {
	      var this$1 = this;
	      var ref = this.$options;
	      var attrs = ref.attrs;
	      var props = ref.props;
	      var el = ref.el;

	      if (this._observer || !props || attrs === false) {
	        return;
	      }

	      attrs = isArray(attrs) ? attrs : Object.keys(props);
	      this._observer = new MutationObserver(function () {
	        var data = getProps(this$1.$options, this$1.$name);

	        if (attrs.some(function (key) {
	          return !isUndefined(data[key]) && data[key] !== this$1.$props[key];
	        })) {
	          this$1.$reset();
	        }
	      });
	      var filter = attrs.map(function (key) {
	        return hyphenate(key);
	      }).concat(this.$name);

	      this._observer.observe(el, {
	        attributes: true,
	        attributeFilter: filter.concat(filter.map(function (key) {
	          return "data-" + key;
	        }))
	      });
	    };

	    function getProps(opts, name) {
	      var data$1 = {};
	      var args = opts.args;
	      if (args === void 0) args = [];
	      var props = opts.props;
	      if (props === void 0) props = {};
	      var el = opts.el;

	      if (!props) {
	        return data$1;
	      }

	      for (var key in props) {
	        var prop = hyphenate(key);
	        var value = data(el, prop);

	        if (!isUndefined(value)) {
	          value = props[key] === Boolean && value === '' ? true : coerce(props[key], value);

	          if (prop === 'target' && (!value || startsWith(value, '_'))) {
	            continue;
	          }

	          data$1[key] = value;
	        }
	      }

	      var options = parseOptions(data(el, name), args);

	      for (var key$1 in options) {
	        var prop$1 = camelize(key$1);

	        if (props[prop$1] !== undefined) {
	          data$1[prop$1] = coerce(props[prop$1], options[key$1]);
	        }
	      }

	      return data$1;
	    }

	    function registerComputed(component, key, cb) {
	      Object.defineProperty(component, key, {
	        enumerable: true,
	        get: function () {
	          var _computeds = component._computeds;
	          var $props = component.$props;
	          var $el = component.$el;

	          if (!hasOwn(_computeds, key)) {
	            _computeds[key] = (cb.get || cb).call(component, $props, $el);
	          }

	          return _computeds[key];
	        },
	        set: function (value) {
	          var _computeds = component._computeds;
	          _computeds[key] = cb.set ? cb.set.call(component, value) : value;

	          if (isUndefined(_computeds[key])) {
	            delete _computeds[key];
	          }
	        }
	      });
	    }

	    function registerEvent(component, event, key) {
	      if (!isPlainObject(event)) {
	        event = {
	          name: key,
	          handler: event
	        };
	      }

	      var name = event.name;
	      var el = event.el;
	      var handler = event.handler;
	      var capture = event.capture;
	      var passive = event.passive;
	      var delegate = event.delegate;
	      var filter = event.filter;
	      var self = event.self;
	      el = isFunction(el) ? el.call(component) : el || component.$el;

	      if (isArray(el)) {
	        el.forEach(function (el) {
	          return registerEvent(component, assign({}, event, {
	            el: el
	          }), key);
	        });
	        return;
	      }

	      if (!el || filter && !filter.call(component)) {
	        return;
	      }

	      component._events.push(on(el, name, !delegate ? null : isString(delegate) ? delegate : delegate.call(component), isString(handler) ? component[handler] : handler.bind(component), {
	        passive: passive,
	        capture: capture,
	        self: self
	      }));
	    }

	    function notIn(options, key) {
	      return options.every(function (arr) {
	        return !arr || !hasOwn(arr, key);
	      });
	    }

	    function coerce(type, value) {
	      if (type === Boolean) {
	        return toBoolean(value);
	      } else if (type === Number) {
	        return toNumber(value);
	      } else if (type === 'list') {
	        return toList(value);
	      }

	      return type ? type(value) : value;
	    }

	    function normalizeData(ref, ref$1) {
	      var data = ref.data;
	      var el = ref.el;
	      var args = ref$1.args;
	      var props = ref$1.props;
	      if (props === void 0) props = {};
	      data = isArray(data) ? !isEmpty(args) ? data.slice(0, args.length).reduce(function (data, value, index) {
	        if (isPlainObject(value)) {
	          assign(data, value);
	        } else {
	          data[args[index]] = value;
	        }

	        return data;
	      }, {}) : undefined : data;

	      if (data) {
	        for (var key in data) {
	          if (isUndefined(data[key])) {
	            delete data[key];
	          } else {
	            data[key] = props[key] ? coerce(props[key], data[key]) : data[key];
	          }
	        }
	      }

	      return data;
	    }
	  }

	  function instanceAPI(UIkit) {
	    var DATA = UIkit.data;

	    UIkit.prototype.$create = function (component, element, data) {
	      return UIkit[component](element, data);
	    };

	    UIkit.prototype.$mount = function (el) {
	      var ref = this.$options;
	      var name = ref.name;

	      if (!el[DATA]) {
	        el[DATA] = {};
	      }

	      if (el[DATA][name]) {
	        return;
	      }

	      el[DATA][name] = this;
	      this.$el = this.$options.el = this.$options.el || el;

	      if (within(el, document)) {
	        this._callConnected();
	      }
	    };

	    UIkit.prototype.$reset = function () {
	      this._callDisconnected();

	      this._callConnected();
	    };

	    UIkit.prototype.$destroy = function (removeEl) {
	      if (removeEl === void 0) removeEl = false;
	      var ref = this.$options;
	      var el = ref.el;
	      var name = ref.name;

	      if (el) {
	        this._callDisconnected();
	      }

	      this._callHook('destroy');

	      if (!el || !el[DATA]) {
	        return;
	      }

	      delete el[DATA][name];

	      if (!isEmpty(el[DATA])) {
	        delete el[DATA];
	      }

	      if (removeEl) {
	        remove(this.$el);
	      }
	    };

	    UIkit.prototype.$emit = function (e) {
	      this._callUpdate(e);
	    };

	    UIkit.prototype.$update = function (element, e) {
	      if (element === void 0) element = this.$el;
	      UIkit.update(element, e);
	    };

	    UIkit.prototype.$getComponent = UIkit.getComponent;
	    var names = {};
	    Object.defineProperties(UIkit.prototype, {
	      $container: Object.getOwnPropertyDescriptor(UIkit, 'container'),
	      $name: {
	        get: function () {
	          var ref = this.$options;
	          var name = ref.name;

	          if (!names[name]) {
	            names[name] = UIkit.prefix + hyphenate(name);
	          }

	          return names[name];
	        }
	      }
	    });
	  }

	  function componentAPI(UIkit) {
	    var DATA = UIkit.data;
	    var components = {};

	    UIkit.component = function (name, options) {
	      var id = hyphenate(name);
	      name = camelize(id);

	      if (!options) {
	        if (isPlainObject(components[name])) {
	          components[name] = UIkit.extend(components[name]);
	        }

	        return components[name];
	      }

	      UIkit[name] = function (element, data) {
	        var i = arguments.length,
	            argsArray = Array(i);

	        while (i--) argsArray[i] = arguments[i];

	        var component = UIkit.component(name);
	        return component.options.functional ? new component({
	          data: isPlainObject(element) ? element : [].concat(argsArray)
	        }) : !element ? init(element) : $$(element).map(init)[0];

	        function init(element) {
	          var instance = UIkit.getComponent(element, name);

	          if (instance) {
	            if (!data) {
	              return instance;
	            } else {
	              instance.$destroy();
	            }
	          }

	          return new component({
	            el: element,
	            data: data
	          });
	        }
	      };

	      var opt = isPlainObject(options) ? assign({}, options) : options.options;
	      opt.name = name;

	      if (opt.install) {
	        opt.install(UIkit, opt, name);
	      }

	      if (UIkit._initialized && !opt.functional) {
	        fastdom.read(function () {
	          return UIkit[name]("[uk-" + id + "],[data-uk-" + id + "]");
	        });
	      }

	      return components[name] = isPlainObject(options) ? opt : options;
	    };

	    UIkit.getComponents = function (element) {
	      return element && element[DATA] || {};
	    };

	    UIkit.getComponent = function (element, name) {
	      return UIkit.getComponents(element)[name];
	    };

	    UIkit.connect = function (node) {
	      if (node[DATA]) {
	        for (var name in node[DATA]) {
	          node[DATA][name]._callConnected();
	        }
	      }

	      for (var i = 0; i < node.attributes.length; i++) {
	        var name$1 = getComponentName(node.attributes[i].name);

	        if (name$1 && name$1 in components) {
	          UIkit[name$1](node);
	        }
	      }
	    };

	    UIkit.disconnect = function (node) {
	      for (var name in node[DATA]) {
	        node[DATA][name]._callDisconnected();
	      }
	    };
	  }

	  function getComponentName(attribute) {
	    return startsWith(attribute, 'uk-') || startsWith(attribute, 'data-uk-') ? camelize(attribute.replace('data-uk-', '').replace('uk-', '')) : false;
	  }

	  var UIkit = function (options) {
	    this._init(options);
	  };

	  UIkit.util = util;
	  UIkit.data = '__uikit__';
	  UIkit.prefix = 'uk-';
	  UIkit.options = {};
	  UIkit.version = '3.4.2';
	  globalAPI(UIkit);
	  hooksAPI(UIkit);
	  stateAPI(UIkit);
	  componentAPI(UIkit);
	  instanceAPI(UIkit);

	  function Core(UIkit) {
	    ready(function () {
	      UIkit.update();
	      on(window, 'load resize', function () {
	        return UIkit.update(null, 'resize');
	      });
	      on(document, 'loadedmetadata load', function (ref) {
	        var target = ref.target;
	        return UIkit.update(target, 'resize');
	      }, true); // throttle `scroll` event (Safari triggers multiple `scroll` events per frame)

	      var pending;
	      on(window, 'scroll', function (e) {
	        if (pending) {
	          return;
	        }

	        pending = true;
	        fastdom.write(function () {
	          return pending = false;
	        });
	        UIkit.update(null, e.type);
	      }, {
	        passive: true,
	        capture: true
	      });
	      var started = 0;
	      on(document, 'animationstart', function (ref) {
	        var target = ref.target;

	        if ((css(target, 'animationName') || '').match(/^uk-.*(left|right)/)) {
	          started++;
	          css(document.body, 'overflowX', 'hidden');
	          setTimeout(function () {
	            if (! --started) {
	              css(document.body, 'overflowX', '');
	            }
	          }, toMs(css(target, 'animationDuration')) + 100);
	        }
	      }, true);
	      var off;
	      on(document, pointerDown, function (e) {
	        off && off();

	        if (!isTouch(e)) {
	          return;
	        } // Handle Swipe Gesture


	        var pos = getEventPos(e);
	        var target = 'tagName' in e.target ? e.target : e.target.parentNode;
	        off = once(document, pointerUp + " " + pointerCancel, function (e) {
	          var ref = getEventPos(e);
	          var x = ref.x;
	          var y = ref.y; // swipe

	          if (target && x && Math.abs(pos.x - x) > 100 || y && Math.abs(pos.y - y) > 100) {
	            setTimeout(function () {
	              trigger(target, 'swipe');
	              trigger(target, "swipe" + swipeDirection(pos.x, pos.y, x, y));
	            });
	          }
	        });
	      }, {
	        passive: true
	      });
	    });
	  }

	  function swipeDirection(x1, y1, x2, y2) {
	    return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ? x1 - x2 > 0 ? 'Left' : 'Right' : y1 - y2 > 0 ? 'Up' : 'Down';
	  }

	  function boot(UIkit) {
	    var connect = UIkit.connect;
	    var disconnect = UIkit.disconnect;

	    if (!('MutationObserver' in window)) {
	      return;
	    }

	    fastdom.read(init);

	    function init() {
	      if (document.body) {
	        apply(document.body, connect);
	      }

	      new MutationObserver(function (mutations) {
	        var updates = [];
	        mutations.forEach(function (mutation) {
	          return applyMutation(mutation, updates);
	        });
	        updates.forEach(function (el) {
	          return UIkit.update(el);
	        });
	      }).observe(document, {
	        childList: true,
	        subtree: true,
	        characterData: true,
	        attributes: true
	      });
	      UIkit._initialized = true;
	    }

	    function applyMutation(mutation, updates) {
	      var target = mutation.target;
	      var type = mutation.type;
	      var update = type !== 'attributes' ? applyChildList(mutation) : applyAttribute(mutation);

	      if (update && !updates.some(function (element) {
	        return element.contains(target);
	      })) {
	        updates.push(target.contains ? target : target.parentNode); // IE 11 text node does not implement contains
	      }
	    }

	    function applyAttribute(ref) {
	      var target = ref.target;
	      var attributeName = ref.attributeName;

	      if (attributeName === 'href') {
	        return true;
	      }

	      var name = getComponentName(attributeName);

	      if (!name || !(name in UIkit)) {
	        return;
	      }

	      if (hasAttr(target, attributeName)) {
	        UIkit[name](target);
	        return true;
	      }

	      var component = UIkit.getComponent(target, name);

	      if (component) {
	        component.$destroy();
	        return true;
	      }
	    }

	    function applyChildList(ref) {
	      var addedNodes = ref.addedNodes;
	      var removedNodes = ref.removedNodes;

	      for (var i = 0; i < addedNodes.length; i++) {
	        apply(addedNodes[i], connect);
	      }

	      for (var i$1 = 0; i$1 < removedNodes.length; i$1++) {
	        apply(removedNodes[i$1], disconnect);
	      }

	      return true;
	    }
	  }

	  var Class = {
	    connected: function () {
	      !hasClass(this.$el, this.$name) && addClass(this.$el, this.$name);
	    }
	  };
	  var Togglable = {
	    props: {
	      cls: Boolean,
	      animation: 'list',
	      duration: Number,
	      origin: String,
	      transition: String,
	      queued: Boolean
	    },
	    data: {
	      cls: false,
	      animation: [false],
	      duration: 200,
	      origin: false,
	      transition: 'linear',
	      queued: false,
	      initProps: {
	        overflow: '',
	        height: '',
	        paddingTop: '',
	        paddingBottom: '',
	        marginTop: '',
	        marginBottom: ''
	      },
	      hideProps: {
	        overflow: 'hidden',
	        height: 0,
	        paddingTop: 0,
	        paddingBottom: 0,
	        marginTop: 0,
	        marginBottom: 0
	      }
	    },
	    computed: {
	      hasAnimation: function (ref) {
	        var animation = ref.animation;
	        return !!animation[0];
	      },
	      hasTransition: function (ref) {
	        var animation = ref.animation;
	        return this.hasAnimation && animation[0] === true;
	      }
	    },
	    methods: {
	      toggleElement: function (targets, show, animate) {
	        var this$1 = this;
	        return new Promise(function (resolve) {
	          targets = toNodes(targets);

	          var all = function (targets) {
	            return Promise.all(targets.map(function (el) {
	              return this$1._toggleElement(el, show, animate);
	            }));
	          };

	          var p;

	          if (!this$1.queued || !isUndefined(show) || !this$1.hasAnimation || targets.length < 2) {
	            p = all(targets);
	          } else {
	            var toggled = targets.filter(function (el) {
	              return this$1.isToggled(el);
	            });
	            var untoggled = targets.filter(function (el) {
	              return !includes(toggled, el);
	            });
	            var body = document.body;
	            var scroll = body.scrollTop;
	            var el = toggled[0];
	            var inProgress = Animation.inProgress(el) && hasClass(el, 'uk-animation-leave') || Transition.inProgress(el) && el.style.height === '0px';
	            p = all(toggled);

	            if (!inProgress) {
	              p = p.then(function () {
	                var p = all(untoggled);
	                body.scrollTop = scroll;
	                return p;
	              });
	            }
	          }

	          p.then(resolve, noop);
	        });
	      },
	      isToggled: function (el) {
	        var nodes = toNodes(el || this.$el);
	        return this.cls ? hasClass(nodes, this.cls.split(' ')[0]) : !hasAttr(nodes, 'hidden');
	      },
	      updateAria: function (el) {
	        if (this.cls === false) {
	          attr(el, 'aria-hidden', !this.isToggled(el));
	        }
	      },
	      _toggleElement: function (el, show, animate) {
	        var this$1 = this;
	        show = isBoolean(show) ? show : Animation.inProgress(el) ? hasClass(el, 'uk-animation-leave') : Transition.inProgress(el) ? el.style.height === '0px' : !this.isToggled(el);

	        if (!trigger(el, "before" + (show ? 'show' : 'hide'), [this])) {
	          return Promise.reject();
	        }

	        var promise = (isFunction(animate) ? animate : animate === false || !this.hasAnimation ? this._toggle : this.hasTransition ? toggleHeight(this) : toggleAnimation(this))(el, show);
	        trigger(el, show ? 'show' : 'hide', [this]);

	        var final = function () {
	          trigger(el, show ? 'shown' : 'hidden', [this$1]);
	          this$1.$update(el);
	        };

	        return promise ? promise.then(final) : Promise.resolve(final());
	      },
	      _toggle: function (el, toggled) {
	        if (!el) {
	          return;
	        }

	        toggled = Boolean(toggled);
	        var changed;

	        if (this.cls) {
	          changed = includes(this.cls, ' ') || toggled !== hasClass(el, this.cls);
	          changed && toggleClass(el, this.cls, includes(this.cls, ' ') ? undefined : toggled);
	        } else {
	          changed = toggled === hasAttr(el, 'hidden');
	          changed && attr(el, 'hidden', !toggled ? '' : null);
	        }

	        $$('[autofocus]', el).some(function (el) {
	          return isVisible(el) ? el.focus() || true : el.blur();
	        });
	        this.updateAria(el);

	        if (changed) {
	          trigger(el, 'toggled', [this]);
	          this.$update(el);
	        }
	      }
	    }
	  };

	  function toggleHeight(ref) {
	    var isToggled = ref.isToggled;
	    var duration = ref.duration;
	    var initProps = ref.initProps;
	    var hideProps = ref.hideProps;
	    var transition = ref.transition;
	    var _toggle = ref._toggle;
	    return function (el, show) {
	      var inProgress = Transition.inProgress(el);
	      var inner = el.hasChildNodes ? toFloat(css(el.firstElementChild, 'marginTop')) + toFloat(css(el.lastElementChild, 'marginBottom')) : 0;
	      var currentHeight = isVisible(el) ? height(el) + (inProgress ? 0 : inner) : 0;
	      Transition.cancel(el);

	      if (!isToggled(el)) {
	        _toggle(el, true);
	      }

	      height(el, ''); // Update child components first

	      fastdom.flush();
	      var endHeight = height(el) + (inProgress ? 0 : inner);
	      height(el, currentHeight);
	      return (show ? Transition.start(el, assign({}, initProps, {
	        overflow: 'hidden',
	        height: endHeight
	      }), Math.round(duration * (1 - currentHeight / endHeight)), transition) : Transition.start(el, hideProps, Math.round(duration * (currentHeight / endHeight)), transition).then(function () {
	        return _toggle(el, false);
	      })).then(function () {
	        return css(el, initProps);
	      });
	    };
	  }

	  function toggleAnimation(cmp) {
	    return function (el, show) {
	      Animation.cancel(el);
	      var animation = cmp.animation;
	      var duration = cmp.duration;
	      var _toggle = cmp._toggle;

	      if (show) {
	        _toggle(el, true);

	        return Animation.in(el, animation[0], duration, cmp.origin);
	      }

	      return Animation.out(el, animation[1] || animation[0], duration, cmp.origin).then(function () {
	        return _toggle(el, false);
	      });
	    };
	  }

	  var Accordion = {
	    mixins: [Class, Togglable],
	    props: {
	      targets: String,
	      active: null,
	      collapsible: Boolean,
	      multiple: Boolean,
	      toggle: String,
	      content: String,
	      transition: String,
	      offset: Number
	    },
	    data: {
	      targets: '> *',
	      active: false,
	      animation: [true],
	      collapsible: true,
	      multiple: false,
	      clsOpen: 'uk-open',
	      toggle: '> .uk-accordion-title',
	      content: '> .uk-accordion-content',
	      transition: 'ease',
	      offset: 0
	    },
	    computed: {
	      items: {
	        get: function (ref, $el) {
	          var targets = ref.targets;
	          return $$(targets, $el);
	        },
	        watch: function (items, prev) {
	          var this$1 = this;
	          items.forEach(function (el) {
	            return hide($(this$1.content, el), !hasClass(el, this$1.clsOpen));
	          });

	          if (prev || hasClass(items, this.clsOpen)) {
	            return;
	          }

	          var active = this.active !== false && items[Number(this.active)] || !this.collapsible && items[0];

	          if (active) {
	            this.toggle(active, false);
	          }
	        },
	        immediate: true
	      }
	    },
	    events: [{
	      name: 'click',
	      delegate: function () {
	        return this.targets + " " + this.$props.toggle;
	      },
	      handler: function (e) {
	        e.preventDefault();
	        this.toggle(index($$(this.targets + " " + this.$props.toggle, this.$el), e.current));
	      }
	    }],
	    methods: {
	      toggle: function (item, animate) {
	        var this$1 = this;
	        var items = [this.items[getIndex(item, this.items)]];
	        var activeItems = filter(this.items, "." + this.clsOpen);

	        if (!this.multiple && !includes(activeItems, items[0])) {
	          items = items.concat(activeItems);
	        }

	        if (!this.collapsible && !filter(items, ":not(." + this.clsOpen + ")").length) {
	          return;
	        }

	        items.forEach(function (el) {
	          return this$1.toggleElement(el, !hasClass(el, this$1.clsOpen), function (el, show) {
	            toggleClass(el, this$1.clsOpen, show);
	            var content = $("" + (el._wrapper ? '> * ' : '') + this$1.content, el);

	            if (animate === false || !this$1.hasTransition) {
	              hide(content, !show);
	              return;
	            }

	            if (!el._wrapper) {
	              el._wrapper = wrapAll(content, "<div" + (show ? ' hidden' : '') + ">");
	            }

	            hide(content, false);
	            return toggleHeight(this$1)(el._wrapper, show).then(function () {
	              hide(content, !show);
	              delete el._wrapper;
	              unwrap(content);

	              if (show) {
	                var toggle = $(this$1.$props.toggle, el);

	                if (!isInView(toggle)) {
	                  scrollIntoView(toggle, {
	                    offset: this$1.offset
	                  });
	                }
	              }
	            });
	          });
	        });
	      }
	    }
	  };

	  function hide(el, hide) {
	    attr(el, 'hidden', hide ? '' : null);
	  }

	  var alert = {
	    mixins: [Class, Togglable],
	    args: 'animation',
	    props: {
	      close: String
	    },
	    data: {
	      animation: [true],
	      selClose: '.uk-alert-close',
	      duration: 150,
	      hideProps: assign({
	        opacity: 0
	      }, Togglable.data.hideProps)
	    },
	    events: [{
	      name: 'click',
	      delegate: function () {
	        return this.selClose;
	      },
	      handler: function (e) {
	        e.preventDefault();
	        this.close();
	      }
	    }],
	    methods: {
	      close: function () {
	        var this$1 = this;
	        this.toggleElement(this.$el).then(function () {
	          return this$1.$destroy(true);
	        });
	      }
	    }
	  };
	  var Video = {
	    args: 'autoplay',
	    props: {
	      automute: Boolean,
	      autoplay: Boolean
	    },
	    data: {
	      automute: false,
	      autoplay: true
	    },
	    computed: {
	      inView: function (ref) {
	        var autoplay = ref.autoplay;
	        return autoplay === 'inview';
	      }
	    },
	    connected: function () {
	      if (this.inView && !hasAttr(this.$el, 'preload')) {
	        this.$el.preload = 'none';
	      }

	      this.player = new Player(this.$el);

	      if (this.automute) {
	        this.player.mute();
	      }
	    },
	    update: {
	      read: function () {
	        return !this.player ? false : {
	          visible: isVisible(this.$el) && css(this.$el, 'visibility') !== 'hidden',
	          inView: this.inView && isInView(this.$el)
	        };
	      },
	      write: function (ref) {
	        var visible = ref.visible;
	        var inView = ref.inView;

	        if (!visible || this.inView && !inView) {
	          this.player.pause();
	        } else if (this.autoplay === true || this.inView && inView) {
	          this.player.play();
	        }
	      },
	      events: ['resize', 'scroll']
	    }
	  };
	  var cover = {
	    mixins: [Class, Video],
	    props: {
	      width: Number,
	      height: Number
	    },
	    data: {
	      automute: true
	    },
	    update: {
	      read: function () {
	        var el = this.$el;
	        var ref = getPositionedParent(el) || el.parentNode;
	        var height = ref.offsetHeight;
	        var width = ref.offsetWidth;
	        var dim = Dimensions.cover({
	          width: this.width || el.naturalWidth || el.videoWidth || el.clientWidth,
	          height: this.height || el.naturalHeight || el.videoHeight || el.clientHeight
	        }, {
	          width: width + (width % 2 ? 1 : 0),
	          height: height + (height % 2 ? 1 : 0)
	        });

	        if (!dim.width || !dim.height) {
	          return false;
	        }

	        return dim;
	      },
	      write: function (ref) {
	        var height = ref.height;
	        var width = ref.width;
	        css(this.$el, {
	          height: height,
	          width: width
	        });
	      },
	      events: ['resize']
	    }
	  };

	  function getPositionedParent(el) {
	    while (el = parent(el)) {
	      if (css(el, 'position') !== 'static') {
	        return el;
	      }
	    }
	  }

	  var Position = {
	    props: {
	      pos: String,
	      offset: null,
	      flip: Boolean,
	      clsPos: String
	    },
	    data: {
	      pos: "bottom-" + (!isRtl ? 'left' : 'right'),
	      flip: true,
	      offset: false,
	      clsPos: ''
	    },
	    computed: {
	      pos: function (ref) {
	        var pos = ref.pos;
	        return (pos + (!includes(pos, '-') ? '-center' : '')).split('-');
	      },
	      dir: function () {
	        return this.pos[0];
	      },
	      align: function () {
	        return this.pos[1];
	      }
	    },
	    methods: {
	      positionAt: function (element, target, boundary) {
	        removeClasses(element, this.clsPos + "-(top|bottom|left|right)(-[a-z]+)?");
	        css(element, {
	          top: '',
	          left: ''
	        });
	        var node;
	        var ref = this;
	        var offset$1 = ref.offset;
	        var axis = this.getAxis();

	        if (!isNumeric(offset$1)) {
	          node = $(offset$1);
	          offset$1 = node ? offset(node)[axis === 'x' ? 'left' : 'top'] - offset(target)[axis === 'x' ? 'right' : 'bottom'] : 0;
	        }

	        var ref$1 = positionAt(element, target, axis === 'x' ? flipPosition(this.dir) + " " + this.align : this.align + " " + flipPosition(this.dir), axis === 'x' ? this.dir + " " + this.align : this.align + " " + this.dir, axis === 'x' ? "" + (this.dir === 'left' ? -offset$1 : offset$1) : " " + (this.dir === 'top' ? -offset$1 : offset$1), null, this.flip, boundary).target;
	        var x = ref$1.x;
	        var y = ref$1.y;
	        this.dir = axis === 'x' ? x : y;
	        this.align = axis === 'x' ? y : x;
	        toggleClass(element, this.clsPos + "-" + this.dir + "-" + this.align, this.offset === false);
	      },
	      getAxis: function () {
	        return this.dir === 'top' || this.dir === 'bottom' ? 'y' : 'x';
	      }
	    }
	  };
	  var active;
	  var drop = {
	    mixins: [Position, Togglable],
	    args: 'pos',
	    props: {
	      mode: 'list',
	      toggle: Boolean,
	      boundary: Boolean,
	      boundaryAlign: Boolean,
	      delayShow: Number,
	      delayHide: Number,
	      clsDrop: String
	    },
	    data: {
	      mode: ['click', 'hover'],
	      toggle: '- *',
	      boundary: window,
	      boundaryAlign: false,
	      delayShow: 0,
	      delayHide: 800,
	      clsDrop: false,
	      animation: ['uk-animation-fade'],
	      cls: 'uk-open'
	    },
	    computed: {
	      boundary: function (ref, $el) {
	        var boundary = ref.boundary;
	        return query(boundary, $el);
	      },
	      clsDrop: function (ref) {
	        var clsDrop = ref.clsDrop;
	        return clsDrop || "uk-" + this.$options.name;
	      },
	      clsPos: function () {
	        return this.clsDrop;
	      }
	    },
	    created: function () {
	      this.tracker = new MouseTracker();
	    },
	    connected: function () {
	      addClass(this.$el, this.clsDrop);
	      var ref = this.$props;
	      var toggle = ref.toggle;
	      this.toggle = toggle && this.$create('toggle', query(toggle, this.$el), {
	        target: this.$el,
	        mode: this.mode
	      });
	      !this.toggle && trigger(this.$el, 'updatearia');
	    },
	    disconnected: function () {
	      if (this.isActive()) {
	        active = null;
	      }
	    },
	    events: [{
	      name: 'click',
	      delegate: function () {
	        return "." + this.clsDrop + "-close";
	      },
	      handler: function (e) {
	        e.preventDefault();
	        this.hide(false);
	      }
	    }, {
	      name: 'click',
	      delegate: function () {
	        return 'a[href^="#"]';
	      },
	      handler: function (ref) {
	        var defaultPrevented = ref.defaultPrevented;
	        var hash = ref.current.hash;

	        if (!defaultPrevented && hash && !within(hash, this.$el)) {
	          this.hide(false);
	        }
	      }
	    }, {
	      name: 'beforescroll',
	      handler: function () {
	        this.hide(false);
	      }
	    }, {
	      name: 'toggle',
	      self: true,
	      handler: function (e, toggle) {
	        e.preventDefault();

	        if (this.isToggled()) {
	          this.hide(false);
	        } else {
	          this.show(toggle, false);
	        }
	      }
	    }, {
	      name: 'toggleshow',
	      self: true,
	      handler: function (e, toggle) {
	        e.preventDefault();
	        this.show(toggle);
	      }
	    }, {
	      name: 'togglehide',
	      self: true,
	      handler: function (e) {
	        e.preventDefault();
	        this.hide();
	      }
	    }, {
	      name: pointerEnter,
	      filter: function () {
	        return includes(this.mode, 'hover');
	      },
	      handler: function (e) {
	        if (!isTouch(e)) {
	          this.clearTimers();
	        }
	      }
	    }, {
	      name: pointerLeave,
	      filter: function () {
	        return includes(this.mode, 'hover');
	      },
	      handler: function (e) {
	        if (!isTouch(e)) {
	          this.hide();
	        }
	      }
	    }, {
	      name: 'toggled',
	      self: true,
	      handler: function () {
	        if (!this.isToggled()) {
	          return;
	        }

	        this.clearTimers();
	        Animation.cancel(this.$el);
	        this.position();
	      }
	    }, {
	      name: 'show',
	      self: true,
	      handler: function () {
	        var this$1 = this;
	        active = this;
	        this.tracker.init();
	        trigger(this.$el, 'updatearia');
	        once(this.$el, 'hide', on(document, pointerDown, function (ref) {
	          var target = ref.target;
	          return !within(target, this$1.$el) && once(document, pointerUp + " " + pointerCancel + " scroll", function (ref) {
	            var defaultPrevented = ref.defaultPrevented;
	            var type = ref.type;
	            var newTarget = ref.target;

	            if (!defaultPrevented && type === pointerUp && target === newTarget && !(this$1.toggle && within(target, this$1.toggle.$el))) {
	              this$1.hide(false);
	            }
	          }, true);
	        }), {
	          self: true
	        });
	        once(this.$el, 'hide', on(document, 'keydown', function (e) {
	          if (e.keyCode === 27) {
	            e.preventDefault();
	            this$1.hide(false);
	          }
	        }), {
	          self: true
	        });
	      }
	    }, {
	      name: 'beforehide',
	      self: true,
	      handler: function () {
	        this.clearTimers();
	      }
	    }, {
	      name: 'hide',
	      handler: function (ref) {
	        var target = ref.target;

	        if (this.$el !== target) {
	          active = active === null && within(target, this.$el) && this.isToggled() ? this : active;
	          return;
	        }

	        active = this.isActive() ? null : active;
	        trigger(this.$el, 'updatearia');
	        this.tracker.cancel();
	      }
	    }, {
	      name: 'updatearia',
	      self: true,
	      handler: function (e, toggle) {
	        e.preventDefault();
	        this.updateAria(this.$el);

	        if (toggle || this.toggle) {
	          attr((toggle || this.toggle).$el, 'aria-expanded', this.isToggled());
	          toggleClass(this.toggle.$el, this.cls, this.isToggled());
	        }
	      }
	    }],
	    update: {
	      write: function () {
	        if (this.isToggled() && !Animation.inProgress(this.$el)) {
	          this.position();
	        }
	      },
	      events: ['resize']
	    },
	    methods: {
	      show: function (toggle, delay) {
	        var this$1 = this;
	        if (toggle === void 0) toggle = this.toggle;
	        if (delay === void 0) delay = true;

	        if (this.isToggled() && toggle && this.toggle && toggle.$el !== this.toggle.$el) {
	          this.hide(false);
	        }

	        this.toggle = toggle;
	        this.clearTimers();

	        if (this.isActive()) {
	          return;
	        }

	        if (active) {
	          if (delay && active.isDelaying) {
	            this.showTimer = setTimeout(this.show, 10);
	            return;
	          }

	          while (active && !within(this.$el, active.$el)) {
	            active.hide(false);
	          }
	        }

	        this.showTimer = setTimeout(function () {
	          return !this$1.isToggled() && this$1.toggleElement(this$1.$el, true);
	        }, delay && this.delayShow || 0);
	      },
	      hide: function (delay) {
	        var this$1 = this;
	        if (delay === void 0) delay = true;

	        var hide = function () {
	          return this$1.toggleElement(this$1.$el, false, false);
	        };

	        this.clearTimers();
	        this.isDelaying = getPositionedElements(this.$el).some(function (el) {
	          return this$1.tracker.movesTo(el);
	        });

	        if (delay && this.isDelaying) {
	          this.hideTimer = setTimeout(this.hide, 50);
	        } else if (delay && this.delayHide) {
	          this.hideTimer = setTimeout(hide, this.delayHide);
	        } else {
	          hide();
	        }
	      },
	      clearTimers: function () {
	        clearTimeout(this.showTimer);
	        clearTimeout(this.hideTimer);
	        this.showTimer = null;
	        this.hideTimer = null;
	        this.isDelaying = false;
	      },
	      isActive: function () {
	        return active === this;
	      },
	      position: function () {
	        removeClasses(this.$el, this.clsDrop + "-(stack|boundary)");
	        toggleClass(this.$el, this.clsDrop + "-boundary", this.boundaryAlign);
	        var boundary = offset(this.boundary);
	        var alignTo = this.boundaryAlign ? boundary : offset(this.toggle.$el);

	        if (this.align === 'justify') {
	          var prop = this.getAxis() === 'y' ? 'width' : 'height';
	          css(this.$el, prop, alignTo[prop]);
	        } else if (this.$el.offsetWidth > Math.max(boundary.right - alignTo.left, alignTo.right - boundary.left)) {
	          addClass(this.$el, this.clsDrop + "-stack");
	        }

	        this.positionAt(this.$el, this.boundaryAlign ? this.boundary : this.toggle.$el, this.boundary);
	      }
	    }
	  };

	  function getPositionedElements(el) {
	    var result = [];
	    apply(el, function (el) {
	      return css(el, 'position') !== 'static' && result.push(el);
	    });
	    return result;
	  }

	  var formCustom = {
	    mixins: [Class],
	    args: 'target',
	    props: {
	      target: Boolean
	    },
	    data: {
	      target: false
	    },
	    computed: {
	      input: function (_, $el) {
	        return $(selInput, $el);
	      },
	      state: function () {
	        return this.input.nextElementSibling;
	      },
	      target: function (ref, $el) {
	        var target = ref.target;
	        return target && (target === true && this.input.parentNode === $el && this.input.nextElementSibling || query(target, $el));
	      }
	    },
	    update: function () {
	      var ref = this;
	      var target = ref.target;
	      var input = ref.input;

	      if (!target) {
	        return;
	      }

	      var option;
	      var prop = isInput(target) ? 'value' : 'textContent';
	      var prev = target[prop];
	      var value = input.files && input.files[0] ? input.files[0].name : matches(input, 'select') && (option = $$('option', input).filter(function (el) {
	        return el.selected;
	      })[0]) // eslint-disable-line prefer-destructuring
	      ? option.textContent : input.value;

	      if (prev !== value) {
	        target[prop] = value;
	      }
	    },
	    events: [{
	      name: 'change',
	      handler: function () {
	        this.$update();
	      }
	    }, {
	      name: 'reset',
	      el: function () {
	        return closest(this.$el, 'form');
	      },
	      handler: function () {
	        this.$update();
	      }
	    }]
	  }; // Deprecated

	  var gif = {
	    update: {
	      read: function (data) {
	        var inview = isInView(this.$el);

	        if (!inview || data.isInView === inview) {
	          return false;
	        }

	        data.isInView = inview;
	      },
	      write: function () {
	        this.$el.src = this.$el.src; // eslint-disable-line no-self-assign
	      },
	      events: ['scroll', 'resize']
	    }
	  };
	  var Margin = {
	    props: {
	      margin: String,
	      firstColumn: Boolean
	    },
	    data: {
	      margin: 'uk-margin-small-top',
	      firstColumn: 'uk-first-column'
	    },
	    update: {
	      read: function () {
	        return {
	          rows: getRows(this.$el.children)
	        };
	      },
	      write: function (ref) {
	        var this$1 = this;
	        var rows = ref.rows;
	        rows.forEach(function (row, i) {
	          return row.forEach(function (el, j) {
	            toggleClass(el, this$1.margin, i !== 0);
	            toggleClass(el, this$1.firstColumn, j === 0);
	          });
	        });
	      },
	      events: ['resize']
	    }
	  };

	  function getRows(items) {
	    var rows = [[]];

	    for (var i = 0; i < items.length; i++) {
	      var el = items[i];

	      if (!isVisible(el)) {
	        continue;
	      }

	      var dim = getOffset(el);

	      for (var j = rows.length - 1; j >= 0; j--) {
	        var row = rows[j];

	        if (!row[0]) {
	          row.push(el);
	          break;
	        }

	        var leftDim = void 0;

	        if (row[0].offsetParent === el.offsetParent) {
	          leftDim = getOffset(row[0]);
	        } else {
	          dim = getOffset(el, true);
	          leftDim = getOffset(row[0], true);
	        }

	        if (dim.top >= leftDim.bottom - 1 && dim.top !== leftDim.top) {
	          rows.push([el]);
	          break;
	        }

	        if (dim.bottom > leftDim.top || dim.top === leftDim.top) {
	          if (dim.left < leftDim.left && !isRtl) {
	            row.unshift(el);
	            break;
	          }

	          row.push(el);
	          break;
	        }

	        if (j === 0) {
	          rows.unshift([el]);
	          break;
	        }
	      }
	    }

	    return rows;
	  }

	  function getOffset(element, offset) {
	    var assign;
	    if (offset === void 0) offset = false;
	    var offsetTop = element.offsetTop;
	    var offsetLeft = element.offsetLeft;
	    var offsetHeight = element.offsetHeight;

	    if (offset) {
	      assign = offsetPosition(element), offsetTop = assign[0], offsetLeft = assign[1];
	    }

	    return {
	      top: offsetTop,
	      left: offsetLeft,
	      height: offsetHeight,
	      bottom: offsetTop + offsetHeight
	    };
	  }

	  var grid = {
	    extends: Margin,
	    mixins: [Class],
	    name: 'grid',
	    props: {
	      masonry: Boolean,
	      parallax: Number
	    },
	    data: {
	      margin: 'uk-grid-margin',
	      clsStack: 'uk-grid-stack',
	      masonry: false,
	      parallax: 0
	    },
	    computed: {
	      length: function (_, $el) {
	        return $el.children.length;
	      },
	      parallax: function (ref) {
	        var parallax = ref.parallax;
	        return parallax && this.length ? Math.abs(parallax) : '';
	      }
	    },
	    connected: function () {
	      this.masonry && addClass(this.$el, 'uk-flex-top uk-flex-wrap-top');
	    },
	    update: [{
	      read: function (ref) {
	        var rows = ref.rows;
	        return {
	          stacks: !rows.some(function (row) {
	            return row.length > 1;
	          })
	        };
	      },
	      write: function (ref) {
	        var stacks = ref.stacks;
	        toggleClass(this.$el, this.clsStack, stacks);
	      },
	      events: ['resize']
	    }, {
	      read: function (ref) {
	        var rows = ref.rows;

	        if (!this.masonry && !this.parallax) {
	          return false;
	        }

	        rows = rows.map(function (elements) {
	          return sortBy(elements, 'offsetLeft');
	        });

	        if (isRtl) {
	          rows.map(function (row) {
	            return row.reverse();
	          });
	        }

	        var transitionInProgress = rows.some(function (elements) {
	          return elements.some(Transition.inProgress);
	        });
	        var translates = false;
	        var elHeight = '';

	        if (this.masonry && this.length) {
	          var height = 0;
	          translates = rows.reduce(function (translates, row, i) {
	            translates[i] = row.map(function (_, j) {
	              return i === 0 ? 0 : toFloat(translates[i - 1][j]) + (height - toFloat(rows[i - 1][j] && rows[i - 1][j].offsetHeight));
	            });
	            height = row.reduce(function (height, el) {
	              return Math.max(height, el.offsetHeight);
	            }, 0);
	            return translates;
	          }, []);
	          elHeight = maxColumnHeight(rows) + getMarginTop(this.$el, this.margin) * (rows.length - 1);
	        }

	        var padding = this.parallax && getPaddingBottom(this.parallax, rows, translates);
	        return {
	          padding: padding,
	          rows: rows,
	          translates: translates,
	          height: !transitionInProgress ? elHeight : false
	        };
	      },
	      write: function (ref) {
	        var height = ref.height;
	        var padding = ref.padding;
	        css(this.$el, 'paddingBottom', padding);
	        height !== false && css(this.$el, 'height', height);
	      },
	      events: ['resize']
	    }, {
	      read: function (ref) {
	        var height$1 = ref.height;
	        return {
	          scrolled: this.parallax ? scrolledOver(this.$el, height$1 ? height$1 - height(this.$el) : 0) * this.parallax : false
	        };
	      },
	      write: function (ref) {
	        var rows = ref.rows;
	        var scrolled = ref.scrolled;
	        var translates = ref.translates;

	        if (scrolled === false && !translates) {
	          return;
	        }

	        rows.forEach(function (row, i) {
	          return row.forEach(function (el, j) {
	            return css(el, 'transform', !scrolled && !translates ? '' : "translateY(" + ((translates && -translates[i][j]) + (scrolled ? j % 2 ? scrolled : scrolled / 8 : 0)) + "px)");
	          });
	        });
	      },
	      events: ['scroll', 'resize']
	    }]
	  };

	  function getPaddingBottom(distance, rows, translates) {
	    var column = 0;
	    var max = 0;
	    var maxScrolled = 0;

	    for (var i = rows.length - 1; i >= 0; i--) {
	      for (var j = column; j < rows[i].length; j++) {
	        var el = rows[i][j];
	        var bottom = el.offsetTop + height(el) + (translates && -translates[i][j]);
	        max = Math.max(max, bottom);
	        maxScrolled = Math.max(maxScrolled, bottom + (j % 2 ? distance : distance / 8));
	        column++;
	      }
	    }

	    return maxScrolled - max;
	  }

	  function getMarginTop(root, cls) {
	    var nodes = children(root);
	    var ref = nodes.filter(function (el) {
	      return hasClass(el, cls);
	    });
	    var node = ref[0];
	    return toFloat(node ? css(node, 'marginTop') : css(nodes[0], 'paddingLeft'));
	  }

	  function maxColumnHeight(rows) {
	    return Math.max.apply(Math, rows.reduce(function (sum, row) {
	      row.forEach(function (el, i) {
	        return sum[i] = (sum[i] || 0) + el.offsetHeight;
	      });
	      return sum;
	    }, []));
	  } // IE 11 fix (min-height on a flex container won't apply to its flex items)


	  var FlexBug = isIE ? {
	    props: {
	      selMinHeight: String
	    },
	    data: {
	      selMinHeight: false,
	      forceHeight: false
	    },
	    computed: {
	      elements: function (ref, $el) {
	        var selMinHeight = ref.selMinHeight;
	        return selMinHeight ? $$(selMinHeight, $el) : [$el];
	      }
	    },
	    update: [{
	      read: function () {
	        css(this.elements, 'height', '');
	      },
	      order: -5,
	      events: ['resize']
	    }, {
	      write: function () {
	        var this$1 = this;
	        this.elements.forEach(function (el) {
	          var height = toFloat(css(el, 'minHeight'));

	          if (height && (this$1.forceHeight || Math.round(height + boxModelAdjust(el, 'height', 'content-box')) >= el.offsetHeight)) {
	            css(el, 'height', height);
	          }
	        });
	      },
	      order: 5,
	      events: ['resize']
	    }]
	  } : {};
	  var heightMatch = {
	    mixins: [FlexBug],
	    args: 'target',
	    props: {
	      target: String,
	      row: Boolean
	    },
	    data: {
	      target: '> *',
	      row: true,
	      forceHeight: true
	    },
	    computed: {
	      elements: function (ref, $el) {
	        var target = ref.target;
	        return $$(target, $el);
	      }
	    },
	    update: {
	      read: function () {
	        return {
	          rows: (this.row ? getRows(this.elements) : [this.elements]).map(match)
	        };
	      },
	      write: function (ref) {
	        var rows = ref.rows;
	        rows.forEach(function (ref) {
	          var heights = ref.heights;
	          var elements = ref.elements;
	          return elements.forEach(function (el, i) {
	            return css(el, 'minHeight', heights[i]);
	          });
	        });
	      },
	      events: ['resize']
	    }
	  };

	  function match(elements) {
	    var assign;

	    if (elements.length < 2) {
	      return {
	        heights: [''],
	        elements: elements
	      };
	    }

	    var ref = getHeights(elements);
	    var heights = ref.heights;
	    var max = ref.max;
	    var hasMinHeight = elements.some(function (el) {
	      return el.style.minHeight;
	    });
	    var hasShrunk = elements.some(function (el, i) {
	      return !el.style.minHeight && heights[i] < max;
	    });

	    if (hasMinHeight && hasShrunk) {
	      css(elements, 'minHeight', '');
	      assign = getHeights(elements), heights = assign.heights, max = assign.max;
	    }

	    heights = elements.map(function (el, i) {
	      return heights[i] === max && toFloat(el.style.minHeight).toFixed(2) !== max.toFixed(2) ? '' : max;
	    });
	    return {
	      heights: heights,
	      elements: elements
	    };
	  }

	  function getHeights(elements) {
	    var heights = elements.map(function (el) {
	      return offset(el).height - boxModelAdjust(el, 'height', 'content-box');
	    });
	    var max = Math.max.apply(null, heights);
	    return {
	      heights: heights,
	      max: max
	    };
	  }

	  var heightViewport = {
	    mixins: [FlexBug],
	    props: {
	      expand: Boolean,
	      offsetTop: Boolean,
	      offsetBottom: Boolean,
	      minHeight: Number
	    },
	    data: {
	      expand: false,
	      offsetTop: false,
	      offsetBottom: false,
	      minHeight: 0
	    },
	    update: {
	      read: function (ref) {
	        var prev = ref.minHeight;

	        if (!isVisible(this.$el)) {
	          return false;
	        }

	        var minHeight = '';
	        var box = boxModelAdjust(this.$el, 'height', 'content-box');

	        if (this.expand) {
	          this.$el.dataset.heightExpand = '';

	          if ($('[data-height-expand]') !== this.$el) {
	            return false;
	          }

	          minHeight = height(window) - (offsetHeight(document.documentElement) - offsetHeight(this.$el)) - box || '';
	        } else {
	          // on mobile devices (iOS and Android) window.innerHeight !== 100vh
	          minHeight = 'calc(100vh';

	          if (this.offsetTop) {
	            var ref$1 = offset(this.$el);
	            var top = ref$1.top;
	            minHeight += top > 0 && top < height(window) / 2 ? " - " + top + "px" : '';
	          }

	          if (this.offsetBottom === true) {
	            minHeight += " - " + offsetHeight(this.$el.nextElementSibling) + "px";
	          } else if (isNumeric(this.offsetBottom)) {
	            minHeight += " - " + this.offsetBottom + "vh";
	          } else if (this.offsetBottom && endsWith(this.offsetBottom, 'px')) {
	            minHeight += " - " + toFloat(this.offsetBottom) + "px";
	          } else if (isString(this.offsetBottom)) {
	            minHeight += " - " + offsetHeight(query(this.offsetBottom, this.$el)) + "px";
	          }

	          minHeight += (box ? " - " + box + "px" : '') + ")";
	        }

	        return {
	          minHeight: minHeight,
	          prev: prev
	        };
	      },
	      write: function (ref) {
	        var minHeight = ref.minHeight;
	        var prev = ref.prev;
	        css(this.$el, {
	          minHeight: minHeight
	        });

	        if (minHeight !== prev) {
	          this.$update(this.$el, 'resize');
	        }

	        if (this.minHeight && toFloat(css(this.$el, 'minHeight')) < this.minHeight) {
	          css(this.$el, 'minHeight', this.minHeight);
	        }
	      },
	      events: ['resize']
	    }
	  };

	  function offsetHeight(el) {
	    return el && offset(el).height || 0;
	  }

	  var SVG = {
	    args: 'src',
	    props: {
	      id: Boolean,
	      icon: String,
	      src: String,
	      style: String,
	      width: Number,
	      height: Number,
	      ratio: Number,
	      class: String,
	      strokeAnimation: Boolean,
	      focusable: Boolean,
	      // IE 11
	      attributes: 'list'
	    },
	    data: {
	      ratio: 1,
	      include: ['style', 'class', 'focusable'],
	      class: '',
	      strokeAnimation: false
	    },
	    beforeConnect: function () {
	      var this$1 = this;
	      var assign;
	      this.class += ' uk-svg';

	      if (!this.icon && includes(this.src, '#')) {
	        var parts = this.src.split('#');

	        if (parts.length > 1) {
	          assign = parts, this.src = assign[0], this.icon = assign[1];
	        }
	      }

	      this.svg = this.getSvg().then(function (el) {
	        this$1.applyAttributes(el);
	        return this$1.svgEl = insertSVG(el, this$1.$el);
	      }, noop);
	    },
	    disconnected: function () {
	      var this$1 = this;

	      if (isVoidElement(this.$el)) {
	        attr(this.$el, 'hidden', null);
	      }

	      if (this.svg) {
	        this.svg.then(function (svg) {
	          return (!this$1._connected || svg !== this$1.svgEl) && remove(svg);
	        }, noop);
	      }

	      this.svg = this.svgEl = null;
	    },
	    update: {
	      read: function () {
	        return !!(this.strokeAnimation && this.svgEl && isVisible(this.svgEl));
	      },
	      write: function () {
	        applyAnimation(this.svgEl);
	      },
	      type: ['resize']
	    },
	    methods: {
	      getSvg: function () {
	        var this$1 = this;
	        return loadSVG(this.src).then(function (svg) {
	          return parseSVG(svg, this$1.icon) || Promise.reject('SVG not found.');
	        });
	      },
	      applyAttributes: function (el) {
	        var this$1 = this;

	        for (var prop in this.$options.props) {
	          if (this[prop] && includes(this.include, prop)) {
	            attr(el, prop, this[prop]);
	          }
	        }

	        for (var attribute in this.attributes) {
	          var ref = this.attributes[attribute].split(':', 2);
	          var prop$1 = ref[0];
	          var value = ref[1];
	          attr(el, prop$1, value);
	        }

	        if (!this.id) {
	          removeAttr(el, 'id');
	        }

	        var props = ['width', 'height'];
	        var dimensions = [this.width, this.height];

	        if (!dimensions.some(function (val) {
	          return val;
	        })) {
	          dimensions = props.map(function (prop) {
	            return attr(el, prop);
	          });
	        }

	        var viewBox = attr(el, 'viewBox');

	        if (viewBox && !dimensions.some(function (val) {
	          return val;
	        })) {
	          dimensions = viewBox.split(' ').slice(2);
	        }

	        dimensions.forEach(function (val, i) {
	          val = (val | 0) * this$1.ratio;
	          val && attr(el, props[i], val);

	          if (val && !dimensions[i ^ 1]) {
	            removeAttr(el, props[i ^ 1]);
	          }
	        });
	        attr(el, 'data-svg', this.icon || this.src);
	      }
	    }
	  };
	  var svgs = {};

	  function loadSVG(src) {
	    if (svgs[src]) {
	      return svgs[src];
	    }

	    return svgs[src] = new Promise(function (resolve, reject) {
	      if (!src) {
	        reject();
	        return;
	      }

	      if (startsWith(src, 'data:')) {
	        resolve(decodeURIComponent(src.split(',')[1]));
	      } else {
	        ajax(src).then(function (xhr) {
	          return resolve(xhr.response);
	        }, function () {
	          return reject('SVG not found.');
	        });
	      }
	    });
	  }

	  function parseSVG(svg, icon) {
	    if (icon && includes(svg, '<symbol')) {
	      svg = parseSymbols(svg, icon) || svg;
	    }

	    svg = $(svg.substr(svg.indexOf('<svg')));
	    return svg && svg.hasChildNodes() && svg;
	  }

	  var symbolRe = /<symbol([^]*?id=(['"])(.+?)\2[^]*?<\/)symbol>/g;
	  var symbols = {};

	  function parseSymbols(svg, icon) {
	    if (!symbols[svg]) {
	      symbols[svg] = {};
	      symbolRe.lastIndex = 0;
	      var match;

	      while (match = symbolRe.exec(svg)) {
	        symbols[svg][match[3]] = "<svg xmlns=\"http://www.w3.org/2000/svg\"" + match[1] + "svg>";
	      }
	    }

	    return symbols[svg][icon];
	  }

	  function applyAnimation(el) {
	    var length = getMaxPathLength(el);

	    if (length) {
	      el.style.setProperty('--uk-animation-stroke', length);
	    }
	  }

	  function getMaxPathLength(el) {
	    return Math.ceil(Math.max.apply(Math, [0].concat($$('[stroke]', el).map(function (stroke) {
	      try {
	        return stroke.getTotalLength();
	      } catch (e) {
	        return 0;
	      }
	    }))));
	  }

	  function insertSVG(el, root) {
	    if (isVoidElement(root) || root.tagName === 'CANVAS') {
	      attr(root, 'hidden', true);
	      var next = root.nextElementSibling;
	      return equals(el, next) ? next : after(root, el);
	    }

	    var last = root.lastElementChild;
	    return equals(el, last) ? last : append(root, el);
	  }

	  function equals(el, other) {
	    return attr(el, 'data-svg') === attr(other, 'data-svg');
	  }

	  var closeIcon = "<svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"1\" y1=\"1\" x2=\"13\" y2=\"13\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13\" y1=\"1\" x2=\"1\" y2=\"13\"/></svg>";
	  var closeLarge = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"1\" y1=\"1\" x2=\"19\" y2=\"19\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"19\" y1=\"1\" x2=\"1\" y2=\"19\"/></svg>";
	  var marker = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"9\" y=\"4\" width=\"1\" height=\"11\"/><rect x=\"4\" y=\"9\" width=\"11\" height=\"1\"/></svg>";
	  var navbarToggleIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect y=\"9\" width=\"20\" height=\"2\"/><rect y=\"3\" width=\"20\" height=\"2\"/><rect y=\"15\" width=\"20\" height=\"2\"/></svg>";
	  var overlayIcon = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"19\" y=\"0\" width=\"1\" height=\"40\"/><rect x=\"0\" y=\"19\" width=\"40\" height=\"1\"/></svg>";
	  var paginationNext = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 1 6 6 1 11\"/></svg>";
	  var paginationPrevious = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"6 1 1 6 6 11\"/></svg>";
	  var searchIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9\" cy=\"9\" r=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M14,14 L18,18 L14,14 Z\"/></svg>";
	  var searchLarge = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" cx=\"17.5\" cy=\"17.5\" r=\"16.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" x1=\"38\" y1=\"39\" x2=\"29\" y2=\"30\"/></svg>";
	  var searchNavbar = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10.5\" cy=\"10.5\" r=\"9.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"23\" y1=\"23\" x2=\"17\" y2=\"17\"/></svg>";
	  var slidenavNext = "<svg width=\"14px\" height=\"24px\" viewBox=\"0 0 14 24\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"1.225,23 12.775,12 1.225,1 \"/></svg>";
	  var slidenavNextLarge = "<svg width=\"25px\" height=\"40px\" viewBox=\"0 0 25 40\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"4.002,38.547 22.527,20.024 4,1.5 \"/></svg>";
	  var slidenavPrevious = "<svg width=\"14px\" height=\"24px\" viewBox=\"0 0 14 24\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"12.775,1 1.225,12 12.775,23 \"/></svg>";
	  var slidenavPreviousLarge = "<svg width=\"25px\" height=\"40px\" viewBox=\"0 0 25 40\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"20.527,1.5 2,20.024 20.525,38.547 \"/></svg>";
	  var spinner = "<svg width=\"30\" height=\"30\" viewBox=\"0 0 30 30\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" cx=\"15\" cy=\"15\" r=\"14\"/></svg>";
	  var totop = "<svg width=\"18\" height=\"10\" viewBox=\"0 0 18 10\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 9 9 1 17 9 \"/></svg>";
	  var icons = {
	    spinner: spinner,
	    totop: totop,
	    marker: marker,
	    'close-icon': closeIcon,
	    'close-large': closeLarge,
	    'navbar-toggle-icon': navbarToggleIcon,
	    'overlay-icon': overlayIcon,
	    'pagination-next': paginationNext,
	    'pagination-previous': paginationPrevious,
	    'search-icon': searchIcon,
	    'search-large': searchLarge,
	    'search-navbar': searchNavbar,
	    'slidenav-next': slidenavNext,
	    'slidenav-next-large': slidenavNextLarge,
	    'slidenav-previous': slidenavPrevious,
	    'slidenav-previous-large': slidenavPreviousLarge
	  };
	  var Icon = {
	    install: install,
	    extends: SVG,
	    args: 'icon',
	    props: ['icon'],
	    data: {
	      include: ['focusable']
	    },
	    isIcon: true,
	    beforeConnect: function () {
	      addClass(this.$el, 'uk-icon');
	    },
	    methods: {
	      getSvg: function () {
	        var icon = getIcon(this.icon);

	        if (!icon) {
	          return Promise.reject('Icon not found.');
	        }

	        return Promise.resolve(icon);
	      }
	    }
	  };
	  var IconComponent = {
	    args: false,
	    extends: Icon,
	    data: function (vm) {
	      return {
	        icon: hyphenate(vm.constructor.options.name)
	      };
	    },
	    beforeConnect: function () {
	      addClass(this.$el, this.$name);
	    }
	  };
	  var Slidenav = {
	    extends: IconComponent,
	    beforeConnect: function () {
	      addClass(this.$el, 'uk-slidenav');
	    },
	    computed: {
	      icon: function (ref, $el) {
	        var icon = ref.icon;
	        return hasClass($el, 'uk-slidenav-large') ? icon + "-large" : icon;
	      }
	    }
	  };
	  var Search = {
	    extends: IconComponent,
	    computed: {
	      icon: function (ref, $el) {
	        var icon = ref.icon;
	        return hasClass($el, 'uk-search-icon') && parents($el, '.uk-search-large').length ? 'search-large' : parents($el, '.uk-search-navbar').length ? 'search-navbar' : icon;
	      }
	    }
	  };
	  var Close = {
	    extends: IconComponent,
	    computed: {
	      icon: function () {
	        return "close-" + (hasClass(this.$el, 'uk-close-large') ? 'large' : 'icon');
	      }
	    }
	  };
	  var Spinner = {
	    extends: IconComponent,
	    connected: function () {
	      var this$1 = this;
	      this.svg.then(function (svg) {
	        return this$1.ratio !== 1 && css($('circle', svg), 'strokeWidth', 1 / this$1.ratio);
	      }, noop);
	    }
	  };
	  var parsed = {};

	  function install(UIkit) {
	    UIkit.icon.add = function (name, svg) {
	      var obj;
	      var added = isString(name) ? (obj = {}, obj[name] = svg, obj) : name;
	      each(added, function (svg, name) {
	        icons[name] = svg;
	        delete parsed[name];
	      });

	      if (UIkit._initialized) {
	        apply(document.body, function (el) {
	          return each(UIkit.getComponents(el), function (cmp) {
	            cmp.$options.isIcon && cmp.icon in added && cmp.$reset();
	          });
	        });
	      }
	    };
	  }

	  function getIcon(icon) {
	    if (!icons[icon]) {
	      return null;
	    }

	    if (!parsed[icon]) {
	      parsed[icon] = $((icons[applyRtl(icon)] || icons[icon]).trim());
	    }

	    return parsed[icon].cloneNode(true);
	  }

	  function applyRtl(icon) {
	    return isRtl ? swap(swap(icon, 'left', 'right'), 'previous', 'next') : icon;
	  }

	  var img = {
	    args: 'dataSrc',
	    props: {
	      dataSrc: String,
	      dataSrcset: Boolean,
	      sizes: String,
	      width: Number,
	      height: Number,
	      offsetTop: String,
	      offsetLeft: String,
	      target: String
	    },
	    data: {
	      dataSrc: '',
	      dataSrcset: false,
	      sizes: false,
	      width: false,
	      height: false,
	      offsetTop: '50vh',
	      offsetLeft: 0,
	      target: false
	    },
	    computed: {
	      cacheKey: function (ref) {
	        var dataSrc = ref.dataSrc;
	        return this.$name + "." + dataSrc;
	      },
	      width: function (ref) {
	        var width = ref.width;
	        var dataWidth = ref.dataWidth;
	        return width || dataWidth;
	      },
	      height: function (ref) {
	        var height = ref.height;
	        var dataHeight = ref.dataHeight;
	        return height || dataHeight;
	      },
	      sizes: function (ref) {
	        var sizes = ref.sizes;
	        var dataSizes = ref.dataSizes;
	        return sizes || dataSizes;
	      },
	      isImg: function (_, $el) {
	        return isImg($el);
	      },
	      target: {
	        get: function (ref) {
	          var target = ref.target;
	          return [this.$el].concat(queryAll(target, this.$el));
	        },
	        watch: function () {
	          this.observe();
	        }
	      },
	      offsetTop: function (ref) {
	        var offsetTop = ref.offsetTop;
	        return toPx(offsetTop, 'height');
	      },
	      offsetLeft: function (ref) {
	        var offsetLeft = ref.offsetLeft;
	        return toPx(offsetLeft, 'width');
	      }
	    },
	    connected: function () {
	      if (storage[this.cacheKey]) {
	        setSrcAttrs(this.$el, storage[this.cacheKey] || this.dataSrc, this.dataSrcset, this.sizes);
	      } else if (this.isImg && this.width && this.height) {
	        setSrcAttrs(this.$el, getPlaceholderImage(this.width, this.height, this.sizes));
	      }

	      this.observer = new IntersectionObserver(this.load, {
	        rootMargin: this.offsetTop + "px " + this.offsetLeft + "px"
	      });
	      requestAnimationFrame(this.observe);
	    },
	    disconnected: function () {
	      this.observer.disconnect();
	    },
	    update: {
	      read: function (ref) {
	        var this$1 = this;
	        var image = ref.image;

	        if (!image && document.readyState === 'complete') {
	          this.load(this.observer.takeRecords());
	        }

	        if (this.isImg) {
	          return false;
	        }

	        image && image.then(function (img) {
	          return img && img.currentSrc !== '' && setSrcAttrs(this$1.$el, currentSrc(img));
	        });
	      },
	      write: function (data) {
	        if (this.dataSrcset && window.devicePixelRatio !== 1) {
	          var bgSize = css(this.$el, 'backgroundSize');

	          if (bgSize.match(/^(auto\s?)+$/) || toFloat(bgSize) === data.bgSize) {
	            data.bgSize = getSourceSize(this.dataSrcset, this.sizes);
	            css(this.$el, 'backgroundSize', data.bgSize + "px");
	          }
	        }
	      },
	      events: ['resize']
	    },
	    methods: {
	      load: function (entries) {
	        var this$1 = this; // Old chromium based browsers (UC Browser) did not implement `isIntersecting`

	        if (!entries.some(function (entry) {
	          return isUndefined(entry.isIntersecting) || entry.isIntersecting;
	        })) {
	          return;
	        }

	        this._data.image = getImage(this.dataSrc, this.dataSrcset, this.sizes).then(function (img) {
	          setSrcAttrs(this$1.$el, currentSrc(img), img.srcset, img.sizes);
	          storage[this$1.cacheKey] = currentSrc(img);
	          return img;
	        }, noop);
	        this.observer.disconnect();
	      },
	      observe: function () {
	        var this$1 = this;

	        if (this._connected && !this._data.image) {
	          this.target.forEach(function (el) {
	            return this$1.observer.observe(el);
	          });
	        }
	      }
	    }
	  };

	  function setSrcAttrs(el, src, srcset, sizes) {
	    if (isImg(el)) {
	      sizes && (el.sizes = sizes);
	      srcset && (el.srcset = srcset);
	      src && (el.src = src);
	    } else if (src) {
	      var change = !includes(el.style.backgroundImage, src);

	      if (change) {
	        css(el, 'backgroundImage', "url(" + escape(src) + ")");
	        trigger(el, createEvent('load', false));
	      }
	    }
	  }

	  function getPlaceholderImage(width, height, sizes) {
	    var assign;

	    if (sizes) {
	      assign = Dimensions.ratio({
	        width: width,
	        height: height
	      }, 'width', toPx(sizesToPixel(sizes))), width = assign.width, height = assign.height;
	    }

	    return "data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"" + width + "\" height=\"" + height + "\"></svg>";
	  }

	  var sizesRe = /\s*(.*?)\s*(\w+|calc\(.*?\))\s*(?:,|$)/g;

	  function sizesToPixel(sizes) {
	    var matches;
	    sizesRe.lastIndex = 0;

	    while (matches = sizesRe.exec(sizes)) {
	      if (!matches[1] || window.matchMedia(matches[1]).matches) {
	        matches = evaluateSize(matches[2]);
	        break;
	      }
	    }

	    return matches || '100vw';
	  }

	  var sizeRe = /\d+(?:\w+|%)/g;
	  var additionRe = /[+-]?(\d+)/g;

	  function evaluateSize(size) {
	    return startsWith(size, 'calc') ? size.substring(5, size.length - 1).replace(sizeRe, function (size) {
	      return toPx(size);
	    }).replace(/ /g, '').match(additionRe).reduce(function (a, b) {
	      return a + +b;
	    }, 0) : size;
	  }

	  var srcSetRe = /\s+\d+w\s*(?:,|$)/g;

	  function getSourceSize(srcset, sizes) {
	    var srcSize = toPx(sizesToPixel(sizes));
	    var descriptors = (srcset.match(srcSetRe) || []).map(toFloat).sort(function (a, b) {
	      return a - b;
	    });
	    return descriptors.filter(function (size) {
	      return size >= srcSize;
	    })[0] || descriptors.pop() || '';
	  }

	  function isImg(el) {
	    return el.tagName === 'IMG';
	  }

	  function currentSrc(el) {
	    return el.currentSrc || el.src;
	  }

	  var key = '__test__';
	  var storage; // workaround for Safari's private browsing mode and accessing sessionStorage in Blink

	  try {
	    storage = window.sessionStorage || {};
	    storage[key] = 1;
	    delete storage[key];
	  } catch (e) {
	    storage = {};
	  }

	  var Media = {
	    props: {
	      media: Boolean
	    },
	    data: {
	      media: false
	    },
	    computed: {
	      matchMedia: function () {
	        var media = toMedia(this.media);
	        return !media || window.matchMedia(media).matches;
	      }
	    }
	  };

	  function toMedia(value) {
	    if (isString(value)) {
	      if (value[0] === '@') {
	        var name = "breakpoint-" + value.substr(1);
	        value = toFloat(getCssVar(name));
	      } else if (isNaN(value)) {
	        return value;
	      }
	    }

	    return value && !isNaN(value) ? "(min-width: " + value + "px)" : false;
	  }

	  var leader = {
	    mixins: [Class, Media],
	    props: {
	      fill: String
	    },
	    data: {
	      fill: '',
	      clsWrapper: 'uk-leader-fill',
	      clsHide: 'uk-leader-hide',
	      attrFill: 'data-fill'
	    },
	    computed: {
	      fill: function (ref) {
	        var fill = ref.fill;
	        return fill || getCssVar('leader-fill-content');
	      }
	    },
	    connected: function () {
	      var assign;
	      assign = wrapInner(this.$el, "<span class=\"" + this.clsWrapper + "\">"), this.wrapper = assign[0];
	    },
	    disconnected: function () {
	      unwrap(this.wrapper.childNodes);
	    },
	    update: {
	      read: function (ref) {
	        var changed = ref.changed;
	        var width = ref.width;
	        var prev = width;
	        width = Math.floor(this.$el.offsetWidth / 2);
	        return {
	          width: width,
	          fill: this.fill,
	          changed: changed || prev !== width,
	          hide: !this.matchMedia
	        };
	      },
	      write: function (data) {
	        toggleClass(this.wrapper, this.clsHide, data.hide);

	        if (data.changed) {
	          data.changed = false;
	          attr(this.wrapper, this.attrFill, new Array(data.width).join(data.fill));
	        }
	      },
	      events: ['resize']
	    }
	  };
	  var Container = {
	    props: {
	      container: Boolean
	    },
	    data: {
	      container: true
	    },
	    computed: {
	      container: function (ref) {
	        var container = ref.container;
	        return container === true && this.$container || container && $(container);
	      }
	    }
	  };
	  var active$1 = [];
	  var Modal = {
	    mixins: [Class, Container, Togglable],
	    props: {
	      selPanel: String,
	      selClose: String,
	      escClose: Boolean,
	      bgClose: Boolean,
	      stack: Boolean
	    },
	    data: {
	      cls: 'uk-open',
	      escClose: true,
	      bgClose: true,
	      overlay: true,
	      stack: false
	    },
	    computed: {
	      panel: function (ref, $el) {
	        var selPanel = ref.selPanel;
	        return $(selPanel, $el);
	      },
	      transitionElement: function () {
	        return this.panel;
	      },
	      bgClose: function (ref) {
	        var bgClose = ref.bgClose;
	        return bgClose && this.panel;
	      }
	    },
	    beforeDisconnect: function () {
	      if (this.isToggled()) {
	        this.toggleElement(this.$el, false, false);
	      }
	    },
	    events: [{
	      name: 'click',
	      delegate: function () {
	        return this.selClose;
	      },
	      handler: function (e) {
	        e.preventDefault();
	        this.hide();
	      }
	    }, {
	      name: 'toggle',
	      self: true,
	      handler: function (e) {
	        if (e.defaultPrevented) {
	          return;
	        }

	        e.preventDefault();

	        if (this.isToggled() === includes(active$1, this)) {
	          this.toggle();
	        }
	      }
	    }, {
	      name: 'beforeshow',
	      self: true,
	      handler: function (e) {
	        if (includes(active$1, this)) {
	          return false;
	        }

	        if (!this.stack && active$1.length) {
	          Promise.all(active$1.map(function (modal) {
	            return modal.hide();
	          })).then(this.show);
	          e.preventDefault();
	        } else {
	          active$1.push(this);
	        }
	      }
	    }, {
	      name: 'show',
	      self: true,
	      handler: function () {
	        var this$1 = this;

	        if (width(window) - width(document) && this.overlay) {
	          css(document.body, 'overflowY', 'scroll');
	        }

	        this.stack && css(this.$el, 'zIndex', css(this.$el, 'zIndex') + active$1.length);
	        addClass(document.documentElement, this.clsPage);

	        if (this.bgClose) {
	          once(this.$el, 'hide', on(document, pointerDown, function (ref) {
	            var target = ref.target;

	            if (last(active$1) !== this$1 || this$1.overlay && !within(target, this$1.$el) || within(target, this$1.panel)) {
	              return;
	            }

	            once(document, pointerUp + " " + pointerCancel + " scroll", function (ref) {
	              var defaultPrevented = ref.defaultPrevented;
	              var type = ref.type;
	              var newTarget = ref.target;

	              if (!defaultPrevented && type === pointerUp && target === newTarget) {
	                this$1.hide();
	              }
	            }, true);
	          }), {
	            self: true
	          });
	        }

	        if (this.escClose) {
	          once(this.$el, 'hide', on(document, 'keydown', function (e) {
	            if (e.keyCode === 27 && last(active$1) === this$1) {
	              e.preventDefault();
	              this$1.hide();
	            }
	          }), {
	            self: true
	          });
	        }
	      }
	    }, {
	      name: 'hidden',
	      self: true,
	      handler: function () {
	        var this$1 = this;
	        active$1.splice(active$1.indexOf(this), 1);

	        if (!active$1.length) {
	          css(document.body, 'overflowY', '');
	        }

	        css(this.$el, 'zIndex', '');

	        if (!active$1.some(function (modal) {
	          return modal.clsPage === this$1.clsPage;
	        })) {
	          removeClass(document.documentElement, this.clsPage);
	        }
	      }
	    }],
	    methods: {
	      toggle: function () {
	        return this.isToggled() ? this.hide() : this.show();
	      },
	      show: function () {
	        var this$1 = this;

	        if (this.container && this.$el.parentNode !== this.container) {
	          append(this.container, this.$el);
	          return new Promise(function (resolve) {
	            return requestAnimationFrame(function () {
	              return this$1.show().then(resolve);
	            });
	          });
	        }

	        return this.toggleElement(this.$el, true, animate$1(this));
	      },
	      hide: function () {
	        return this.toggleElement(this.$el, false, animate$1(this));
	      }
	    }
	  };

	  function animate$1(ref) {
	    var transitionElement = ref.transitionElement;
	    var _toggle = ref._toggle;
	    return function (el, show) {
	      return new Promise(function (resolve, reject) {
	        return once(el, 'show hide', function () {
	          el._reject && el._reject();
	          el._reject = reject;

	          _toggle(el, show);

	          var off = once(transitionElement, 'transitionstart', function () {
	            once(transitionElement, 'transitionend transitioncancel', resolve, {
	              self: true
	            });
	            clearTimeout(timer);
	          }, {
	            self: true
	          });
	          var timer = setTimeout(function () {
	            off();
	            resolve();
	          }, toMs(css(transitionElement, 'transitionDuration')));
	        });
	      });
	    };
	  }

	  var modal = {
	    install: install$1,
	    mixins: [Modal],
	    data: {
	      clsPage: 'uk-modal-page',
	      selPanel: '.uk-modal-dialog',
	      selClose: '.uk-modal-close, .uk-modal-close-default, .uk-modal-close-outside, .uk-modal-close-full'
	    },
	    events: [{
	      name: 'show',
	      self: true,
	      handler: function () {
	        if (hasClass(this.panel, 'uk-margin-auto-vertical')) {
	          addClass(this.$el, 'uk-flex');
	        } else {
	          css(this.$el, 'display', 'block');
	        }

	        height(this.$el); // force reflow
	      }
	    }, {
	      name: 'hidden',
	      self: true,
	      handler: function () {
	        css(this.$el, 'display', '');
	        removeClass(this.$el, 'uk-flex');
	      }
	    }]
	  };

	  function install$1(ref) {
	    var modal = ref.modal;

	    modal.dialog = function (content, options) {
	      var dialog = modal("<div class=\"uk-modal\"> <div class=\"uk-modal-dialog\">" + content + "</div> </div>", options);
	      dialog.show();
	      on(dialog.$el, 'hidden', function () {
	        return Promise.resolve().then(function () {
	          return dialog.$destroy(true);
	        });
	      }, {
	        self: true
	      });
	      return dialog;
	    };

	    modal.alert = function (message, options) {
	      return openDialog(function (ref) {
	        var labels = ref.labels;
	        return "<div class=\"uk-modal-body\">" + (isString(message) ? message : html(message)) + "</div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-primary uk-modal-close\" autofocus>" + labels.ok + "</button> </div>";
	      }, options, function (deferred) {
	        return deferred.resolve();
	      });
	    };

	    modal.confirm = function (message, options) {
	      return openDialog(function (ref) {
	        var labels = ref.labels;
	        return "<form> <div class=\"uk-modal-body\">" + (isString(message) ? message : html(message)) + "</div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-default uk-modal-close\" type=\"button\">" + labels.cancel + "</button> <button class=\"uk-button uk-button-primary\" autofocus>" + labels.ok + "</button> </div> </form>";
	      }, options, function (deferred) {
	        return deferred.reject();
	      });
	    };

	    modal.prompt = function (message, value, options) {
	      return openDialog(function (ref) {
	        var labels = ref.labels;
	        return "<form class=\"uk-form-stacked\"> <div class=\"uk-modal-body\"> <label>" + (isString(message) ? message : html(message)) + "</label> <input class=\"uk-input\" value=\"" + (value || '') + "\" autofocus> </div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-default uk-modal-close\" type=\"button\">" + labels.cancel + "</button> <button class=\"uk-button uk-button-primary\">" + labels.ok + "</button> </div> </form>";
	      }, options, function (deferred) {
	        return deferred.resolve(null);
	      }, function (dialog) {
	        return $('input', dialog.$el).value;
	      });
	    };

	    modal.labels = {
	      ok: 'Ok',
	      cancel: 'Cancel'
	    };

	    function openDialog(tmpl, options, hideFn, submitFn) {
	      options = assign({
	        bgClose: false,
	        escClose: true,
	        labels: modal.labels
	      }, options);
	      var dialog = modal.dialog(tmpl(options), options);
	      var deferred = new Deferred();
	      var resolved = false;
	      on(dialog.$el, 'submit', 'form', function (e) {
	        e.preventDefault();
	        deferred.resolve(submitFn && submitFn(dialog));
	        resolved = true;
	        dialog.hide();
	      });
	      on(dialog.$el, 'hide', function () {
	        return !resolved && hideFn(deferred);
	      });
	      deferred.promise.dialog = dialog;
	      return deferred.promise;
	    }
	  }

	  var nav = {
	    extends: Accordion,
	    data: {
	      targets: '> .uk-parent',
	      toggle: '> a',
	      content: '> ul'
	    }
	  };
	  var navbar = {
	    mixins: [Class, FlexBug],
	    props: {
	      dropdown: String,
	      mode: 'list',
	      align: String,
	      offset: Number,
	      boundary: Boolean,
	      boundaryAlign: Boolean,
	      clsDrop: String,
	      delayShow: Number,
	      delayHide: Number,
	      dropbar: Boolean,
	      dropbarMode: String,
	      dropbarAnchor: Boolean,
	      duration: Number
	    },
	    data: {
	      dropdown: '.uk-navbar-nav > li',
	      align: !isRtl ? 'left' : 'right',
	      clsDrop: 'uk-navbar-dropdown',
	      mode: undefined,
	      offset: undefined,
	      delayShow: undefined,
	      delayHide: undefined,
	      boundaryAlign: undefined,
	      flip: 'x',
	      boundary: true,
	      dropbar: false,
	      dropbarMode: 'slide',
	      dropbarAnchor: false,
	      duration: 200,
	      forceHeight: true,
	      selMinHeight: '.uk-navbar-nav > li > a, .uk-navbar-item, .uk-navbar-toggle'
	    },
	    computed: {
	      boundary: function (ref, $el) {
	        var boundary = ref.boundary;
	        var boundaryAlign = ref.boundaryAlign;
	        return boundary === true || boundaryAlign ? $el : boundary;
	      },
	      dropbarAnchor: function (ref, $el) {
	        var dropbarAnchor = ref.dropbarAnchor;
	        return query(dropbarAnchor, $el);
	      },
	      pos: function (ref) {
	        var align = ref.align;
	        return "bottom-" + align;
	      },
	      dropbar: {
	        get: function (ref) {
	          var dropbar = ref.dropbar;

	          if (!dropbar) {
	            return null;
	          }

	          dropbar = this._dropbar || query(dropbar, this.$el) || $('+ .uk-navbar-dropbar', this.$el);
	          return dropbar ? dropbar : this._dropbar = $('<div></div>');
	        },
	        watch: function (dropbar) {
	          addClass(dropbar, 'uk-navbar-dropbar');
	        },
	        immediate: true
	      },
	      dropdowns: {
	        get: function (ref, $el) {
	          var dropdown = ref.dropdown;
	          var clsDrop = ref.clsDrop;
	          return $$(dropdown + " ." + clsDrop, $el);
	        },
	        watch: function (dropdowns) {
	          var this$1 = this;
	          this.$create('drop', dropdowns.filter(function (el) {
	            return !this$1.getDropdown(el);
	          }), assign({}, this.$props, {
	            boundary: this.boundary,
	            pos: this.pos,
	            offset: this.dropbar || this.offset
	          }));
	        },
	        immediate: true
	      }
	    },
	    disconnected: function () {
	      this.dropbar && remove(this.dropbar);
	      delete this._dropbar;
	    },
	    events: [{
	      name: 'mouseover',
	      delegate: function () {
	        return this.dropdown;
	      },
	      handler: function (ref) {
	        var current = ref.current;
	        var active = this.getActive();

	        if (active && active.toggle && !within(active.toggle.$el, current) && !active.tracker.movesTo(active.$el)) {
	          active.hide(false);
	        }
	      }
	    }, {
	      name: 'mouseleave',
	      el: function () {
	        return this.dropbar;
	      },
	      handler: function () {
	        var active = this.getActive();

	        if (active && !this.dropdowns.some(function (el) {
	          return matches(el, ':hover');
	        })) {
	          active.hide();
	        }
	      }
	    }, {
	      name: 'beforeshow',
	      capture: true,
	      filter: function () {
	        return this.dropbar;
	      },
	      handler: function () {
	        if (!this.dropbar.parentNode) {
	          after(this.dropbarAnchor || this.$el, this.dropbar);
	        }
	      }
	    }, {
	      name: 'show',
	      capture: true,
	      filter: function () {
	        return this.dropbar;
	      },
	      handler: function (_, drop) {
	        var $el = drop.$el;
	        var dir = drop.dir;
	        toggleClass(this.dropbar, 'uk-navbar-dropbar-slide', this.dropbarMode === 'slide' || parents(this.$el).some(function (el) {
	          return css(el, 'position') !== 'static';
	        }));
	        this.clsDrop && addClass($el, this.clsDrop + "-dropbar");

	        if (dir === 'bottom') {
	          this.transitionTo($el.offsetHeight + toFloat(css($el, 'marginTop')) + toFloat(css($el, 'marginBottom')), $el);
	        }
	      }
	    }, {
	      name: 'beforehide',
	      filter: function () {
	        return this.dropbar;
	      },
	      handler: function (e, ref) {
	        var $el = ref.$el;
	        var active = this.getActive();

	        if (matches(this.dropbar, ':hover') && active && active.$el === $el) {
	          e.preventDefault();
	        }
	      }
	    }, {
	      name: 'hide',
	      filter: function () {
	        return this.dropbar;
	      },
	      handler: function (_, ref) {
	        var $el = ref.$el;
	        var active = this.getActive();

	        if (!active || active && active.$el === $el) {
	          this.transitionTo(0);
	        }
	      }
	    }],
	    methods: {
	      getActive: function () {
	        var ref = this.dropdowns.map(this.getDropdown).filter(function (drop) {
	          return drop && drop.isActive();
	        });
	        var active = ref[0];
	        return active && includes(active.mode, 'hover') && within(active.toggle.$el, this.$el) && active;
	      },
	      transitionTo: function (newHeight, el) {
	        var this$1 = this;
	        var ref = this;
	        var dropbar = ref.dropbar;
	        var oldHeight = isVisible(dropbar) ? height(dropbar) : 0;
	        el = oldHeight < newHeight && el;
	        css(el, 'clip', "rect(0," + el.offsetWidth + "px," + oldHeight + "px,0)");
	        height(dropbar, oldHeight);
	        Transition.cancel([el, dropbar]);
	        return Promise.all([Transition.start(dropbar, {
	          height: newHeight
	        }, this.duration), Transition.start(el, {
	          clip: "rect(0," + el.offsetWidth + "px," + newHeight + "px,0)"
	        }, this.duration)]).catch(noop).then(function () {
	          css(el, {
	            clip: ''
	          });
	          this$1.$update(dropbar);
	        });
	      },
	      getDropdown: function (el) {
	        return this.$getComponent(el, 'drop') || this.$getComponent(el, 'dropdown');
	      }
	    }
	  };
	  var offcanvas = {
	    mixins: [Modal],
	    args: 'mode',
	    props: {
	      mode: String,
	      flip: Boolean,
	      overlay: Boolean
	    },
	    data: {
	      mode: 'slide',
	      flip: false,
	      overlay: false,
	      clsPage: 'uk-offcanvas-page',
	      clsContainer: 'uk-offcanvas-container',
	      selPanel: '.uk-offcanvas-bar',
	      clsFlip: 'uk-offcanvas-flip',
	      clsContainerAnimation: 'uk-offcanvas-container-animation',
	      clsSidebarAnimation: 'uk-offcanvas-bar-animation',
	      clsMode: 'uk-offcanvas',
	      clsOverlay: 'uk-offcanvas-overlay',
	      selClose: '.uk-offcanvas-close',
	      container: false
	    },
	    computed: {
	      clsFlip: function (ref) {
	        var flip = ref.flip;
	        var clsFlip = ref.clsFlip;
	        return flip ? clsFlip : '';
	      },
	      clsOverlay: function (ref) {
	        var overlay = ref.overlay;
	        var clsOverlay = ref.clsOverlay;
	        return overlay ? clsOverlay : '';
	      },
	      clsMode: function (ref) {
	        var mode = ref.mode;
	        var clsMode = ref.clsMode;
	        return clsMode + "-" + mode;
	      },
	      clsSidebarAnimation: function (ref) {
	        var mode = ref.mode;
	        var clsSidebarAnimation = ref.clsSidebarAnimation;
	        return mode === 'none' || mode === 'reveal' ? '' : clsSidebarAnimation;
	      },
	      clsContainerAnimation: function (ref) {
	        var mode = ref.mode;
	        var clsContainerAnimation = ref.clsContainerAnimation;
	        return mode !== 'push' && mode !== 'reveal' ? '' : clsContainerAnimation;
	      },
	      transitionElement: function (ref) {
	        var mode = ref.mode;
	        return mode === 'reveal' ? this.panel.parentNode : this.panel;
	      }
	    },
	    events: [{
	      name: 'click',
	      delegate: function () {
	        return 'a[href^="#"]';
	      },
	      handler: function (ref) {
	        var hash = ref.current.hash;
	        var defaultPrevented = ref.defaultPrevented;

	        if (!defaultPrevented && hash && $(hash, document.body)) {
	          this.hide();
	        }
	      }
	    }, {
	      name: 'touchstart',
	      passive: true,
	      el: function () {
	        return this.panel;
	      },
	      handler: function (ref) {
	        var targetTouches = ref.targetTouches;

	        if (targetTouches.length === 1) {
	          this.clientY = targetTouches[0].clientY;
	        }
	      }
	    }, {
	      name: 'touchmove',
	      self: true,
	      passive: false,
	      filter: function () {
	        return this.overlay;
	      },
	      handler: function (e) {
	        e.cancelable && e.preventDefault();
	      }
	    }, {
	      name: 'touchmove',
	      passive: false,
	      el: function () {
	        return this.panel;
	      },
	      handler: function (e) {
	        if (e.targetTouches.length !== 1) {
	          return;
	        }

	        var clientY = event.targetTouches[0].clientY - this.clientY;
	        var ref = this.panel;
	        var scrollTop = ref.scrollTop;
	        var scrollHeight = ref.scrollHeight;
	        var clientHeight = ref.clientHeight;

	        if (clientHeight >= scrollHeight || scrollTop === 0 && clientY > 0 || scrollHeight - scrollTop <= clientHeight && clientY < 0) {
	          e.cancelable && e.preventDefault();
	        }
	      }
	    }, {
	      name: 'show',
	      self: true,
	      handler: function () {
	        if (this.mode === 'reveal' && !hasClass(this.panel.parentNode, this.clsMode)) {
	          wrapAll(this.panel, '<div>');
	          addClass(this.panel.parentNode, this.clsMode);
	        }

	        css(document.documentElement, 'overflowY', this.overlay ? 'hidden' : '');
	        addClass(document.body, this.clsContainer, this.clsFlip);
	        css(document.body, 'touch-action', 'pan-y pinch-zoom');
	        css(this.$el, 'display', 'block');
	        addClass(this.$el, this.clsOverlay);
	        addClass(this.panel, this.clsSidebarAnimation, this.mode !== 'reveal' ? this.clsMode : '');
	        height(document.body); // force reflow

	        addClass(document.body, this.clsContainerAnimation);
	        this.clsContainerAnimation && suppressUserScale();
	      }
	    }, {
	      name: 'hide',
	      self: true,
	      handler: function () {
	        removeClass(document.body, this.clsContainerAnimation);
	        css(document.body, 'touch-action', '');
	      }
	    }, {
	      name: 'hidden',
	      self: true,
	      handler: function () {
	        this.clsContainerAnimation && resumeUserScale();

	        if (this.mode === 'reveal') {
	          unwrap(this.panel);
	        }

	        removeClass(this.panel, this.clsSidebarAnimation, this.clsMode);
	        removeClass(this.$el, this.clsOverlay);
	        css(this.$el, 'display', '');
	        removeClass(document.body, this.clsContainer, this.clsFlip);
	        css(document.documentElement, 'overflowY', '');
	      }
	    }, {
	      name: 'swipeLeft swipeRight',
	      handler: function (e) {
	        if (this.isToggled() && endsWith(e.type, 'Left') ^ this.flip) {
	          this.hide();
	        }
	      }
	    }]
	  }; // Chrome in responsive mode zooms page upon opening offcanvas

	  function suppressUserScale() {
	    getViewport$1().content += ',user-scalable=0';
	  }

	  function resumeUserScale() {
	    var viewport = getViewport$1();
	    viewport.content = viewport.content.replace(/,user-scalable=0$/, '');
	  }

	  function getViewport$1() {
	    return $('meta[name="viewport"]', document.head) || append(document.head, '<meta name="viewport">');
	  }

	  var overflowAuto = {
	    mixins: [Class],
	    props: {
	      selContainer: String,
	      selContent: String
	    },
	    data: {
	      selContainer: '.uk-modal',
	      selContent: '.uk-modal-dialog'
	    },
	    computed: {
	      container: function (ref, $el) {
	        var selContainer = ref.selContainer;
	        return closest($el, selContainer);
	      },
	      content: function (ref, $el) {
	        var selContent = ref.selContent;
	        return closest($el, selContent);
	      }
	    },
	    connected: function () {
	      css(this.$el, 'minHeight', 150);
	    },
	    update: {
	      read: function () {
	        if (!this.content || !this.container) {
	          return false;
	        }

	        return {
	          current: toFloat(css(this.$el, 'maxHeight')),
	          max: Math.max(150, height(this.container) - (offset(this.content).height - height(this.$el)))
	        };
	      },
	      write: function (ref) {
	        var current = ref.current;
	        var max = ref.max;
	        css(this.$el, 'maxHeight', max);

	        if (Math.round(current) !== Math.round(max)) {
	          trigger(this.$el, 'resize');
	        }
	      },
	      events: ['resize']
	    }
	  };
	  var responsive = {
	    props: ['width', 'height'],
	    connected: function () {
	      addClass(this.$el, 'uk-responsive-width');
	    },
	    update: {
	      read: function () {
	        return isVisible(this.$el) && this.width && this.height ? {
	          width: width(this.$el.parentNode),
	          height: this.height
	        } : false;
	      },
	      write: function (dim) {
	        height(this.$el, Dimensions.contain({
	          height: this.height,
	          width: this.width
	        }, dim).height);
	      },
	      events: ['resize']
	    }
	  };
	  var scroll = {
	    props: {
	      offset: Number
	    },
	    data: {
	      offset: 0
	    },
	    methods: {
	      scrollTo: function (el) {
	        var this$1 = this;
	        el = el && $(el) || document.body;

	        if (trigger(this.$el, 'beforescroll', [this, el])) {
	          scrollIntoView(el, {
	            offset: this.offset
	          }).then(function () {
	            return trigger(this$1.$el, 'scrolled', [this$1, el]);
	          });
	        }
	      }
	    },
	    events: {
	      click: function (e) {
	        if (e.defaultPrevented) {
	          return;
	        }

	        e.preventDefault();
	        this.scrollTo(escape(decodeURIComponent(this.$el.hash)).substr(1));
	      }
	    }
	  };
	  var scrollspy = {
	    args: 'cls',
	    props: {
	      cls: String,
	      target: String,
	      hidden: Boolean,
	      offsetTop: Number,
	      offsetLeft: Number,
	      repeat: Boolean,
	      delay: Number
	    },
	    data: function () {
	      return {
	        cls: false,
	        target: false,
	        hidden: true,
	        offsetTop: 0,
	        offsetLeft: 0,
	        repeat: false,
	        delay: 0,
	        inViewClass: 'uk-scrollspy-inview'
	      };
	    },
	    computed: {
	      elements: {
	        get: function (ref, $el) {
	          var target = ref.target;
	          return target ? $$(target, $el) : [$el];
	        },
	        watch: function (elements) {
	          if (this.hidden) {
	            css(filter(elements, ":not(." + this.inViewClass + ")"), 'visibility', 'hidden');
	          }
	        },
	        immediate: true
	      }
	    },
	    update: [{
	      read: function (ref) {
	        var this$1 = this;
	        var update = ref.update;

	        if (!update) {
	          return;
	        }

	        this.elements.forEach(function (el) {
	          var state = el._ukScrollspyState;

	          if (!state) {
	            state = {
	              cls: data(el, 'uk-scrollspy-class') || this$1.cls
	            };
	          }

	          state.show = isInView(el, this$1.offsetTop, this$1.offsetLeft);
	          el._ukScrollspyState = state;
	        });
	      },
	      write: function (data) {
	        var this$1 = this; // Let child components be applied at least once first

	        if (!data.update) {
	          this.$update();
	          return data.update = true;
	        }

	        this.elements.forEach(function (el) {
	          var state = el._ukScrollspyState;

	          var toggle = function (inview) {
	            css(el, 'visibility', !inview && this$1.hidden ? 'hidden' : '');
	            toggleClass(el, this$1.inViewClass, inview);
	            toggleClass(el, state.cls);
	            trigger(el, inview ? 'inview' : 'outview');
	            state.inview = inview;
	            this$1.$update(el);
	          };

	          if (state.show && !state.inview && !state.queued) {
	            state.queued = true;
	            data.promise = (data.promise || Promise.resolve()).then(function () {
	              return new Promise(function (resolve) {
	                return setTimeout(resolve, this$1.delay);
	              });
	            }).then(function () {
	              toggle(true);
	              setTimeout(function () {
	                return state.queued = false;
	              }, 300);
	            });
	          } else if (!state.show && state.inview && !state.queued && this$1.repeat) {
	            toggle(false);
	          }
	        });
	      },
	      events: ['scroll', 'resize']
	    }]
	  };
	  var scrollspyNav = {
	    props: {
	      cls: String,
	      closest: String,
	      scroll: Boolean,
	      overflow: Boolean,
	      offset: Number
	    },
	    data: {
	      cls: 'uk-active',
	      closest: false,
	      scroll: false,
	      overflow: true,
	      offset: 0
	    },
	    computed: {
	      links: {
	        get: function (_, $el) {
	          return $$('a[href^="#"]', $el).filter(function (el) {
	            return el.hash;
	          });
	        },
	        watch: function (links) {
	          if (this.scroll) {
	            this.$create('scroll', links, {
	              offset: this.offset || 0
	            });
	          }
	        },
	        immediate: true
	      },
	      targets: function () {
	        return $$(this.links.map(function (el) {
	          return escape(el.hash).substr(1);
	        }).join(','));
	      },
	      elements: function (ref) {
	        var selector = ref.closest;
	        return closest(this.links, selector || '*');
	      }
	    },
	    update: [{
	      read: function () {
	        var this$1 = this;
	        var ref = this.targets;
	        var length = ref.length;

	        if (!length || !isVisible(this.$el)) {
	          return false;
	        }

	        var scrollElement = last(scrollParents(this.targets[0]));
	        var scrollTop = scrollElement.scrollTop;
	        var scrollHeight = scrollElement.scrollHeight;
	        var viewport = getViewport(scrollElement);
	        var max = scrollHeight - offset(viewport).height;
	        var active = false;

	        if (scrollTop === max) {
	          active = length - 1;
	        } else {
	          this.targets.every(function (el, i) {
	            if (position(el, viewport).top - this$1.offset <= 0) {
	              active = i;
	              return true;
	            }
	          });

	          if (active === false && this.overflow) {
	            active = 0;
	          }
	        }

	        return {
	          active: active
	        };
	      },
	      write: function (ref) {
	        var active = ref.active;
	        this.links.forEach(function (el) {
	          return el.blur();
	        });
	        removeClass(this.elements, this.cls);

	        if (active !== false) {
	          trigger(this.$el, 'active', [active, addClass(this.elements[active], this.cls)]);
	        }
	      },
	      events: ['scroll', 'resize']
	    }]
	  };
	  var sticky = {
	    mixins: [Class, Media],
	    props: {
	      top: null,
	      bottom: Boolean,
	      offset: String,
	      animation: String,
	      clsActive: String,
	      clsInactive: String,
	      clsFixed: String,
	      clsBelow: String,
	      selTarget: String,
	      widthElement: Boolean,
	      showOnUp: Boolean,
	      targetOffset: Number
	    },
	    data: {
	      top: 0,
	      bottom: false,
	      offset: 0,
	      animation: '',
	      clsActive: 'uk-active',
	      clsInactive: '',
	      clsFixed: 'uk-sticky-fixed',
	      clsBelow: 'uk-sticky-below',
	      selTarget: '',
	      widthElement: false,
	      showOnUp: false,
	      targetOffset: false
	    },
	    computed: {
	      offset: function (ref) {
	        var offset = ref.offset;
	        return toPx(offset);
	      },
	      selTarget: function (ref, $el) {
	        var selTarget = ref.selTarget;
	        return selTarget && $(selTarget, $el) || $el;
	      },
	      widthElement: function (ref, $el) {
	        var widthElement = ref.widthElement;
	        return query(widthElement, $el) || this.placeholder;
	      },
	      isActive: {
	        get: function () {
	          return hasClass(this.selTarget, this.clsActive);
	        },
	        set: function (value) {
	          if (value && !this.isActive) {
	            replaceClass(this.selTarget, this.clsInactive, this.clsActive);
	            trigger(this.$el, 'active');
	          } else if (!value && !hasClass(this.selTarget, this.clsInactive)) {
	            replaceClass(this.selTarget, this.clsActive, this.clsInactive);
	            trigger(this.$el, 'inactive');
	          }
	        }
	      }
	    },
	    connected: function () {
	      this.placeholder = $('+ .uk-sticky-placeholder', this.$el) || $('<div class="uk-sticky-placeholder"></div>');
	      this.isFixed = false;
	      this.isActive = false;
	    },
	    disconnected: function () {
	      if (this.isFixed) {
	        this.hide();
	        removeClass(this.selTarget, this.clsInactive);
	      }

	      remove(this.placeholder);
	      this.placeholder = null;
	      this.widthElement = null;
	    },
	    events: [{
	      name: 'load hashchange popstate',
	      el: window,
	      handler: function () {
	        var this$1 = this;

	        if (!(this.targetOffset !== false && location.hash && window.pageYOffset > 0)) {
	          return;
	        }

	        var target = $(location.hash);

	        if (target) {
	          fastdom.read(function () {
	            var ref = offset(target);
	            var top = ref.top;
	            var elTop = offset(this$1.$el).top;
	            var elHeight = this$1.$el.offsetHeight;

	            if (this$1.isFixed && elTop + elHeight >= top && elTop <= top + target.offsetHeight) {
	              scrollTop(window, top - elHeight - (isNumeric(this$1.targetOffset) ? this$1.targetOffset : 0) - this$1.offset);
	            }
	          });
	        }
	      }
	    }],
	    update: [{
	      read: function (ref, type) {
	        var height = ref.height;

	        if (this.isActive && type !== 'update') {
	          this.hide();
	          height = this.$el.offsetHeight;
	          this.show();
	        }

	        height = !this.isActive ? this.$el.offsetHeight : height;
	        this.topOffset = offset(this.isFixed ? this.placeholder : this.$el).top;
	        this.bottomOffset = this.topOffset + height;
	        var bottom = parseProp('bottom', this);
	        this.top = Math.max(toFloat(parseProp('top', this)), this.topOffset) - this.offset;
	        this.bottom = bottom && bottom - this.$el.offsetHeight;
	        this.inactive = !this.matchMedia;
	        return {
	          lastScroll: false,
	          height: height,
	          margins: css(this.$el, ['marginTop', 'marginBottom', 'marginLeft', 'marginRight'])
	        };
	      },
	      write: function (ref) {
	        var height = ref.height;
	        var margins = ref.margins;
	        var ref$1 = this;
	        var placeholder = ref$1.placeholder;
	        css(placeholder, assign({
	          height: height
	        }, margins));

	        if (!within(placeholder, document)) {
	          after(this.$el, placeholder);
	          attr(placeholder, 'hidden', '');
	        } // ensure active/inactive classes are applied


	        this.isActive = this.isActive; // eslint-disable-line no-self-assign
	      },
	      events: ['resize']
	    }, {
	      read: function (ref) {
	        var scroll = ref.scroll;
	        if (scroll === void 0) scroll = 0;
	        this.width = offset(isVisible(this.widthElement) ? this.widthElement : this.$el).width;
	        this.scroll = window.pageYOffset;
	        return {
	          dir: scroll <= this.scroll ? 'down' : 'up',
	          scroll: this.scroll,
	          visible: isVisible(this.$el),
	          top: offsetPosition(this.placeholder)[0]
	        };
	      },
	      write: function (data, type) {
	        var this$1 = this;
	        var initTimestamp = data.initTimestamp;
	        if (initTimestamp === void 0) initTimestamp = 0;
	        var dir = data.dir;
	        var lastDir = data.lastDir;
	        var lastScroll = data.lastScroll;
	        var scroll = data.scroll;
	        var top = data.top;
	        var visible = data.visible;
	        var now = performance.now();
	        data.lastScroll = scroll;

	        if (scroll < 0 || scroll === lastScroll || !visible || this.disabled || this.showOnUp && type !== 'scroll') {
	          return;
	        }

	        if (now - initTimestamp > 300 || dir !== lastDir) {
	          data.initScroll = scroll;
	          data.initTimestamp = now;
	        }

	        data.lastDir = dir;

	        if (this.showOnUp && !this.isFixed && Math.abs(data.initScroll - scroll) <= 30 && Math.abs(lastScroll - scroll) <= 10) {
	          return;
	        }

	        if (this.inactive || scroll < this.top || this.showOnUp && (scroll <= this.top || dir === 'down' || dir === 'up' && !this.isFixed && scroll <= this.bottomOffset)) {
	          if (!this.isFixed) {
	            if (Animation.inProgress(this.$el) && top > scroll) {
	              Animation.cancel(this.$el);
	              this.hide();
	            }

	            return;
	          }

	          this.isFixed = false;

	          if (this.animation && scroll > this.topOffset) {
	            Animation.cancel(this.$el);
	            Animation.out(this.$el, this.animation).then(function () {
	              return this$1.hide();
	            }, noop);
	          } else {
	            this.hide();
	          }
	        } else if (this.isFixed) {
	          this.update();
	        } else if (this.animation) {
	          Animation.cancel(this.$el);
	          this.show();
	          Animation.in(this.$el, this.animation).catch(noop);
	        } else {
	          this.show();
	        }
	      },
	      events: ['resize', 'scroll']
	    }],
	    methods: {
	      show: function () {
	        this.isFixed = true;
	        this.update();
	        attr(this.placeholder, 'hidden', null);
	      },
	      hide: function () {
	        this.isActive = false;
	        removeClass(this.$el, this.clsFixed, this.clsBelow);
	        css(this.$el, {
	          position: '',
	          top: '',
	          width: ''
	        });
	        attr(this.placeholder, 'hidden', '');
	      },
	      update: function () {
	        var active = this.top !== 0 || this.scroll > this.top;
	        var top = Math.max(0, this.offset);

	        if (isNumeric(this.bottom) && this.scroll > this.bottom - this.offset) {
	          top = this.bottom - this.scroll;
	        }

	        css(this.$el, {
	          position: 'fixed',
	          top: top + "px",
	          width: this.width
	        });
	        this.isActive = active;
	        toggleClass(this.$el, this.clsBelow, this.scroll > this.bottomOffset);
	        addClass(this.$el, this.clsFixed);
	      }
	    }
	  };

	  function parseProp(prop, ref) {
	    var $props = ref.$props;
	    var $el = ref.$el;
	    var propOffset = ref[prop + "Offset"];
	    var value = $props[prop];

	    if (!value) {
	      return;
	    }

	    if (isString(value) && value.match(/^-?\d/)) {
	      return propOffset + toPx(value);
	    } else {
	      return offset(value === true ? $el.parentNode : query(value, $el)).bottom;
	    }
	  }

	  var Switcher = {
	    mixins: [Togglable],
	    args: 'connect',
	    props: {
	      connect: String,
	      toggle: String,
	      active: Number,
	      swiping: Boolean
	    },
	    data: {
	      connect: '~.uk-switcher',
	      toggle: '> * > :first-child',
	      active: 0,
	      swiping: true,
	      cls: 'uk-active',
	      clsContainer: 'uk-switcher',
	      attrItem: 'uk-switcher-item',
	      queued: true
	    },
	    computed: {
	      connects: {
	        get: function (ref, $el) {
	          var connect = ref.connect;
	          return queryAll(connect, $el);
	        },
	        watch: function (connects) {
	          var this$1 = this;
	          connects.forEach(function (list) {
	            return this$1.updateAria(list.children);
	          });

	          if (this.swiping) {
	            css(connects, 'touch-action', 'pan-y pinch-zoom');
	          }
	        },
	        immediate: true
	      },
	      toggles: {
	        get: function (ref, $el) {
	          var toggle = ref.toggle;
	          return $$(toggle, $el).filter(function (el) {
	            return !matches(el, '.uk-disabled *, .uk-disabled, [disabled]');
	          });
	        },
	        watch: function (toggles) {
	          var active = this.index();
	          this.show(~active && active || toggles[this.active] || toggles[0]);
	        },
	        immediate: true
	      }
	    },
	    events: [{
	      name: 'click',
	      delegate: function () {
	        return this.toggle;
	      },
	      handler: function (e) {
	        if (!includes(this.toggles, e.current)) {
	          return;
	        }

	        e.preventDefault();
	        this.show(e.current);
	      }
	    }, {
	      name: 'click',
	      el: function () {
	        return this.connects;
	      },
	      delegate: function () {
	        return "[" + this.attrItem + "],[data-" + this.attrItem + "]";
	      },
	      handler: function (e) {
	        e.preventDefault();
	        this.show(data(e.current, this.attrItem));
	      }
	    }, {
	      name: 'swipeRight swipeLeft',
	      filter: function () {
	        return this.swiping;
	      },
	      el: function () {
	        return this.connects;
	      },
	      handler: function (ref) {
	        var type = ref.type;
	        this.show(endsWith(type, 'Left') ? 'next' : 'previous');
	      }
	    }, {
	      name: 'show',
	      el: function () {
	        return this.connects;
	      },
	      handler: function () {
	        var this$1 = this;
	        var index = this.index();
	        this.toggles.forEach(function (toggle, i) {
	          toggleClass(children(this$1.$el).filter(function (el) {
	            return within(toggle, el);
	          }), this$1.cls, index === i);
	          attr(toggle, 'aria-expanded', index === i);
	        });
	      }
	    }],
	    methods: {
	      index: function () {
	        return index(children(this.connects[0], "." + this.cls)[0]);
	      },
	      show: function (item) {
	        var this$1 = this;
	        var prev = this.index();
	        var next = getIndex(item, this.toggles, prev);
	        this.connects.forEach(function (ref) {
	          var children = ref.children;
	          return this$1.toggleElement([children[prev], children[next]], undefined, prev >= 0);
	        });
	      }
	    }
	  };
	  var tab = {
	    mixins: [Class],
	    extends: Switcher,
	    props: {
	      media: Boolean
	    },
	    data: {
	      media: 960,
	      attrItem: 'uk-tab-item'
	    },
	    connected: function () {
	      var cls = hasClass(this.$el, 'uk-tab-left') ? 'uk-tab-left' : hasClass(this.$el, 'uk-tab-right') ? 'uk-tab-right' : false;

	      if (cls) {
	        this.$create('toggle', this.$el, {
	          cls: cls,
	          mode: 'media',
	          media: this.media
	        });
	      }
	    }
	  };
	  var toggle = {
	    mixins: [Media, Togglable],
	    args: 'target',
	    props: {
	      href: String,
	      target: null,
	      mode: 'list'
	    },
	    data: {
	      href: false,
	      target: false,
	      mode: 'click',
	      queued: true
	    },
	    computed: {
	      target: {
	        get: function (ref, $el) {
	          var href = ref.href;
	          var target = ref.target;
	          target = queryAll(target || href, $el);
	          return target.length && target || [$el];
	        },
	        watch: function () {
	          trigger(this.target, 'updatearia', [this]);
	        },
	        immediate: true
	      }
	    },
	    events: [{
	      name: pointerEnter + " " + pointerLeave,
	      filter: function () {
	        return includes(this.mode, 'hover');
	      },
	      handler: function (e) {
	        if (!isTouch(e)) {
	          this.toggle("toggle" + (e.type === pointerEnter ? 'show' : 'hide'));
	        }
	      }
	    }, {
	      name: 'click',
	      filter: function () {
	        return includes(this.mode, 'click') || hasTouch && includes(this.mode, 'hover');
	      },
	      handler: function (e) {
	        // TODO better isToggled handling
	        var link;

	        if (closest(e.target, 'a[href="#"], a[href=""]') || (link = closest(e.target, 'a[href]')) && (this.cls && !hasClass(this.target, this.cls.split(' ')[0]) || !isVisible(this.target) || link.hash && matches(this.target, link.hash))) {
	          e.preventDefault();
	        }

	        this.toggle();
	      }
	    }],
	    update: {
	      read: function () {
	        return includes(this.mode, 'media') && this.media ? {
	          match: this.matchMedia
	        } : false;
	      },
	      write: function (ref) {
	        var match = ref.match;
	        var toggled = this.isToggled(this.target);

	        if (match ? !toggled : toggled) {
	          this.toggle();
	        }
	      },
	      events: ['resize']
	    },
	    methods: {
	      toggle: function (type) {
	        if (trigger(this.target, type || 'toggle', [this])) {
	          this.toggleElement(this.target);
	        }
	      }
	    }
	  };
	  var coreComponents = /*#__PURE__*/Object.freeze({
	    __proto__: null,
	    Accordion: Accordion,
	    Alert: alert,
	    Cover: cover,
	    Drop: drop,
	    Dropdown: drop,
	    FormCustom: formCustom,
	    Gif: gif,
	    Grid: grid,
	    HeightMatch: heightMatch,
	    HeightViewport: heightViewport,
	    Icon: Icon,
	    Img: img,
	    Leader: leader,
	    Margin: Margin,
	    Modal: modal,
	    Nav: nav,
	    Navbar: navbar,
	    Offcanvas: offcanvas,
	    OverflowAuto: overflowAuto,
	    Responsive: responsive,
	    Scroll: scroll,
	    Scrollspy: scrollspy,
	    ScrollspyNav: scrollspyNav,
	    Sticky: sticky,
	    Svg: SVG,
	    Switcher: Switcher,
	    Tab: tab,
	    Toggle: toggle,
	    Video: Video,
	    Close: Close,
	    Spinner: Spinner,
	    SlidenavNext: Slidenav,
	    SlidenavPrevious: Slidenav,
	    SearchIcon: Search,
	    Marker: IconComponent,
	    NavbarToggleIcon: IconComponent,
	    OverlayIcon: IconComponent,
	    PaginationNext: IconComponent,
	    PaginationPrevious: IconComponent,
	    Totop: IconComponent
	  });
	  var countdown = {
	    mixins: [Class],
	    props: {
	      date: String,
	      clsWrapper: String
	    },
	    data: {
	      date: '',
	      clsWrapper: '.uk-countdown-%unit%'
	    },
	    computed: {
	      date: function (ref) {
	        var date = ref.date;
	        return Date.parse(date);
	      },
	      days: function (ref, $el) {
	        var clsWrapper = ref.clsWrapper;
	        return $(clsWrapper.replace('%unit%', 'days'), $el);
	      },
	      hours: function (ref, $el) {
	        var clsWrapper = ref.clsWrapper;
	        return $(clsWrapper.replace('%unit%', 'hours'), $el);
	      },
	      minutes: function (ref, $el) {
	        var clsWrapper = ref.clsWrapper;
	        return $(clsWrapper.replace('%unit%', 'minutes'), $el);
	      },
	      seconds: function (ref, $el) {
	        var clsWrapper = ref.clsWrapper;
	        return $(clsWrapper.replace('%unit%', 'seconds'), $el);
	      },
	      units: function () {
	        var this$1 = this;
	        return ['days', 'hours', 'minutes', 'seconds'].filter(function (unit) {
	          return this$1[unit];
	        });
	      }
	    },
	    connected: function () {
	      this.start();
	    },
	    disconnected: function () {
	      var this$1 = this;
	      this.stop();
	      this.units.forEach(function (unit) {
	        return empty(this$1[unit]);
	      });
	    },
	    events: [{
	      name: 'visibilitychange',
	      el: document,
	      handler: function () {
	        if (document.hidden) {
	          this.stop();
	        } else {
	          this.start();
	        }
	      }
	    }],
	    update: {
	      write: function () {
	        var this$1 = this;
	        var timespan = getTimeSpan(this.date);

	        if (timespan.total <= 0) {
	          this.stop();
	          timespan.days = timespan.hours = timespan.minutes = timespan.seconds = 0;
	        }

	        this.units.forEach(function (unit) {
	          var digits = String(Math.floor(timespan[unit]));
	          digits = digits.length < 2 ? "0" + digits : digits;
	          var el = this$1[unit];

	          if (el.textContent !== digits) {
	            digits = digits.split('');

	            if (digits.length !== el.children.length) {
	              html(el, digits.map(function () {
	                return '<span></span>';
	              }).join(''));
	            }

	            digits.forEach(function (digit, i) {
	              return el.children[i].textContent = digit;
	            });
	          }
	        });
	      }
	    },
	    methods: {
	      start: function () {
	        this.stop();

	        if (this.date && this.units.length) {
	          this.$update();
	          this.timer = setInterval(this.$update, 1000);
	        }
	      },
	      stop: function () {
	        if (this.timer) {
	          clearInterval(this.timer);
	          this.timer = null;
	        }
	      }
	    }
	  };

	  function getTimeSpan(date) {
	    var total = date - Date.now();
	    return {
	      total: total,
	      seconds: total / 1000 % 60,
	      minutes: total / 1000 / 60 % 60,
	      hours: total / 1000 / 60 / 60 % 24,
	      days: total / 1000 / 60 / 60 / 24
	    };
	  }

	  var targetClass = 'uk-animation-target';
	  var Animate = {
	    props: {
	      animation: Number
	    },
	    data: {
	      animation: 150
	    },
	    computed: {
	      target: function () {
	        return this.$el;
	      }
	    },
	    methods: {
	      animate: function (action) {
	        var this$1 = this;
	        addStyle();
	        var children$1 = children(this.target);
	        var propsFrom = children$1.map(function (el) {
	          return getProps(el, true);
	        });
	        var oldHeight = height(this.target);
	        var oldScrollY = window.pageYOffset;
	        action();
	        Transition.cancel(this.target);
	        children$1.forEach(Transition.cancel);
	        reset(this.target);
	        this.$update(this.target, 'resize');
	        fastdom.flush();
	        var newHeight = height(this.target);
	        children$1 = children$1.concat(children(this.target).filter(function (el) {
	          return !includes(children$1, el);
	        }));
	        var propsTo = children$1.map(function (el, i) {
	          return el.parentNode && i in propsFrom ? propsFrom[i] ? isVisible(el) ? getPositionWithMargin(el) : {
	            opacity: 0
	          } : {
	            opacity: isVisible(el) ? 1 : 0
	          } : false;
	        });
	        propsFrom = propsTo.map(function (props, i) {
	          var from = children$1[i].parentNode === this$1.target ? propsFrom[i] || getProps(children$1[i]) : false;

	          if (from) {
	            if (!props) {
	              delete from.opacity;
	            } else if (!('opacity' in props)) {
	              var opacity = from.opacity;

	              if (opacity % 1) {
	                props.opacity = 1;
	              } else {
	                delete from.opacity;
	              }
	            }
	          }

	          return from;
	        });
	        addClass(this.target, targetClass);
	        children$1.forEach(function (el, i) {
	          return propsFrom[i] && css(el, propsFrom[i]);
	        });
	        css(this.target, {
	          height: oldHeight,
	          display: 'block'
	        });
	        scrollTop(window, oldScrollY);
	        return Promise.all(children$1.map(function (el, i) {
	          return ['top', 'left', 'height', 'width'].some(function (prop) {
	            return propsFrom[i][prop] !== propsTo[i][prop];
	          }) && Transition.start(el, propsTo[i], this$1.animation, 'ease');
	        }).concat(oldHeight !== newHeight && Transition.start(this.target, {
	          height: newHeight
	        }, this.animation, 'ease'))).then(function () {
	          children$1.forEach(function (el, i) {
	            return css(el, {
	              display: propsTo[i].opacity === 0 ? 'none' : '',
	              zIndex: ''
	            });
	          });
	          reset(this$1.target);
	          this$1.$update(this$1.target, 'resize');
	          fastdom.flush(); // needed for IE11
	        }, noop);
	      }
	    }
	  };

	  function getProps(el, opacity) {
	    var zIndex = css(el, 'zIndex');
	    return isVisible(el) ? assign({
	      display: '',
	      opacity: opacity ? css(el, 'opacity') : '0',
	      pointerEvents: 'none',
	      position: 'absolute',
	      zIndex: zIndex === 'auto' ? index(el) : zIndex
	    }, getPositionWithMargin(el)) : false;
	  }

	  function reset(el) {
	    css(el.children, {
	      height: '',
	      left: '',
	      opacity: '',
	      pointerEvents: '',
	      position: '',
	      top: '',
	      width: ''
	    });
	    removeClass(el, targetClass);
	    css(el, {
	      height: '',
	      display: ''
	    });
	  }

	  function getPositionWithMargin(el) {
	    var ref = offset(el);
	    var height = ref.height;
	    var width = ref.width;
	    var ref$1 = position(el);
	    var top = ref$1.top;
	    var left = ref$1.left;
	    return {
	      top: top,
	      left: left,
	      height: height,
	      width: width
	    };
	  }

	  var style;

	  function addStyle() {
	    if (style) {
	      return;
	    }

	    style = append(document.head, '<style>').sheet;
	    style.insertRule("." + targetClass + " > * {\n            margin-top: 0 !important;\n            transform: none !important;\n        }", 0);
	  }

	  var filter$1 = {
	    mixins: [Animate],
	    args: 'target',
	    props: {
	      target: Boolean,
	      selActive: Boolean
	    },
	    data: {
	      target: null,
	      selActive: false,
	      attrItem: 'uk-filter-control',
	      cls: 'uk-active',
	      animation: 250
	    },
	    computed: {
	      toggles: {
	        get: function (ref, $el) {
	          var attrItem = ref.attrItem;
	          return $$("[" + this.attrItem + "],[data-" + this.attrItem + "]", $el);
	        },
	        watch: function () {
	          var this$1 = this;
	          this.updateState();

	          if (this.selActive !== false) {
	            var actives = $$(this.selActive, this.$el);
	            this.toggles.forEach(function (el) {
	              return toggleClass(el, this$1.cls, includes(actives, el));
	            });
	          }
	        },
	        immediate: true
	      },
	      target: function (ref, $el) {
	        var target = ref.target;
	        return $(target, $el);
	      },
	      children: {
	        get: function () {
	          return children(this.target);
	        },
	        watch: function (list, old) {
	          if (!isEqualList(list, old)) {
	            this.updateState();
	          }
	        }
	      }
	    },
	    events: [{
	      name: 'click',
	      delegate: function () {
	        return "[" + this.attrItem + "],[data-" + this.attrItem + "]";
	      },
	      handler: function (e) {
	        e.preventDefault();
	        this.apply(e.current);
	      }
	    }],
	    methods: {
	      apply: function (el) {
	        this.setState(mergeState(el, this.attrItem, this.getState()));
	      },
	      getState: function () {
	        var this$1 = this;
	        return this.toggles.filter(function (item) {
	          return hasClass(item, this$1.cls);
	        }).reduce(function (state, el) {
	          return mergeState(el, this$1.attrItem, state);
	        }, {
	          filter: {
	            '': ''
	          },
	          sort: []
	        });
	      },
	      setState: function (state, animate) {
	        var this$1 = this;
	        if (animate === void 0) animate = true;
	        state = assign({
	          filter: {
	            '': ''
	          },
	          sort: []
	        }, state);
	        trigger(this.$el, 'beforeFilter', [this, state]);
	        var ref = this;
	        var children = ref.children;
	        this.toggles.forEach(function (el) {
	          return toggleClass(el, this$1.cls, !!matchFilter(el, this$1.attrItem, state));
	        });

	        var apply = function () {
	          var selector = getSelector(state);
	          children.forEach(function (el) {
	            return css(el, 'display', selector && !matches(el, selector) ? 'none' : '');
	          });
	          var ref = state.sort;
	          var sort = ref[0];
	          var order = ref[1];

	          if (sort) {
	            var sorted = sortItems(children, sort, order);

	            if (!isEqual(sorted, children)) {
	              sorted.forEach(function (el) {
	                return append(this$1.target, el);
	              });
	            }
	          }
	        };

	        if (animate) {
	          this.animate(apply).then(function () {
	            return trigger(this$1.$el, 'afterFilter', [this$1]);
	          });
	        } else {
	          apply();
	          trigger(this.$el, 'afterFilter', [this]);
	        }
	      },
	      updateState: function () {
	        var this$1 = this;
	        fastdom.write(function () {
	          return this$1.setState(this$1.getState(), false);
	        });
	      }
	    }
	  };

	  function getFilter(el, attr) {
	    return parseOptions(data(el, attr), ['filter']);
	  }

	  function mergeState(el, attr, state) {
	    var filterBy = getFilter(el, attr);
	    var filter = filterBy.filter;
	    var group = filterBy.group;
	    var sort = filterBy.sort;
	    var order = filterBy.order;
	    if (order === void 0) order = 'asc';

	    if (filter || isUndefined(sort)) {
	      if (group) {
	        if (filter) {
	          delete state.filter[''];
	          state.filter[group] = filter;
	        } else {
	          delete state.filter[group];

	          if (isEmpty(state.filter) || '' in state.filter) {
	            state.filter = {
	              '': filter || ''
	            };
	          }
	        }
	      } else {
	        state.filter = {
	          '': filter || ''
	        };
	      }
	    }

	    if (!isUndefined(sort)) {
	      state.sort = [sort, order];
	    }

	    return state;
	  }

	  function matchFilter(el, attr, ref) {
	    var stateFilter = ref.filter;
	    if (stateFilter === void 0) stateFilter = {
	      '': ''
	    };
	    var ref_sort = ref.sort;
	    var stateSort = ref_sort[0];
	    var stateOrder = ref_sort[1];
	    var ref$1 = getFilter(el, attr);
	    var filter = ref$1.filter;
	    if (filter === void 0) filter = '';
	    var group = ref$1.group;
	    if (group === void 0) group = '';
	    var sort = ref$1.sort;
	    var order = ref$1.order;
	    if (order === void 0) order = 'asc';
	    return isUndefined(sort) ? group in stateFilter && filter === stateFilter[group] || !filter && group && !(group in stateFilter) && !stateFilter[''] : stateSort === sort && stateOrder === order;
	  }

	  function isEqualList(listA, listB) {
	    return listA.length === listB.length && listA.every(function (el) {
	      return ~listB.indexOf(el);
	    });
	  }

	  function getSelector(ref) {
	    var filter = ref.filter;
	    var selector = '';
	    each(filter, function (value) {
	      return selector += value || '';
	    });
	    return selector;
	  }

	  function sortItems(nodes, sort, order) {
	    return assign([], nodes).sort(function (a, b) {
	      return data(a, sort).localeCompare(data(b, sort), undefined, {
	        numeric: true
	      }) * (order === 'asc' || -1);
	    });
	  }

	  var Animations = {
	    slide: {
	      show: function (dir) {
	        return [{
	          transform: translate(dir * -100)
	        }, {
	          transform: translate()
	        }];
	      },
	      percent: function (current) {
	        return translated(current);
	      },
	      translate: function (percent, dir) {
	        return [{
	          transform: translate(dir * -100 * percent)
	        }, {
	          transform: translate(dir * 100 * (1 - percent))
	        }];
	      }
	    }
	  };

	  function translated(el) {
	    return Math.abs(css(el, 'transform').split(',')[4] / el.offsetWidth) || 0;
	  }

	  function translate(value, unit) {
	    if (value === void 0) value = 0;
	    if (unit === void 0) unit = '%';
	    value += value ? unit : '';
	    return isIE ? "translateX(" + value + ")" : "translate3d(" + value + ", 0, 0)"; // currently not translate3d in IE, translate3d within translate3d does not work while transitioning
	  }

	  function scale3d(value) {
	    return "scale3d(" + value + ", " + value + ", 1)";
	  }

	  var Animations$1 = assign({}, Animations, {
	    fade: {
	      show: function () {
	        return [{
	          opacity: 0
	        }, {
	          opacity: 1
	        }];
	      },
	      percent: function (current) {
	        return 1 - css(current, 'opacity');
	      },
	      translate: function (percent) {
	        return [{
	          opacity: 1 - percent
	        }, {
	          opacity: percent
	        }];
	      }
	    },
	    scale: {
	      show: function () {
	        return [{
	          opacity: 0,
	          transform: scale3d(1 - .2)
	        }, {
	          opacity: 1,
	          transform: scale3d(1)
	        }];
	      },
	      percent: function (current) {
	        return 1 - css(current, 'opacity');
	      },
	      translate: function (percent) {
	        return [{
	          opacity: 1 - percent,
	          transform: scale3d(1 - .2 * percent)
	        }, {
	          opacity: percent,
	          transform: scale3d(1 - .2 + .2 * percent)
	        }];
	      }
	    }
	  });

	  function Transitioner(prev, next, dir, ref) {
	    var animation = ref.animation;
	    var easing = ref.easing;
	    var percent = animation.percent;
	    var translate = animation.translate;
	    var show = animation.show;
	    if (show === void 0) show = noop;
	    var props = show(dir);
	    var deferred = new Deferred();
	    return {
	      dir: dir,
	      show: function (duration, percent, linear) {
	        var this$1 = this;
	        if (percent === void 0) percent = 0;
	        var timing = linear ? 'linear' : easing;
	        duration -= Math.round(duration * clamp(percent, -1, 1));
	        this.translate(percent);
	        triggerUpdate(next, 'itemin', {
	          percent: percent,
	          duration: duration,
	          timing: timing,
	          dir: dir
	        });
	        triggerUpdate(prev, 'itemout', {
	          percent: 1 - percent,
	          duration: duration,
	          timing: timing,
	          dir: dir
	        });
	        Promise.all([Transition.start(next, props[1], duration, timing), Transition.start(prev, props[0], duration, timing)]).then(function () {
	          this$1.reset();
	          deferred.resolve();
	        }, noop);
	        return deferred.promise;
	      },
	      stop: function () {
	        return Transition.stop([next, prev]);
	      },
	      cancel: function () {
	        Transition.cancel([next, prev]);
	      },
	      reset: function () {
	        for (var prop in props[0]) {
	          css([next, prev], prop, '');
	        }
	      },
	      forward: function (duration, percent) {
	        if (percent === void 0) percent = this.percent();
	        Transition.cancel([next, prev]);
	        return this.show(duration, percent, true);
	      },
	      translate: function (percent) {
	        this.reset();
	        var props = translate(percent, dir);
	        css(next, props[1]);
	        css(prev, props[0]);
	        triggerUpdate(next, 'itemtranslatein', {
	          percent: percent,
	          dir: dir
	        });
	        triggerUpdate(prev, 'itemtranslateout', {
	          percent: 1 - percent,
	          dir: dir
	        });
	      },
	      percent: function () {
	        return percent(prev || next, next, dir);
	      },
	      getDistance: function () {
	        return prev && prev.offsetWidth;
	      }
	    };
	  }

	  function triggerUpdate(el, type, data) {
	    trigger(el, createEvent(type, false, false, data));
	  }

	  var SliderAutoplay = {
	    props: {
	      autoplay: Boolean,
	      autoplayInterval: Number,
	      pauseOnHover: Boolean
	    },
	    data: {
	      autoplay: false,
	      autoplayInterval: 7000,
	      pauseOnHover: true
	    },
	    connected: function () {
	      this.autoplay && this.startAutoplay();
	    },
	    disconnected: function () {
	      this.stopAutoplay();
	    },
	    update: function () {
	      attr(this.slides, 'tabindex', '-1');
	    },
	    events: [{
	      name: 'visibilitychange',
	      el: document,
	      filter: function () {
	        return this.autoplay;
	      },
	      handler: function () {
	        if (document.hidden) {
	          this.stopAutoplay();
	        } else {
	          this.startAutoplay();
	        }
	      }
	    }],
	    methods: {
	      startAutoplay: function () {
	        var this$1 = this;
	        this.stopAutoplay();
	        this.interval = setInterval(function () {
	          return (!this$1.draggable || !$(':focus', this$1.$el)) && (!this$1.pauseOnHover || !matches(this$1.$el, ':hover')) && !this$1.stack.length && this$1.show('next');
	        }, this.autoplayInterval);
	      },
	      stopAutoplay: function () {
	        this.interval && clearInterval(this.interval);
	      }
	    }
	  };
	  var SliderDrag = {
	    props: {
	      draggable: Boolean
	    },
	    data: {
	      draggable: true,
	      threshold: 10
	    },
	    created: function () {
	      var this$1 = this;
	      ['start', 'move', 'end'].forEach(function (key) {
	        var fn = this$1[key];

	        this$1[key] = function (e) {
	          var pos = getEventPos(e).x * (isRtl ? -1 : 1);
	          this$1.prevPos = pos !== this$1.pos ? this$1.pos : this$1.prevPos;
	          this$1.pos = pos;
	          fn(e);
	        };
	      });
	    },
	    events: [{
	      name: pointerDown,
	      delegate: function () {
	        return this.selSlides;
	      },
	      handler: function (e) {
	        if (!this.draggable || !isTouch(e) && hasTextNodesOnly(e.target) || closest(e.target, selInput) || e.button > 0 || this.length < 2) {
	          return;
	        }

	        this.start(e);
	      }
	    }, {
	      // Workaround for iOS 11 bug: https://bugs.webkit.org/show_bug.cgi?id=184250
	      name: 'touchmove',
	      passive: false,
	      handler: 'move',
	      filter: function () {
	        return pointerMove === 'touchmove';
	      },
	      delegate: function () {
	        return this.selSlides;
	      }
	    }, {
	      name: 'dragstart',
	      handler: function (e) {
	        e.preventDefault();
	      }
	    }],
	    methods: {
	      start: function () {
	        var this$1 = this;
	        this.drag = this.pos;

	        if (this._transitioner) {
	          this.percent = this._transitioner.percent();
	          this.drag += this._transitioner.getDistance() * this.percent * this.dir;

	          this._transitioner.cancel();

	          this._transitioner.translate(this.percent);

	          this.dragging = true;
	          this.stack = [];
	        } else {
	          this.prevIndex = this.index;
	        } // See above workaround notice


	        var off = pointerMove !== 'touchmove' ? on(document, pointerMove, this.move, {
	          passive: false
	        }) : noop;

	        this.unbindMove = function () {
	          off();
	          this$1.unbindMove = null;
	        };

	        on(window, 'scroll', this.unbindMove);
	        on(window.visualViewport, 'resize', this.unbindMove);
	        on(document, pointerUp + " " + pointerCancel, this.end, true);
	        css(this.list, 'userSelect', 'none');
	      },
	      move: function (e) {
	        var this$1 = this; // See above workaround notice

	        if (!this.unbindMove) {
	          return;
	        }

	        var distance = this.pos - this.drag;

	        if (distance === 0 || this.prevPos === this.pos || !this.dragging && Math.abs(distance) < this.threshold) {
	          return;
	        }

	        css(this.list, 'pointerEvents', 'none');
	        e.cancelable && e.preventDefault();
	        this.dragging = true;
	        this.dir = distance < 0 ? 1 : -1;
	        var ref = this;
	        var slides = ref.slides;
	        var ref$1 = this;
	        var prevIndex = ref$1.prevIndex;
	        var dis = Math.abs(distance);
	        var nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);
	        var width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;

	        while (nextIndex !== prevIndex && dis > width) {
	          this.drag -= width * this.dir;
	          prevIndex = nextIndex;
	          dis -= width;
	          nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);
	          width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;
	        }

	        this.percent = dis / width;
	        var prev = slides[prevIndex];
	        var next = slides[nextIndex];
	        var changed = this.index !== nextIndex;
	        var edge = prevIndex === nextIndex;
	        var itemShown;
	        [this.index, this.prevIndex].filter(function (i) {
	          return !includes([nextIndex, prevIndex], i);
	        }).forEach(function (i) {
	          trigger(slides[i], 'itemhidden', [this$1]);

	          if (edge) {
	            itemShown = true;
	            this$1.prevIndex = prevIndex;
	          }
	        });

	        if (this.index === prevIndex && this.prevIndex !== prevIndex || itemShown) {
	          trigger(slides[this.index], 'itemshown', [this]);
	        }

	        if (changed) {
	          this.prevIndex = prevIndex;
	          this.index = nextIndex;
	          !edge && trigger(prev, 'beforeitemhide', [this]);
	          trigger(next, 'beforeitemshow', [this]);
	        }

	        this._transitioner = this._translate(Math.abs(this.percent), prev, !edge && next);

	        if (changed) {
	          !edge && trigger(prev, 'itemhide', [this]);
	          trigger(next, 'itemshow', [this]);
	        }
	      },
	      end: function () {
	        off(window, 'scroll', this.unbindMove);
	        off(window.visualViewport, 'resize', this.unbindMove);
	        this.unbindMove && this.unbindMove();
	        off(document, pointerUp, this.end, true);

	        if (this.dragging) {
	          this.dragging = null;

	          if (this.index === this.prevIndex) {
	            this.percent = 1 - this.percent;
	            this.dir *= -1;

	            this._show(false, this.index, true);

	            this._transitioner = null;
	          } else {
	            var dirChange = (isRtl ? this.dir * (isRtl ? 1 : -1) : this.dir) < 0 === this.prevPos > this.pos;
	            this.index = dirChange ? this.index : this.prevIndex;

	            if (dirChange) {
	              this.percent = 1 - this.percent;
	            }

	            this.show(this.dir > 0 && !dirChange || this.dir < 0 && dirChange ? 'next' : 'previous', true);
	          }
	        }

	        css(this.list, {
	          userSelect: '',
	          pointerEvents: ''
	        });
	        this.drag = this.percent = null;
	      }
	    }
	  };

	  function hasTextNodesOnly(el) {
	    return !el.children.length && el.childNodes.length;
	  }

	  var SliderNav = {
	    data: {
	      selNav: false
	    },
	    computed: {
	      nav: function (ref, $el) {
	        var selNav = ref.selNav;
	        return $(selNav, $el);
	      },
	      selNavItem: function (ref) {
	        var attrItem = ref.attrItem;
	        return "[" + attrItem + "],[data-" + attrItem + "]";
	      },
	      navItems: function (_, $el) {
	        return $$(this.selNavItem, $el);
	      }
	    },
	    update: {
	      write: function () {
	        var this$1 = this;

	        if (this.nav && this.length !== this.nav.children.length) {
	          html(this.nav, this.slides.map(function (_, i) {
	            return "<li " + this$1.attrItem + "=\"" + i + "\"><a href></a></li>";
	          }).join(''));
	        }

	        toggleClass($$(this.selNavItem, this.$el).concat(this.nav), 'uk-hidden', !this.maxIndex);
	        this.updateNav();
	      },
	      events: ['resize']
	    },
	    events: [{
	      name: 'click',
	      delegate: function () {
	        return this.selNavItem;
	      },
	      handler: function (e) {
	        e.preventDefault();
	        this.show(data(e.current, this.attrItem));
	      }
	    }, {
	      name: 'itemshow',
	      handler: 'updateNav'
	    }],
	    methods: {
	      updateNav: function () {
	        var this$1 = this;
	        var i = this.getValidIndex();
	        this.navItems.forEach(function (el) {
	          var cmd = data(el, this$1.attrItem);
	          toggleClass(el, this$1.clsActive, toNumber(cmd) === i);
	          toggleClass(el, 'uk-invisible', this$1.finite && (cmd === 'previous' && i === 0 || cmd === 'next' && i >= this$1.maxIndex));
	        });
	      }
	    }
	  };
	  var Slider = {
	    mixins: [SliderAutoplay, SliderDrag, SliderNav],
	    props: {
	      clsActivated: Boolean,
	      easing: String,
	      index: Number,
	      finite: Boolean,
	      velocity: Number,
	      selSlides: String
	    },
	    data: function () {
	      return {
	        easing: 'ease',
	        finite: false,
	        velocity: 1,
	        index: 0,
	        prevIndex: -1,
	        stack: [],
	        percent: 0,
	        clsActive: 'uk-active',
	        clsActivated: false,
	        Transitioner: false,
	        transitionOptions: {}
	      };
	    },
	    connected: function () {
	      this.prevIndex = -1;
	      this.index = this.getValidIndex(this.index);
	      this.stack = [];
	    },
	    disconnected: function () {
	      removeClass(this.slides, this.clsActive);
	    },
	    computed: {
	      duration: function (ref, $el) {
	        var velocity = ref.velocity;
	        return speedUp($el.offsetWidth / velocity);
	      },
	      list: function (ref, $el) {
	        var selList = ref.selList;
	        return $(selList, $el);
	      },
	      maxIndex: function () {
	        return this.length - 1;
	      },
	      selSlides: function (ref) {
	        var selList = ref.selList;
	        var selSlides = ref.selSlides;
	        return selList + " " + (selSlides || '> *');
	      },
	      slides: {
	        get: function () {
	          return $$(this.selSlides, this.$el);
	        },
	        watch: function () {
	          this.$reset();
	        }
	      },
	      length: function () {
	        return this.slides.length;
	      }
	    },
	    events: {
	      itemshown: function () {
	        this.$update(this.list);
	      }
	    },
	    methods: {
	      show: function (index, force) {
	        var this$1 = this;
	        if (force === void 0) force = false;

	        if (this.dragging || !this.length) {
	          return;
	        }

	        var ref = this;
	        var stack = ref.stack;
	        var queueIndex = force ? 0 : stack.length;

	        var reset = function () {
	          stack.splice(queueIndex, 1);

	          if (stack.length) {
	            this$1.show(stack.shift(), true);
	          }
	        };

	        stack[force ? 'unshift' : 'push'](index);

	        if (!force && stack.length > 1) {
	          if (stack.length === 2) {
	            this._transitioner.forward(Math.min(this.duration, 200));
	          }

	          return;
	        }

	        var prevIndex = this.getIndex(this.index);
	        var prev = hasClass(this.slides, this.clsActive) && this.slides[prevIndex];
	        var nextIndex = this.getIndex(index, this.index);
	        var next = this.slides[nextIndex];

	        if (prev === next) {
	          reset();
	          return;
	        }

	        this.dir = getDirection(index, prevIndex);
	        this.prevIndex = prevIndex;
	        this.index = nextIndex;

	        if (prev && !trigger(prev, 'beforeitemhide', [this]) || !trigger(next, 'beforeitemshow', [this, prev])) {
	          this.index = this.prevIndex;
	          reset();
	          return;
	        }

	        var promise = this._show(prev, next, force).then(function () {
	          prev && trigger(prev, 'itemhidden', [this$1]);
	          trigger(next, 'itemshown', [this$1]);
	          return new Promise(function (resolve) {
	            fastdom.write(function () {
	              stack.shift();

	              if (stack.length) {
	                this$1.show(stack.shift(), true);
	              } else {
	                this$1._transitioner = null;
	              }

	              resolve();
	            });
	          });
	        });

	        prev && trigger(prev, 'itemhide', [this]);
	        trigger(next, 'itemshow', [this]);
	        return promise;
	      },
	      getIndex: function (index, prev) {
	        if (index === void 0) index = this.index;
	        if (prev === void 0) prev = this.index;
	        return clamp(getIndex(index, this.slides, prev, this.finite), 0, this.maxIndex);
	      },
	      getValidIndex: function (index, prevIndex) {
	        if (index === void 0) index = this.index;
	        if (prevIndex === void 0) prevIndex = this.prevIndex;
	        return this.getIndex(index, prevIndex);
	      },
	      _show: function (prev, next, force) {
	        this._transitioner = this._getTransitioner(prev, next, this.dir, assign({
	          easing: force ? next.offsetWidth < 600 ? 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
	          /* easeOutQuad */
	          : 'cubic-bezier(0.165, 0.84, 0.44, 1)'
	          /* easeOutQuart */
	          : this.easing
	        }, this.transitionOptions));

	        if (!force && !prev) {
	          this._translate(1);

	          return Promise.resolve();
	        }

	        var ref = this.stack;
	        var length = ref.length;
	        return this._transitioner[length > 1 ? 'forward' : 'show'](length > 1 ? Math.min(this.duration, 75 + 75 / (length - 1)) : this.duration, this.percent);
	      },
	      _getDistance: function (prev, next) {
	        return this._getTransitioner(prev, prev !== next && next).getDistance();
	      },
	      _translate: function (percent, prev, next) {
	        if (prev === void 0) prev = this.prevIndex;
	        if (next === void 0) next = this.index;

	        var transitioner = this._getTransitioner(prev !== next ? prev : false, next);

	        transitioner.translate(percent);
	        return transitioner;
	      },
	      _getTransitioner: function (prev, next, dir, options) {
	        if (prev === void 0) prev = this.prevIndex;
	        if (next === void 0) next = this.index;
	        if (dir === void 0) dir = this.dir || 1;
	        if (options === void 0) options = this.transitionOptions;
	        return new this.Transitioner(isNumber(prev) ? this.slides[prev] : prev, isNumber(next) ? this.slides[next] : next, dir * (isRtl ? -1 : 1), options);
	      }
	    }
	  };

	  function getDirection(index, prevIndex) {
	    return index === 'next' ? 1 : index === 'previous' ? -1 : index < prevIndex ? -1 : 1;
	  }

	  function speedUp(x) {
	    return .5 * x + 300; // parabola through (400,500; 600,600; 1800,1200)
	  }

	  var Slideshow = {
	    mixins: [Slider],
	    props: {
	      animation: String
	    },
	    data: {
	      animation: 'slide',
	      clsActivated: 'uk-transition-active',
	      Animations: Animations,
	      Transitioner: Transitioner
	    },
	    computed: {
	      animation: function (ref) {
	        var animation = ref.animation;
	        var Animations = ref.Animations;
	        return assign(Animations[animation] || Animations.slide, {
	          name: animation
	        });
	      },
	      transitionOptions: function () {
	        return {
	          animation: this.animation
	        };
	      }
	    },
	    events: {
	      'itemshow itemhide itemshown itemhidden': function (ref) {
	        var target = ref.target;
	        this.$update(target);
	      },
	      beforeitemshow: function (ref) {
	        var target = ref.target;
	        addClass(target, this.clsActive);
	      },
	      itemshown: function (ref) {
	        var target = ref.target;
	        addClass(target, this.clsActivated);
	      },
	      itemhidden: function (ref) {
	        var target = ref.target;
	        removeClass(target, this.clsActive, this.clsActivated);
	      }
	    }
	  };
	  var LightboxPanel = {
	    mixins: [Container, Modal, Togglable, Slideshow],
	    functional: true,
	    props: {
	      delayControls: Number,
	      preload: Number,
	      videoAutoplay: Boolean,
	      template: String
	    },
	    data: function () {
	      return {
	        preload: 1,
	        videoAutoplay: false,
	        delayControls: 3000,
	        items: [],
	        cls: 'uk-open',
	        clsPage: 'uk-lightbox-page',
	        selList: '.uk-lightbox-items',
	        attrItem: 'uk-lightbox-item',
	        selClose: '.uk-close-large',
	        selCaption: '.uk-lightbox-caption',
	        pauseOnHover: false,
	        velocity: 2,
	        Animations: Animations$1,
	        template: "<div class=\"uk-lightbox uk-overflow-hidden\"> <ul class=\"uk-lightbox-items\"></ul> <div class=\"uk-lightbox-toolbar uk-position-top uk-text-right uk-transition-slide-top uk-transition-opaque\"> <button class=\"uk-lightbox-toolbar-icon uk-close-large\" type=\"button\" uk-close></button> </div> <a class=\"uk-lightbox-button uk-position-center-left uk-position-medium uk-transition-fade\" href uk-slidenav-previous uk-lightbox-item=\"previous\"></a> <a class=\"uk-lightbox-button uk-position-center-right uk-position-medium uk-transition-fade\" href uk-slidenav-next uk-lightbox-item=\"next\"></a> <div class=\"uk-lightbox-toolbar uk-lightbox-caption uk-position-bottom uk-text-center uk-transition-slide-bottom uk-transition-opaque\"></div> </div>"
	      };
	    },
	    created: function () {
	      var $el = $(this.template);
	      var list = $(this.selList, $el);
	      this.items.forEach(function () {
	        return append(list, '<li>');
	      });
	      this.$mount(append(this.container, $el));
	    },
	    computed: {
	      caption: function (ref, $el) {
	        var selCaption = ref.selCaption;
	        return $('.uk-lightbox-caption', $el);
	      }
	    },
	    events: [{
	      name: pointerMove + " " + pointerDown + " keydown",
	      handler: 'showControls'
	    }, {
	      name: 'click',
	      self: true,
	      delegate: function () {
	        return this.selSlides;
	      },
	      handler: function (e) {
	        if (e.defaultPrevented) {
	          return;
	        }

	        this.hide();
	      }
	    }, {
	      name: 'shown',
	      self: true,
	      handler: function () {
	        this.showControls();
	      }
	    }, {
	      name: 'hide',
	      self: true,
	      handler: function () {
	        this.hideControls();
	        removeClass(this.slides, this.clsActive);
	        Transition.stop(this.slides);
	      }
	    }, {
	      name: 'hidden',
	      self: true,
	      handler: function () {
	        this.$destroy(true);
	      }
	    }, {
	      name: 'keyup',
	      el: document,
	      handler: function (e) {
	        if (!this.isToggled(this.$el) || !this.draggable) {
	          return;
	        }

	        switch (e.keyCode) {
	          case 37:
	            this.show('previous');
	            break;

	          case 39:
	            this.show('next');
	            break;
	        }
	      }
	    }, {
	      name: 'beforeitemshow',
	      handler: function (e) {
	        if (this.isToggled()) {
	          return;
	        }

	        this.draggable = false;
	        e.preventDefault();
	        this.toggleElement(this.$el, true, false);
	        this.animation = Animations$1['scale'];
	        removeClass(e.target, this.clsActive);
	        this.stack.splice(1, 0, this.index);
	      }
	    }, {
	      name: 'itemshow',
	      handler: function () {
	        html(this.caption, this.getItem().caption || '');

	        for (var j = -this.preload; j <= this.preload; j++) {
	          this.loadItem(this.index + j);
	        }
	      }
	    }, {
	      name: 'itemshown',
	      handler: function () {
	        this.draggable = this.$props.draggable;
	      }
	    }, {
	      name: 'itemload',
	      handler: function (_, item) {
	        var this$1 = this;
	        var src = item.source;
	        var type = item.type;
	        var alt = item.alt;
	        if (alt === void 0) alt = '';
	        var poster = item.poster;
	        var attrs = item.attrs;
	        if (attrs === void 0) attrs = {};
	        this.setItem(item, '<span uk-spinner></span>');

	        if (!src) {
	          return;
	        }

	        var matches;
	        var iframeAttrs = {
	          frameborder: '0',
	          allow: 'autoplay',
	          allowfullscreen: '',
	          style: 'max-width: 100%; box-sizing: border-box;',
	          'uk-responsive': '',
	          'uk-video': "" + this.videoAutoplay
	        }; // Image

	        if (type === 'image' || src.match(/\.(jpe?g|png|gif|svg|webp)($|\?)/i)) {
	          getImage(src, attrs.srcset, attrs.size).then(function (ref) {
	            var width = ref.width;
	            var height = ref.height;
	            return this$1.setItem(item, createEl('img', assign({
	              src: src,
	              width: width,
	              height: height,
	              alt: alt
	            }, attrs)));
	          }, function () {
	            return this$1.setError(item);
	          }); // Video
	        } else if (type === 'video' || src.match(/\.(mp4|webm|ogv)($|\?)/i)) {
	          var video = createEl('video', assign({
	            src: src,
	            poster: poster,
	            controls: '',
	            playsinline: '',
	            'uk-video': "" + this.videoAutoplay
	          }, attrs));
	          on(video, 'loadedmetadata', function () {
	            attr(video, {
	              width: video.videoWidth,
	              height: video.videoHeight
	            });
	            this$1.setItem(item, video);
	          });
	          on(video, 'error', function () {
	            return this$1.setError(item);
	          }); // Iframe
	        } else if (type === 'iframe' || src.match(/\.(html|php)($|\?)/i)) {
	          this.setItem(item, createEl('iframe', assign({
	            src: src,
	            frameborder: '0',
	            allowfullscreen: '',
	            class: 'uk-lightbox-iframe'
	          }, attrs))); // YouTube
	        } else if (matches = src.match(/\/\/(?:.*?youtube(-nocookie)?\..*?[?&]v=|youtu\.be\/)([\w-]{11})[&?]?(.*)?/)) {
	          this.setItem(item, createEl('iframe', assign({
	            src: "https://www.youtube" + (matches[1] || '') + ".com/embed/" + matches[2] + (matches[3] ? "?" + matches[3] : ''),
	            width: 1920,
	            height: 1080
	          }, iframeAttrs, attrs))); // Vimeo
	        } else if (matches = src.match(/\/\/.*?vimeo\.[a-z]+\/(\d+)[&?]?(.*)?/)) {
	          ajax("https://vimeo.com/api/oembed.json?maxwidth=1920&url=" + encodeURI(src), {
	            responseType: 'json',
	            withCredentials: false
	          }).then(function (ref) {
	            var ref_response = ref.response;
	            var height = ref_response.height;
	            var width = ref_response.width;
	            return this$1.setItem(item, createEl('iframe', assign({
	              src: "https://player.vimeo.com/video/" + matches[1] + (matches[2] ? "?" + matches[2] : ''),
	              width: width,
	              height: height
	            }, iframeAttrs, attrs)));
	          }, function () {
	            return this$1.setError(item);
	          });
	        }
	      }
	    }],
	    methods: {
	      loadItem: function (index) {
	        if (index === void 0) index = this.index;
	        var item = this.getItem(index);

	        if (!this.getSlide(item).childElementCount) {
	          trigger(this.$el, 'itemload', [item]);
	        }
	      },
	      getItem: function (index) {
	        if (index === void 0) index = this.index;
	        return this.items[getIndex(index, this.slides)];
	      },
	      setItem: function (item, content) {
	        trigger(this.$el, 'itemloaded', [this, html(this.getSlide(item), content)]);
	      },
	      getSlide: function (item) {
	        return this.slides[this.items.indexOf(item)];
	      },
	      setError: function (item) {
	        this.setItem(item, '<span uk-icon="icon: bolt; ratio: 2"></span>');
	      },
	      showControls: function () {
	        clearTimeout(this.controlsTimer);
	        this.controlsTimer = setTimeout(this.hideControls, this.delayControls);
	        addClass(this.$el, 'uk-active', 'uk-transition-active');
	      },
	      hideControls: function () {
	        removeClass(this.$el, 'uk-active', 'uk-transition-active');
	      }
	    }
	  };

	  function createEl(tag, attrs) {
	    var el = fragment("<" + tag + ">");
	    attr(el, attrs);
	    return el;
	  }

	  var lightbox = {
	    install: install$2,
	    props: {
	      toggle: String
	    },
	    data: {
	      toggle: 'a'
	    },
	    computed: {
	      toggles: {
	        get: function (ref, $el) {
	          var toggle = ref.toggle;
	          return $$(toggle, $el);
	        },
	        watch: function () {
	          this.hide();
	        }
	      }
	    },
	    disconnected: function () {
	      this.hide();
	    },
	    events: [{
	      name: 'click',
	      delegate: function () {
	        return this.toggle + ":not(.uk-disabled)";
	      },
	      handler: function (e) {
	        e.preventDefault();
	        this.show(e.current);
	      }
	    }],
	    methods: {
	      show: function (index) {
	        var this$1 = this;
	        var items = uniqueBy(this.toggles.map(toItem), 'source');

	        if (isElement(index)) {
	          var ref = toItem(index);
	          var source = ref.source;
	          index = findIndex(items, function (ref) {
	            var src = ref.source;
	            return source === src;
	          });
	        }

	        this.panel = this.panel || this.$create('lightboxPanel', assign({}, this.$props, {
	          items: items
	        }));
	        on(this.panel.$el, 'hidden', function () {
	          return this$1.panel = false;
	        });
	        return this.panel.show(index);
	      },
	      hide: function () {
	        return this.panel && this.panel.hide();
	      }
	    }
	  };

	  function install$2(UIkit, Lightbox) {
	    if (!UIkit.lightboxPanel) {
	      UIkit.component('lightboxPanel', LightboxPanel);
	    }

	    assign(Lightbox.props, UIkit.component('lightboxPanel').options.props);
	  }

	  function toItem(el) {
	    var item = {};
	    ['href', 'caption', 'type', 'poster', 'alt', 'attrs'].forEach(function (attr) {
	      item[attr === 'href' ? 'source' : attr] = data(el, attr);
	    });
	    item.attrs = parseOptions(item.attrs);
	    return item;
	  }

	  var obj;
	  var notification = {
	    functional: true,
	    args: ['message', 'status'],
	    data: {
	      message: '',
	      status: '',
	      timeout: 5000,
	      group: null,
	      pos: 'top-center',
	      clsContainer: 'uk-notification',
	      clsClose: 'uk-notification-close',
	      clsMsg: 'uk-notification-message'
	    },
	    install: install$3,
	    computed: {
	      marginProp: function (ref) {
	        var pos = ref.pos;
	        return "margin" + (startsWith(pos, 'top') ? 'Top' : 'Bottom');
	      },
	      startProps: function () {
	        var obj;
	        return obj = {
	          opacity: 0
	        }, obj[this.marginProp] = -this.$el.offsetHeight, obj;
	      }
	    },
	    created: function () {
	      var container = $("." + this.clsContainer + "-" + this.pos, this.$container) || append(this.$container, "<div class=\"" + this.clsContainer + " " + this.clsContainer + "-" + this.pos + "\" style=\"display: block\"></div>");
	      this.$mount(append(container, "<div class=\"" + this.clsMsg + (this.status ? " " + this.clsMsg + "-" + this.status : '') + "\"> <a href class=\"" + this.clsClose + "\" data-uk-close></a> <div>" + this.message + "</div> </div>"));
	    },
	    connected: function () {
	      var this$1 = this;
	      var obj;
	      var margin = toFloat(css(this.$el, this.marginProp));
	      Transition.start(css(this.$el, this.startProps), (obj = {
	        opacity: 1
	      }, obj[this.marginProp] = margin, obj)).then(function () {
	        if (this$1.timeout) {
	          this$1.timer = setTimeout(this$1.close, this$1.timeout);
	        }
	      });
	    },
	    events: (obj = {
	      click: function (e) {
	        if (closest(e.target, 'a[href="#"],a[href=""]')) {
	          e.preventDefault();
	        }

	        this.close();
	      }
	    }, obj[pointerEnter] = function () {
	      if (this.timer) {
	        clearTimeout(this.timer);
	      }
	    }, obj[pointerLeave] = function () {
	      if (this.timeout) {
	        this.timer = setTimeout(this.close, this.timeout);
	      }
	    }, obj),
	    methods: {
	      close: function (immediate) {
	        var this$1 = this;

	        var removeFn = function () {
	          var container = this$1.$el.parentNode;
	          trigger(this$1.$el, 'close', [this$1]);
	          remove(this$1.$el);

	          if (container && !container.hasChildNodes()) {
	            remove(container);
	          }
	        };

	        if (this.timer) {
	          clearTimeout(this.timer);
	        }

	        if (immediate) {
	          removeFn();
	        } else {
	          Transition.start(this.$el, this.startProps).then(removeFn);
	        }
	      }
	    }
	  };

	  function install$3(UIkit) {
	    UIkit.notification.closeAll = function (group, immediate) {
	      apply(document.body, function (el) {
	        var notification = UIkit.getComponent(el, 'notification');

	        if (notification && (!group || group === notification.group)) {
	          notification.close(immediate);
	        }
	      });
	    };
	  }

	  var props = ['x', 'y', 'bgx', 'bgy', 'rotate', 'scale', 'color', 'backgroundColor', 'borderColor', 'opacity', 'blur', 'hue', 'grayscale', 'invert', 'saturate', 'sepia', 'fopacity', 'stroke'];
	  var Parallax = {
	    mixins: [Media],
	    props: props.reduce(function (props, prop) {
	      props[prop] = 'list';
	      return props;
	    }, {}),
	    data: props.reduce(function (data, prop) {
	      data[prop] = undefined;
	      return data;
	    }, {}),
	    computed: {
	      props: function (properties, $el) {
	        var this$1 = this;
	        return props.reduce(function (props, prop) {
	          if (isUndefined(properties[prop])) {
	            return props;
	          }

	          var isColor = prop.match(/color/i);
	          var isCssProp = isColor || prop === 'opacity';
	          var pos, bgPos, diff;
	          var steps = properties[prop].slice(0);

	          if (isCssProp) {
	            css($el, prop, '');
	          }

	          if (steps.length < 2) {
	            steps.unshift((prop === 'scale' ? 1 : isCssProp ? css($el, prop) : 0) || 0);
	          }

	          var unit = getUnit(steps);

	          if (isColor) {
	            var ref = $el.style;
	            var color = ref.color;
	            steps = steps.map(function (step) {
	              return parseColor($el, step);
	            });
	            $el.style.color = color;
	          } else if (startsWith(prop, 'bg')) {
	            var attr = prop === 'bgy' ? 'height' : 'width';
	            steps = steps.map(function (step) {
	              return toPx(step, attr, this$1.$el);
	            });
	            css($el, "background-position-" + prop[2], '');
	            bgPos = css($el, 'backgroundPosition').split(' ')[prop[2] === 'x' ? 0 : 1]; // IE 11 can't read background-position-[x|y]

	            if (this$1.covers) {
	              var min = Math.min.apply(Math, steps);
	              var max = Math.max.apply(Math, steps);
	              var down = steps.indexOf(min) < steps.indexOf(max);
	              diff = max - min;
	              steps = steps.map(function (step) {
	                return step - (down ? min : max);
	              });
	              pos = (down ? -diff : 0) + "px";
	            } else {
	              pos = bgPos;
	            }
	          } else {
	            steps = steps.map(toFloat);
	          }

	          if (prop === 'stroke') {
	            if (!steps.some(function (step) {
	              return step;
	            })) {
	              return props;
	            }

	            var length = getMaxPathLength(this$1.$el);
	            css($el, 'strokeDasharray', length);

	            if (unit === '%') {
	              steps = steps.map(function (step) {
	                return step * length / 100;
	              });
	            }

	            steps = steps.reverse();
	            prop = 'strokeDashoffset';
	          }

	          props[prop] = {
	            steps: steps,
	            unit: unit,
	            pos: pos,
	            bgPos: bgPos,
	            diff: diff
	          };
	          return props;
	        }, {});
	      },
	      bgProps: function () {
	        var this$1 = this;
	        return ['bgx', 'bgy'].filter(function (bg) {
	          return bg in this$1.props;
	        });
	      },
	      covers: function (_, $el) {
	        return covers($el);
	      }
	    },
	    disconnected: function () {
	      delete this._image;
	    },
	    update: {
	      read: function (data) {
	        var this$1 = this;
	        data.active = this.matchMedia;

	        if (!data.active) {
	          return;
	        }

	        if (!data.image && this.covers && this.bgProps.length) {
	          var src = css(this.$el, 'backgroundImage').replace(/^none|url\(["']?(.+?)["']?\)$/, '$1');

	          if (src) {
	            var img = new Image();
	            img.src = src;
	            data.image = img;

	            if (!img.naturalWidth) {
	              img.onload = function () {
	                return this$1.$update();
	              };
	            }
	          }
	        }

	        var image = data.image;

	        if (!image || !image.naturalWidth) {
	          return;
	        }

	        var dimEl = {
	          width: this.$el.offsetWidth,
	          height: this.$el.offsetHeight
	        };
	        var dimImage = {
	          width: image.naturalWidth,
	          height: image.naturalHeight
	        };
	        var dim = Dimensions.cover(dimImage, dimEl);
	        this.bgProps.forEach(function (prop) {
	          var ref = this$1.props[prop];
	          var diff = ref.diff;
	          var bgPos = ref.bgPos;
	          var steps = ref.steps;
	          var attr = prop === 'bgy' ? 'height' : 'width';
	          var span = dim[attr] - dimEl[attr];

	          if (span < diff) {
	            dimEl[attr] = dim[attr] + diff - span;
	          } else if (span > diff) {
	            var posPercentage = dimEl[attr] / toPx(bgPos, attr, this$1.$el);

	            if (posPercentage) {
	              this$1.props[prop].steps = steps.map(function (step) {
	                return step - (span - diff) / posPercentage;
	              });
	            }
	          }

	          dim = Dimensions.cover(dimImage, dimEl);
	        });
	        data.dim = dim;
	      },
	      write: function (ref) {
	        var dim = ref.dim;
	        var active = ref.active;

	        if (!active) {
	          css(this.$el, {
	            backgroundSize: '',
	            backgroundRepeat: ''
	          });
	          return;
	        }

	        dim && css(this.$el, {
	          backgroundSize: dim.width + "px " + dim.height + "px",
	          backgroundRepeat: 'no-repeat'
	        });
	      },
	      events: ['resize']
	    },
	    methods: {
	      reset: function () {
	        var this$1 = this;
	        each(this.getCss(0), function (_, prop) {
	          return css(this$1.$el, prop, '');
	        });
	      },
	      getCss: function (percent) {
	        var ref = this;
	        var props = ref.props;
	        return Object.keys(props).reduce(function (css, prop) {
	          var ref = props[prop];
	          var steps = ref.steps;
	          var unit = ref.unit;
	          var pos = ref.pos;
	          var value = getValue(steps, percent);

	          switch (prop) {
	            // transforms
	            case 'x':
	            case 'y':
	              {
	                unit = unit || 'px';
	                css.transform += " translate" + ucfirst(prop) + "(" + toFloat(value).toFixed(unit === 'px' ? 0 : 2) + unit + ")";
	                break;
	              }

	            case 'rotate':
	              unit = unit || 'deg';
	              css.transform += " rotate(" + (value + unit) + ")";
	              break;

	            case 'scale':
	              css.transform += " scale(" + value + ")";
	              break;
	            // bg image

	            case 'bgy':
	            case 'bgx':
	              css["background-position-" + prop[2]] = "calc(" + pos + " + " + value + "px)";
	              break;
	            // color

	            case 'color':
	            case 'backgroundColor':
	            case 'borderColor':
	              {
	                var ref$1 = getStep(steps, percent);
	                var start = ref$1[0];
	                var end = ref$1[1];
	                var p = ref$1[2];
	                css[prop] = "rgba(" + start.map(function (value, i) {
	                  value = value + p * (end[i] - value);
	                  return i === 3 ? toFloat(value) : parseInt(value, 10);
	                }).join(',') + ")";
	                break;
	              }
	            // CSS Filter

	            case 'blur':
	              unit = unit || 'px';
	              css.filter += " blur(" + (value + unit) + ")";
	              break;

	            case 'hue':
	              unit = unit || 'deg';
	              css.filter += " hue-rotate(" + (value + unit) + ")";
	              break;

	            case 'fopacity':
	              unit = unit || '%';
	              css.filter += " opacity(" + (value + unit) + ")";
	              break;

	            case 'grayscale':
	            case 'invert':
	            case 'saturate':
	            case 'sepia':
	              unit = unit || '%';
	              css.filter += " " + prop + "(" + (value + unit) + ")";
	              break;

	            default:
	              css[prop] = value;
	          }

	          return css;
	        }, {
	          transform: '',
	          filter: ''
	        });
	      }
	    }
	  };

	  function parseColor(el, color) {
	    return css(css(el, 'color', color), 'color').split(/[(),]/g).slice(1, -1).concat(1).slice(0, 4).map(toFloat);
	  }

	  function getStep(steps, percent) {
	    var count = steps.length - 1;
	    var index = Math.min(Math.floor(count * percent), count - 1);
	    var step = steps.slice(index, index + 2);
	    step.push(percent === 1 ? 1 : percent % (1 / count) * count);
	    return step;
	  }

	  function getValue(steps, percent, digits) {
	    if (digits === void 0) digits = 2;
	    var ref = getStep(steps, percent);
	    var start = ref[0];
	    var end = ref[1];
	    var p = ref[2];
	    return (isNumber(start) ? start + Math.abs(start - end) * p * (start < end ? 1 : -1) : +end).toFixed(digits);
	  }

	  function getUnit(steps) {
	    return steps.reduce(function (unit, step) {
	      return isString(step) && step.replace(/-|\d/g, '').trim() || unit;
	    }, '');
	  }

	  function covers(el) {
	    var ref = el.style;
	    var backgroundSize = ref.backgroundSize;
	    var covers = css(css(el, 'backgroundSize', ''), 'backgroundSize') === 'cover';
	    el.style.backgroundSize = backgroundSize;
	    return covers;
	  }

	  var parallax = {
	    mixins: [Parallax],
	    props: {
	      target: String,
	      viewport: Number,
	      easing: Number
	    },
	    data: {
	      target: false,
	      viewport: 1,
	      easing: 1
	    },
	    computed: {
	      target: function (ref, $el) {
	        var target = ref.target;
	        return getOffsetElement(target && query(target, $el) || $el);
	      }
	    },
	    update: {
	      read: function (ref, type) {
	        var percent = ref.percent;
	        var active = ref.active;

	        if (type !== 'scroll') {
	          percent = false;
	        }

	        if (!active) {
	          return;
	        }

	        var prev = percent;
	        percent = ease(scrolledOver(this.target) / (this.viewport || 1), this.easing);
	        return {
	          percent: percent,
	          style: prev !== percent ? this.getCss(percent) : false
	        };
	      },
	      write: function (ref) {
	        var style = ref.style;
	        var active = ref.active;

	        if (!active) {
	          this.reset();
	          return;
	        }

	        style && css(this.$el, style);
	      },
	      events: ['scroll', 'resize']
	    }
	  };

	  function ease(percent, easing) {
	    return clamp(percent * (1 - (easing - easing * percent)));
	  } // SVG elements do not inherit from HTMLElement


	  function getOffsetElement(el) {
	    return el ? 'offsetTop' in el ? el : getOffsetElement(el.parentNode) : document.body;
	  }

	  var SliderReactive = {
	    update: {
	      write: function () {
	        if (this.stack.length || this.dragging) {
	          return;
	        }

	        var index = this.getValidIndex(this.index);

	        if (!~this.prevIndex || this.index !== index) {
	          this.show(index);
	        }
	      },
	      events: ['resize']
	    }
	  };

	  function Transitioner$1(prev, next, dir, ref) {
	    var center = ref.center;
	    var easing = ref.easing;
	    var list = ref.list;
	    var deferred = new Deferred();
	    var from = prev ? getLeft(prev, list, center) : getLeft(next, list, center) + offset(next).width * dir;
	    var to = next ? getLeft(next, list, center) : from + offset(prev).width * dir * (isRtl ? -1 : 1);
	    return {
	      dir: dir,
	      show: function (duration, percent, linear) {
	        if (percent === void 0) percent = 0;
	        var timing = linear ? 'linear' : easing;
	        duration -= Math.round(duration * clamp(percent, -1, 1));
	        this.translate(percent);
	        prev && this.updateTranslates();
	        percent = prev ? percent : clamp(percent, 0, 1);
	        triggerUpdate$1(this.getItemIn(), 'itemin', {
	          percent: percent,
	          duration: duration,
	          timing: timing,
	          dir: dir
	        });
	        prev && triggerUpdate$1(this.getItemIn(true), 'itemout', {
	          percent: 1 - percent,
	          duration: duration,
	          timing: timing,
	          dir: dir
	        });
	        Transition.start(list, {
	          transform: translate(-to * (isRtl ? -1 : 1), 'px')
	        }, duration, timing).then(deferred.resolve, noop);
	        return deferred.promise;
	      },
	      stop: function () {
	        return Transition.stop(list);
	      },
	      cancel: function () {
	        Transition.cancel(list);
	      },
	      reset: function () {
	        css(list, 'transform', '');
	      },
	      forward: function (duration, percent) {
	        if (percent === void 0) percent = this.percent();
	        Transition.cancel(list);
	        return this.show(duration, percent, true);
	      },
	      translate: function (percent) {
	        var distance = this.getDistance() * dir * (isRtl ? -1 : 1);
	        css(list, 'transform', translate(clamp(-to + (distance - distance * percent), -getWidth(list), offset(list).width) * (isRtl ? -1 : 1), 'px'));
	        this.updateTranslates();

	        if (prev) {
	          percent = clamp(percent, -1, 1);
	          triggerUpdate$1(this.getItemIn(), 'itemtranslatein', {
	            percent: percent,
	            dir: dir
	          });
	          triggerUpdate$1(this.getItemIn(true), 'itemtranslateout', {
	            percent: 1 - percent,
	            dir: dir
	          });
	        }
	      },
	      percent: function () {
	        return Math.abs((css(list, 'transform').split(',')[4] * (isRtl ? -1 : 1) + from) / (to - from));
	      },
	      getDistance: function () {
	        return Math.abs(to - from);
	      },
	      getItemIn: function (out) {
	        if (out === void 0) out = false;
	        var actives = this.getActives();
	        var all = sortBy(slides(list), 'offsetLeft');
	        var i = index(all, actives[dir * (out ? -1 : 1) > 0 ? actives.length - 1 : 0]);
	        return ~i && all[i + (prev && !out ? dir : 0)];
	      },
	      getActives: function () {
	        var left = getLeft(prev || next, list, center);
	        return sortBy(slides(list).filter(function (slide) {
	          var slideLeft = getElLeft(slide, list);
	          return slideLeft >= left && slideLeft + offset(slide).width <= offset(list).width + left;
	        }), 'offsetLeft');
	      },
	      updateTranslates: function () {
	        var actives = this.getActives();
	        slides(list).forEach(function (slide) {
	          var isActive = includes(actives, slide);
	          triggerUpdate$1(slide, "itemtranslate" + (isActive ? 'in' : 'out'), {
	            percent: isActive ? 1 : 0,
	            dir: slide.offsetLeft <= next.offsetLeft ? 1 : -1
	          });
	        });
	      }
	    };
	  }

	  function getLeft(el, list, center) {
	    var left = getElLeft(el, list);
	    return center ? left - centerEl(el, list) : Math.min(left, getMax(list));
	  }

	  function getMax(list) {
	    return Math.max(0, getWidth(list) - offset(list).width);
	  }

	  function getWidth(list) {
	    return slides(list).reduce(function (right, el) {
	      return offset(el).width + right;
	    }, 0);
	  }

	  function getMaxWidth(list) {
	    return slides(list).reduce(function (right, el) {
	      return Math.max(right, offset(el).width);
	    }, 0);
	  }

	  function centerEl(el, list) {
	    return offset(list).width / 2 - offset(el).width / 2;
	  }

	  function getElLeft(el, list) {
	    return (position(el).left + (isRtl ? offset(el).width - offset(list).width : 0)) * (isRtl ? -1 : 1);
	  }

	  function triggerUpdate$1(el, type, data) {
	    trigger(el, createEvent(type, false, false, data));
	  }

	  function slides(list) {
	    return children(list);
	  }

	  var slider = {
	    mixins: [Class, Slider, SliderReactive],
	    props: {
	      center: Boolean,
	      sets: Boolean
	    },
	    data: {
	      center: false,
	      sets: false,
	      attrItem: 'uk-slider-item',
	      selList: '.uk-slider-items',
	      selNav: '.uk-slider-nav',
	      clsContainer: 'uk-slider-container',
	      Transitioner: Transitioner$1
	    },
	    computed: {
	      avgWidth: function () {
	        return getWidth(this.list) / this.length;
	      },
	      finite: function (ref) {
	        var finite = ref.finite;
	        return finite || Math.ceil(getWidth(this.list)) < offset(this.list).width + getMaxWidth(this.list) + this.center;
	      },
	      maxIndex: function () {
	        if (!this.finite || this.center && !this.sets) {
	          return this.length - 1;
	        }

	        if (this.center) {
	          return last(this.sets);
	        }

	        css(this.slides, 'order', '');
	        var max = getMax(this.list);
	        var i = this.length;

	        while (i--) {
	          if (getElLeft(this.list.children[i], this.list) < max) {
	            return Math.min(i + 1, this.length - 1);
	          }
	        }

	        return 0;
	      },
	      sets: function (ref) {
	        var this$1 = this;
	        var sets = ref.sets;
	        var width = offset(this.list).width / (this.center ? 2 : 1);
	        var left = 0;
	        var leftCenter = width;
	        var slideLeft = 0;
	        sets = sets && this.slides.reduce(function (sets, slide, i) {
	          var ref = offset(slide);
	          var slideWidth = ref.width;
	          var slideRight = slideLeft + slideWidth;

	          if (slideRight > left) {
	            if (!this$1.center && i > this$1.maxIndex) {
	              i = this$1.maxIndex;
	            }

	            if (!includes(sets, i)) {
	              var cmp = this$1.slides[i + 1];

	              if (this$1.center && cmp && slideWidth < leftCenter - offset(cmp).width / 2) {
	                leftCenter -= slideWidth;
	              } else {
	                leftCenter = width;
	                sets.push(i);
	                left = slideLeft + width + (this$1.center ? slideWidth / 2 : 0);
	              }
	            }
	          }

	          slideLeft += slideWidth;
	          return sets;
	        }, []);
	        return !isEmpty(sets) && sets;
	      },
	      transitionOptions: function () {
	        return {
	          center: this.center,
	          list: this.list
	        };
	      }
	    },
	    connected: function () {
	      toggleClass(this.$el, this.clsContainer, !$("." + this.clsContainer, this.$el));
	    },
	    update: {
	      write: function () {
	        var this$1 = this;
	        $$("[" + this.attrItem + "],[data-" + this.attrItem + "]", this.$el).forEach(function (el) {
	          var index = data(el, this$1.attrItem);
	          this$1.maxIndex && toggleClass(el, 'uk-hidden', isNumeric(index) && (this$1.sets && !includes(this$1.sets, toFloat(index)) || index > this$1.maxIndex));
	        });

	        if (this.length && !this.dragging && !this.stack.length) {
	          this._translate(1);
	        }
	      },
	      events: ['resize']
	    },
	    events: {
	      beforeitemshow: function (e) {
	        if (!this.dragging && this.sets && this.stack.length < 2 && !includes(this.sets, this.index)) {
	          this.index = this.getValidIndex();
	        }

	        var diff = Math.abs(this.index - this.prevIndex + (this.dir > 0 && this.index < this.prevIndex || this.dir < 0 && this.index > this.prevIndex ? (this.maxIndex + 1) * this.dir : 0));

	        if (!this.dragging && diff > 1) {
	          for (var i = 0; i < diff; i++) {
	            this.stack.splice(1, 0, this.dir > 0 ? 'next' : 'previous');
	          }

	          e.preventDefault();
	          return;
	        }

	        this.duration = speedUp(this.avgWidth / this.velocity) * (offset(this.dir < 0 || !this.slides[this.prevIndex] ? this.slides[this.index] : this.slides[this.prevIndex]).width / this.avgWidth);
	        this.reorder();
	      },
	      itemshow: function () {
	        !isUndefined(this.prevIndex) && addClass(this._getTransitioner().getItemIn(), this.clsActive);
	      },
	      itemshown: function () {
	        var this$1 = this;

	        var actives = this._getTransitioner(this.index).getActives();

	        this.slides.forEach(function (slide) {
	          return toggleClass(slide, this$1.clsActive, includes(actives, slide));
	        });
	        (!this.sets || includes(this.sets, toFloat(this.index))) && this.slides.forEach(function (slide) {
	          return toggleClass(slide, this$1.clsActivated, includes(actives, slide));
	        });
	      }
	    },
	    methods: {
	      reorder: function () {
	        var this$1 = this;
	        css(this.slides, 'order', '');

	        if (this.finite) {
	          return;
	        }

	        var index = this.dir > 0 && this.slides[this.prevIndex] ? this.prevIndex : this.index;
	        this.slides.forEach(function (slide, i) {
	          return css(slide, 'order', this$1.dir > 0 && i < index ? 1 : this$1.dir < 0 && i >= this$1.index ? -1 : '');
	        });

	        if (!this.center) {
	          return;
	        }

	        var next = this.slides[index];
	        var width = offset(this.list).width / 2 - offset(next).width / 2;
	        var j = 0;

	        while (width > 0) {
	          var slideIndex = this.getIndex(--j + index, index);
	          var slide = this.slides[slideIndex];
	          css(slide, 'order', slideIndex > index ? -2 : -1);
	          width -= offset(slide).width;
	        }
	      },
	      getValidIndex: function (index, prevIndex) {
	        if (index === void 0) index = this.index;
	        if (prevIndex === void 0) prevIndex = this.prevIndex;
	        index = this.getIndex(index, prevIndex);

	        if (!this.sets) {
	          return index;
	        }

	        var prev;

	        do {
	          if (includes(this.sets, index)) {
	            return index;
	          }

	          prev = index;
	          index = this.getIndex(index + this.dir, prevIndex);
	        } while (index !== prev);

	        return index;
	      }
	    }
	  };
	  var sliderParallax = {
	    mixins: [Parallax],
	    data: {
	      selItem: '!li'
	    },
	    computed: {
	      item: function (ref, $el) {
	        var selItem = ref.selItem;
	        return query(selItem, $el);
	      }
	    },
	    events: [{
	      name: 'itemshown',
	      self: true,
	      el: function () {
	        return this.item;
	      },
	      handler: function () {
	        css(this.$el, this.getCss(.5));
	      }
	    }, {
	      name: 'itemin itemout',
	      self: true,
	      el: function () {
	        return this.item;
	      },
	      handler: function (ref) {
	        var type = ref.type;
	        var ref_detail = ref.detail;
	        var percent = ref_detail.percent;
	        var duration = ref_detail.duration;
	        var timing = ref_detail.timing;
	        var dir = ref_detail.dir;
	        Transition.cancel(this.$el);
	        css(this.$el, this.getCss(getCurrent(type, dir, percent)));
	        Transition.start(this.$el, this.getCss(isIn(type) ? .5 : dir > 0 ? 1 : 0), duration, timing).catch(noop);
	      }
	    }, {
	      name: 'transitioncanceled transitionend',
	      self: true,
	      el: function () {
	        return this.item;
	      },
	      handler: function () {
	        Transition.cancel(this.$el);
	      }
	    }, {
	      name: 'itemtranslatein itemtranslateout',
	      self: true,
	      el: function () {
	        return this.item;
	      },
	      handler: function (ref) {
	        var type = ref.type;
	        var ref_detail = ref.detail;
	        var percent = ref_detail.percent;
	        var dir = ref_detail.dir;
	        Transition.cancel(this.$el);
	        css(this.$el, this.getCss(getCurrent(type, dir, percent)));
	      }
	    }]
	  };

	  function isIn(type) {
	    return endsWith(type, 'in');
	  }

	  function getCurrent(type, dir, percent) {
	    percent /= 2;
	    return !isIn(type) ? dir < 0 ? percent : 1 - percent : dir < 0 ? 1 - percent : percent;
	  }

	  var Animations$2 = assign({}, Animations, {
	    fade: {
	      show: function () {
	        return [{
	          opacity: 0,
	          zIndex: 0
	        }, {
	          zIndex: -1
	        }];
	      },
	      percent: function (current) {
	        return 1 - css(current, 'opacity');
	      },
	      translate: function (percent) {
	        return [{
	          opacity: 1 - percent,
	          zIndex: 0
	        }, {
	          zIndex: -1
	        }];
	      }
	    },
	    scale: {
	      show: function () {
	        return [{
	          opacity: 0,
	          transform: scale3d(1 + .5),
	          zIndex: 0
	        }, {
	          zIndex: -1
	        }];
	      },
	      percent: function (current) {
	        return 1 - css(current, 'opacity');
	      },
	      translate: function (percent) {
	        return [{
	          opacity: 1 - percent,
	          transform: scale3d(1 + .5 * percent),
	          zIndex: 0
	        }, {
	          zIndex: -1
	        }];
	      }
	    },
	    pull: {
	      show: function (dir) {
	        return dir < 0 ? [{
	          transform: translate(30),
	          zIndex: -1
	        }, {
	          transform: translate(),
	          zIndex: 0
	        }] : [{
	          transform: translate(-100),
	          zIndex: 0
	        }, {
	          transform: translate(),
	          zIndex: -1
	        }];
	      },
	      percent: function (current, next, dir) {
	        return dir < 0 ? 1 - translated(next) : translated(current);
	      },
	      translate: function (percent, dir) {
	        return dir < 0 ? [{
	          transform: translate(30 * percent),
	          zIndex: -1
	        }, {
	          transform: translate(-100 * (1 - percent)),
	          zIndex: 0
	        }] : [{
	          transform: translate(-percent * 100),
	          zIndex: 0
	        }, {
	          transform: translate(30 * (1 - percent)),
	          zIndex: -1
	        }];
	      }
	    },
	    push: {
	      show: function (dir) {
	        return dir < 0 ? [{
	          transform: translate(100),
	          zIndex: 0
	        }, {
	          transform: translate(),
	          zIndex: -1
	        }] : [{
	          transform: translate(-30),
	          zIndex: -1
	        }, {
	          transform: translate(),
	          zIndex: 0
	        }];
	      },
	      percent: function (current, next, dir) {
	        return dir > 0 ? 1 - translated(next) : translated(current);
	      },
	      translate: function (percent, dir) {
	        return dir < 0 ? [{
	          transform: translate(percent * 100),
	          zIndex: 0
	        }, {
	          transform: translate(-30 * (1 - percent)),
	          zIndex: -1
	        }] : [{
	          transform: translate(-30 * percent),
	          zIndex: -1
	        }, {
	          transform: translate(100 * (1 - percent)),
	          zIndex: 0
	        }];
	      }
	    }
	  });
	  var slideshow = {
	    mixins: [Class, Slideshow, SliderReactive],
	    props: {
	      ratio: String,
	      minHeight: Number,
	      maxHeight: Number
	    },
	    data: {
	      ratio: '16:9',
	      minHeight: false,
	      maxHeight: false,
	      selList: '.uk-slideshow-items',
	      attrItem: 'uk-slideshow-item',
	      selNav: '.uk-slideshow-nav',
	      Animations: Animations$2
	    },
	    update: {
	      read: function () {
	        var ref = this.ratio.split(':').map(Number);
	        var width = ref[0];
	        var height = ref[1];
	        height = height * this.list.offsetWidth / width || 0;

	        if (this.minHeight) {
	          height = Math.max(this.minHeight, height);
	        }

	        if (this.maxHeight) {
	          height = Math.min(this.maxHeight, height);
	        }

	        return {
	          height: height - boxModelAdjust(this.list, 'height', 'content-box')
	        };
	      },
	      write: function (ref) {
	        var height = ref.height;
	        height > 0 && css(this.list, 'minHeight', height);
	      },
	      events: ['resize']
	    }
	  };
	  var sortable = {
	    mixins: [Class, Animate],
	    props: {
	      group: String,
	      threshold: Number,
	      clsItem: String,
	      clsPlaceholder: String,
	      clsDrag: String,
	      clsDragState: String,
	      clsBase: String,
	      clsNoDrag: String,
	      clsEmpty: String,
	      clsCustom: String,
	      handle: String
	    },
	    data: {
	      group: false,
	      threshold: 5,
	      clsItem: 'uk-sortable-item',
	      clsPlaceholder: 'uk-sortable-placeholder',
	      clsDrag: 'uk-sortable-drag',
	      clsDragState: 'uk-drag',
	      clsBase: 'uk-sortable',
	      clsNoDrag: 'uk-sortable-nodrag',
	      clsEmpty: 'uk-sortable-empty',
	      clsCustom: '',
	      handle: false,
	      pos: {}
	    },
	    created: function () {
	      var this$1 = this;
	      ['init', 'start', 'move', 'end'].forEach(function (key) {
	        var fn = this$1[key];

	        this$1[key] = function (e) {
	          assign(this$1.pos, getEventPos(e));
	          fn(e);
	        };
	      });
	    },
	    events: {
	      name: pointerDown,
	      passive: false,
	      handler: 'init'
	    },
	    computed: {
	      target: function () {
	        return (this.$el.tBodies || [this.$el])[0];
	      },
	      items: function () {
	        return children(this.target);
	      },
	      isEmpty: {
	        get: function () {
	          return isEmpty(this.items);
	        },
	        watch: function (empty) {
	          toggleClass(this.target, this.clsEmpty, empty);
	        },
	        immediate: true
	      },
	      handles: {
	        get: function (ref, el) {
	          var handle = ref.handle;
	          return handle ? $$(handle, el) : this.items;
	        },
	        watch: function (handles, prev) {
	          css(prev, {
	            touchAction: '',
	            userSelect: ''
	          });
	          css(handles, {
	            touchAction: hasTouch ? 'none' : '',
	            userSelect: 'none'
	          }); // touchAction set to 'none' causes a performance drop in Chrome 80
	        },
	        immediate: true
	      }
	    },
	    update: {
	      write: function () {
	        if (!this.drag || !parent(this.placeholder)) {
	          return;
	        } // clamp to viewport


	        var ref = this.pos;
	        var x = ref.x;
	        var y = ref.y;
	        var ref$1 = this.origin;
	        var offsetTop = ref$1.offsetTop;
	        var offsetLeft = ref$1.offsetLeft;
	        var ref$2 = this.drag;
	        var offsetHeight = ref$2.offsetHeight;
	        var offsetWidth = ref$2.offsetWidth;
	        var ref$3 = offset(window);
	        var right = ref$3.right;
	        var bottom = ref$3.bottom;
	        var target = document.elementFromPoint(x, y);
	        css(this.drag, {
	          top: clamp(y - offsetTop, 0, bottom - offsetHeight),
	          left: clamp(x - offsetLeft, 0, right - offsetWidth)
	        });
	        var sortable = this.getSortable(target);
	        var previous = this.getSortable(this.placeholder);
	        var move = sortable !== previous;

	        if (!sortable || within(target, this.placeholder) || move && (!sortable.group || sortable.group !== previous.group)) {
	          return;
	        }

	        target = sortable.target === target.parentNode && target || sortable.items.filter(function (element) {
	          return within(target, element);
	        })[0];

	        if (move) {
	          previous.remove(this.placeholder);
	        } else if (!target) {
	          return;
	        }

	        sortable.insert(this.placeholder, target);

	        if (!includes(this.touched, sortable)) {
	          this.touched.push(sortable);
	        }
	      },
	      events: ['move']
	    },
	    methods: {
	      init: function (e) {
	        var target = e.target;
	        var button = e.button;
	        var defaultPrevented = e.defaultPrevented;
	        var ref = this.items.filter(function (el) {
	          return within(target, el);
	        });
	        var placeholder = ref[0];

	        if (!placeholder || defaultPrevented || button > 0 || isInput(target) || within(target, "." + this.clsNoDrag) || this.handle && !within(target, this.handle)) {
	          return;
	        }

	        e.preventDefault();
	        this.touched = [this];
	        this.placeholder = placeholder;
	        this.origin = assign({
	          target: target,
	          index: index(placeholder)
	        }, this.pos);
	        on(document, pointerMove, this.move);
	        on(document, pointerUp, this.end);

	        if (!this.threshold) {
	          this.start(e);
	        }
	      },
	      start: function (e) {
	        this.drag = appendDrag(this.$container, this.placeholder);
	        var ref = this.placeholder.getBoundingClientRect();
	        var left = ref.left;
	        var top = ref.top;
	        assign(this.origin, {
	          offsetLeft: this.pos.x - left,
	          offsetTop: this.pos.y - top
	        });
	        addClass(this.drag, this.clsDrag, this.clsCustom);
	        addClass(this.placeholder, this.clsPlaceholder);
	        addClass(this.items, this.clsItem);
	        addClass(document.documentElement, this.clsDragState);
	        trigger(this.$el, 'start', [this, this.placeholder]);
	        trackScroll(this.pos);
	        this.move(e);
	      },
	      move: function (e) {
	        if (this.drag) {
	          this.$emit('move');
	        } else if (Math.abs(this.pos.x - this.origin.x) > this.threshold || Math.abs(this.pos.y - this.origin.y) > this.threshold) {
	          this.start(e);
	        }
	      },
	      end: function (e) {
	        off(document, pointerMove, this.move);
	        off(document, pointerUp, this.end);
	        off(window, 'scroll', this.scroll);

	        if (!this.drag) {
	          if (e.type === 'touchend') {
	            e.target.click();
	          }

	          return;
	        }

	        untrackScroll();
	        var sortable = this.getSortable(this.placeholder);

	        if (this === sortable) {
	          if (this.origin.index !== index(this.placeholder)) {
	            trigger(this.$el, 'moved', [this, this.placeholder]);
	          }
	        } else {
	          trigger(sortable.$el, 'added', [sortable, this.placeholder]);
	          trigger(this.$el, 'removed', [this, this.placeholder]);
	        }

	        trigger(this.$el, 'stop', [this, this.placeholder]);
	        remove(this.drag);
	        this.drag = null;
	        var classes = this.touched.map(function (sortable) {
	          return sortable.clsPlaceholder + " " + sortable.clsItem;
	        }).join(' ');
	        this.touched.forEach(function (sortable) {
	          return removeClass(sortable.items, classes);
	        });
	        removeClass(document.documentElement, this.clsDragState);
	      },
	      insert: function (element, target) {
	        var this$1 = this;
	        addClass(this.items, this.clsItem);

	        var insert = function () {
	          if (target) {
	            if (!within(element, this$1.target) || isPredecessor(element, target)) {
	              before(target, element);
	            } else {
	              after(target, element);
	            }
	          } else {
	            append(this$1.target, element);
	          }
	        };

	        if (this.animation) {
	          this.animate(insert);
	        } else {
	          insert();
	        }
	      },
	      remove: function (element) {
	        if (!within(element, this.target)) {
	          return;
	        }

	        if (this.animation) {
	          this.animate(function () {
	            return remove(element);
	          });
	        } else {
	          remove(element);
	        }
	      },
	      getSortable: function (element) {
	        return element && (this.$getComponent(element, 'sortable') || this.getSortable(element.parentNode));
	      }
	    }
	  };

	  function isPredecessor(element, target) {
	    return element.parentNode === target.parentNode && index(element) > index(target);
	  }

	  var trackTimer;

	  function trackScroll(pos) {
	    var last = Date.now();
	    trackTimer = setInterval(function () {
	      var x = pos.x;
	      var y = pos.y;
	      y += window.pageYOffset;
	      var dist = (Date.now() - last) * .3;
	      last = Date.now();
	      scrollParents(document.elementFromPoint(x, pos.y)).some(function (scrollEl) {
	        var scroll = scrollEl.scrollTop;
	        var scrollHeight = scrollEl.scrollHeight;
	        var ref = offset(getViewport(scrollEl));
	        var top = ref.top;
	        var bottom = ref.bottom;
	        var height = ref.height;

	        if (top < y && top + 30 > y) {
	          scroll -= dist;
	        } else if (bottom > y && bottom - 30 < y) {
	          scroll += dist;
	        } else {
	          return;
	        }

	        if (scroll > 0 && scroll < scrollHeight - height) {
	          scrollTop(scrollEl, scroll);
	          return true;
	        }
	      });
	    }, 15);
	  }

	  function untrackScroll() {
	    clearInterval(trackTimer);
	  }

	  function appendDrag(container, element) {
	    var clone = append(container, element.outerHTML.replace(/(^<)(?:li|tr)|(?:li|tr)(\/>$)/g, '$1div$2'));
	    attr(clone, 'style', attr(clone, 'style') + ";margin:0!important");
	    css(clone, assign({
	      boxSizing: 'border-box',
	      width: element.offsetWidth,
	      height: element.offsetHeight,
	      overflow: 'hidden'
	    }, css(element, ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom'])));
	    height(clone.firstElementChild, height(element.firstElementChild));
	    return clone;
	  }

	  var obj$1;
	  var actives = [];
	  var tooltip = {
	    mixins: [Container, Togglable, Position],
	    args: 'title',
	    props: {
	      delay: Number,
	      title: String
	    },
	    data: {
	      pos: 'top',
	      title: '',
	      delay: 0,
	      animation: ['uk-animation-scale-up'],
	      duration: 100,
	      cls: 'uk-active',
	      clsPos: 'uk-tooltip'
	    },
	    beforeConnect: function () {
	      this._hasTitle = hasAttr(this.$el, 'title');
	      attr(this.$el, {
	        title: '',
	        'aria-expanded': false
	      });
	    },
	    disconnected: function () {
	      this.hide();
	      attr(this.$el, {
	        title: this._hasTitle ? this.title : null,
	        'aria-expanded': null
	      });
	    },
	    methods: {
	      show: function () {
	        var this$1 = this;

	        if (this.isActive() || !this.title) {
	          return;
	        }

	        actives.forEach(function (active) {
	          return active.hide();
	        });
	        actives.push(this);
	        this._unbind = on(document, pointerUp, function (e) {
	          return !within(e.target, this$1.$el) && this$1.hide();
	        });
	        clearTimeout(this.showTimer);
	        this.showTimer = setTimeout(this._show, this.delay);
	      },
	      hide: function () {
	        var this$1 = this;

	        if (!this.isActive() || matches(this.$el, 'input:focus')) {
	          return;
	        }

	        this.toggleElement(this.tooltip, false, false).then(function () {
	          actives.splice(actives.indexOf(this$1), 1);
	          clearTimeout(this$1.showTimer);
	          this$1.tooltip = remove(this$1.tooltip);

	          this$1._unbind();
	        });
	      },
	      _show: function () {
	        var this$1 = this;
	        this.tooltip = append(this.container, "<div class=\"" + this.clsPos + "\"> <div class=\"" + this.clsPos + "-inner\">" + this.title + "</div> </div>");
	        on(this.tooltip, 'toggled', function () {
	          var toggled = this$1.isToggled(this$1.tooltip);
	          attr(this$1.$el, 'aria-expanded', toggled);

	          if (!toggled) {
	            return;
	          }

	          this$1.positionAt(this$1.tooltip, this$1.$el);
	          this$1.origin = this$1.getAxis() === 'y' ? flipPosition(this$1.dir) + "-" + this$1.align : this$1.align + "-" + flipPosition(this$1.dir);
	        });
	        this.toggleElement(this.tooltip, true);
	      },
	      isActive: function () {
	        return includes(actives, this);
	      }
	    },
	    events: (obj$1 = {
	      focus: 'show',
	      blur: 'hide'
	    }, obj$1[pointerEnter + " " + pointerLeave] = function (e) {
	      if (isTouch(e)) {
	        return;
	      }

	      e.type === pointerEnter ? this.show() : this.hide();
	    }, obj$1[pointerDown] = function (e) {
	      if (!isTouch(e)) {
	        return;
	      }

	      this.isActive() ? this.hide() : this.show();
	    }, obj$1)
	  };
	  var upload = {
	    props: {
	      allow: String,
	      clsDragover: String,
	      concurrent: Number,
	      maxSize: Number,
	      method: String,
	      mime: String,
	      msgInvalidMime: String,
	      msgInvalidName: String,
	      msgInvalidSize: String,
	      multiple: Boolean,
	      name: String,
	      params: Object,
	      type: String,
	      url: String
	    },
	    data: {
	      allow: false,
	      clsDragover: 'uk-dragover',
	      concurrent: 1,
	      maxSize: 0,
	      method: 'POST',
	      mime: false,
	      msgInvalidMime: 'Invalid File Type: %s',
	      msgInvalidName: 'Invalid File Name: %s',
	      msgInvalidSize: 'Invalid File Size: %s Kilobytes Max',
	      multiple: false,
	      name: 'files[]',
	      params: {},
	      type: '',
	      url: '',
	      abort: noop,
	      beforeAll: noop,
	      beforeSend: noop,
	      complete: noop,
	      completeAll: noop,
	      error: noop,
	      fail: noop,
	      load: noop,
	      loadEnd: noop,
	      loadStart: noop,
	      progress: noop
	    },
	    events: {
	      change: function (e) {
	        if (!matches(e.target, 'input[type="file"]')) {
	          return;
	        }

	        e.preventDefault();

	        if (e.target.files) {
	          this.upload(e.target.files);
	        }

	        e.target.value = '';
	      },
	      drop: function (e) {
	        stop(e);
	        var transfer = e.dataTransfer;

	        if (!transfer || !transfer.files) {
	          return;
	        }

	        removeClass(this.$el, this.clsDragover);
	        this.upload(transfer.files);
	      },
	      dragenter: function (e) {
	        stop(e);
	      },
	      dragover: function (e) {
	        stop(e);
	        addClass(this.$el, this.clsDragover);
	      },
	      dragleave: function (e) {
	        stop(e);
	        removeClass(this.$el, this.clsDragover);
	      }
	    },
	    methods: {
	      upload: function (files) {
	        var this$1 = this;

	        if (!files.length) {
	          return;
	        }

	        trigger(this.$el, 'upload', [files]);

	        for (var i = 0; i < files.length; i++) {
	          if (this.maxSize && this.maxSize * 1000 < files[i].size) {
	            this.fail(this.msgInvalidSize.replace('%s', this.maxSize));
	            return;
	          }

	          if (this.allow && !match$1(this.allow, files[i].name)) {
	            this.fail(this.msgInvalidName.replace('%s', this.allow));
	            return;
	          }

	          if (this.mime && !match$1(this.mime, files[i].type)) {
	            this.fail(this.msgInvalidMime.replace('%s', this.mime));
	            return;
	          }
	        }

	        if (!this.multiple) {
	          files = [files[0]];
	        }

	        this.beforeAll(this, files);
	        var chunks = chunk(files, this.concurrent);

	        var upload = function (files) {
	          var data = new FormData();
	          files.forEach(function (file) {
	            return data.append(this$1.name, file);
	          });

	          for (var key in this$1.params) {
	            data.append(key, this$1.params[key]);
	          }

	          ajax(this$1.url, {
	            data: data,
	            method: this$1.method,
	            responseType: this$1.type,
	            beforeSend: function (env) {
	              var xhr = env.xhr;
	              xhr.upload && on(xhr.upload, 'progress', this$1.progress);
	              ['loadStart', 'load', 'loadEnd', 'abort'].forEach(function (type) {
	                return on(xhr, type.toLowerCase(), this$1[type]);
	              });
	              this$1.beforeSend(env);
	            }
	          }).then(function (xhr) {
	            this$1.complete(xhr);

	            if (chunks.length) {
	              upload(chunks.shift());
	            } else {
	              this$1.completeAll(xhr);
	            }
	          }, function (e) {
	            return this$1.error(e);
	          });
	        };

	        upload(chunks.shift());
	      }
	    }
	  };

	  function match$1(pattern, path) {
	    return path.match(new RegExp("^" + pattern.replace(/\//g, '\\/').replace(/\*\*/g, '(\\/[^\\/]+)*').replace(/\*/g, '[^\\/]+').replace(/((?!\\))\?/g, '$1.') + "$", 'i'));
	  }

	  function chunk(files, size) {
	    var chunks = [];

	    for (var i = 0; i < files.length; i += size) {
	      var chunk = [];

	      for (var j = 0; j < size; j++) {
	        chunk.push(files[i + j]);
	      }

	      chunks.push(chunk);
	    }

	    return chunks;
	  }

	  function stop(e) {
	    e.preventDefault();
	    e.stopPropagation();
	  }

	  var components = /*#__PURE__*/Object.freeze({
	    __proto__: null,
	    Countdown: countdown,
	    Filter: filter$1,
	    Lightbox: lightbox,
	    LightboxPanel: LightboxPanel,
	    Notification: notification,
	    Parallax: parallax,
	    Slider: slider,
	    SliderParallax: sliderParallax,
	    Slideshow: slideshow,
	    SlideshowParallax: sliderParallax,
	    Sortable: sortable,
	    Tooltip: tooltip,
	    Upload: upload
	  }); // register components

	  each(coreComponents, register);
	  each(components, register); // core functionality

	  UIkit.use(Core);
	  boot(UIkit);

	  function register(component, name) {
	    UIkit.component(name, component);
	  }

	  return UIkit;
	});
	});

	var uikitIcons = createCommonjsModule(function (module, exports) {
	/*! UIkit 3.4.2 | https://www.getuikit.com | (c) 2014 - 2020 YOOtheme | MIT License */
	(function (global, factory) {
	   module.exports = factory() ;
	})(commonjsGlobal, function () {

	  function plugin(UIkit) {
	    if (plugin.installed) {
	      return;
	    }

	    UIkit.icon.add({
	      "500px": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.624,11.866c-0.141,0.132,0.479,0.658,0.662,0.418c0.051-0.046,0.607-0.61,0.662-0.664c0,0,0.738,0.719,0.814,0.719 c0.1,0,0.207-0.055,0.322-0.17c0.27-0.269,0.135-0.416,0.066-0.495l-0.631-0.616l0.658-0.668c0.146-0.156,0.021-0.314-0.1-0.449 c-0.182-0.18-0.359-0.226-0.471-0.125l-0.656,0.654l-0.654-0.654c-0.033-0.034-0.08-0.045-0.124-0.045 c-0.079,0-0.191,0.068-0.307,0.181c-0.202,0.202-0.247,0.351-0.133,0.462l0.665,0.665L9.624,11.866z\"/><path d=\"M11.066,2.884c-1.061,0-2.185,0.248-3.011,0.604c-0.087,0.034-0.141,0.106-0.15,0.205C7.893,3.784,7.919,3.909,7.982,4.066 c0.05,0.136,0.187,0.474,0.452,0.372c0.844-0.326,1.779-0.507,2.633-0.507c0.963,0,1.9,0.191,2.781,0.564 c0.695,0.292,1.357,0.719,2.078,1.34c0.051,0.044,0.105,0.068,0.164,0.068c0.143,0,0.273-0.137,0.389-0.271 c0.191-0.214,0.324-0.395,0.135-0.575c-0.686-0.654-1.436-1.138-2.363-1.533C13.24,3.097,12.168,2.884,11.066,2.884z\"/><path d=\"M16.43,15.747c-0.092-0.028-0.242,0.05-0.309,0.119l0,0c-0.652,0.652-1.42,1.169-2.268,1.521 c-0.877,0.371-1.814,0.551-2.779,0.551c-0.961,0-1.896-0.189-2.775-0.564c-0.848-0.36-1.612-0.879-2.268-1.53 c-0.682-0.688-1.196-1.455-1.529-2.268c-0.325-0.799-0.471-1.643-0.471-1.643c-0.045-0.24-0.258-0.249-0.567-0.203 c-0.128,0.021-0.519,0.079-0.483,0.36v0.01c0.105,0.644,0.289,1.284,0.545,1.895c0.417,0.969,1.002,1.849,1.756,2.604 c0.757,0.754,1.636,1.34,2.604,1.757C8.901,18.785,9.97,19,11.088,19c1.104,0,2.186-0.215,3.188-0.645 c1.838-0.896,2.604-1.757,2.604-1.757c0.182-0.204,0.227-0.317-0.1-0.643C16.779,15.956,16.525,15.774,16.43,15.747z\"/><path d=\"M5.633,13.287c0.293,0.71,0.723,1.341,1.262,1.882c0.54,0.54,1.172,0.971,1.882,1.264c0.731,0.303,1.509,0.461,2.298,0.461 c0.801,0,1.578-0.158,2.297-0.461c0.711-0.293,1.344-0.724,1.883-1.264c0.543-0.541,0.971-1.172,1.264-1.882 c0.314-0.721,0.463-1.5,0.463-2.298c0-0.79-0.148-1.569-0.463-2.289c-0.293-0.699-0.721-1.329-1.264-1.881 c-0.539-0.541-1.172-0.959-1.867-1.263c-0.721-0.303-1.5-0.461-2.299-0.461c-0.802,0-1.613,0.159-2.322,0.461 c-0.577,0.25-1.544,0.867-2.119,1.454v0.012V2.108h8.16C15.1,2.104,15.1,1.69,15.1,1.552C15.1,1.417,15.1,1,14.809,1H5.915 C5.676,1,5.527,1.192,5.527,1.384v6.84c0,0.214,0.273,0.372,0.529,0.428c0.5,0.105,0.614-0.056,0.737-0.224l0,0 c0.18-0.273,0.776-0.884,0.787-0.894c0.901-0.905,2.117-1.408,3.416-1.408c1.285,0,2.5,0.501,3.412,1.408 c0.914,0.914,1.408,2.122,1.408,3.405c0,1.288-0.508,2.496-1.408,3.405c-0.9,0.896-2.152,1.406-3.438,1.406 c-0.877,0-1.711-0.229-2.433-0.671v-4.158c0-0.553,0.237-1.151,0.643-1.614c0.462-0.519,1.094-0.799,1.782-0.799 c0.664,0,1.293,0.253,1.758,0.715c0.459,0.459,0.709,1.071,0.709,1.723c0,1.385-1.094,2.468-2.488,2.468 c-0.273,0-0.769-0.121-0.781-0.125c-0.281-0.087-0.405,0.306-0.438,0.436c-0.159,0.496,0.079,0.585,0.123,0.607 c0.452,0.137,0.743,0.157,1.129,0.157c1.973,0,3.572-1.6,3.572-3.57c0-1.964-1.6-3.552-3.572-3.552c-0.97,0-1.872,0.36-2.546,1.038 c-0.656,0.631-1.027,1.487-1.027,2.322v3.438v-0.011c-0.372-0.42-0.732-1.041-0.981-1.682c-0.102-0.248-0.315-0.202-0.607-0.113 c-0.135,0.035-0.519,0.157-0.44,0.439C5.372,12.799,5.577,13.164,5.633,13.287z\"/></svg>",
	      "album": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"5\" y=\"2\" width=\"10\" height=\"1\"/><rect x=\"3\" y=\"4\" width=\"14\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"6.5\" width=\"17\" height=\"11\"/></svg>",
	      "arrow-down": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"10.5,16.08 5.63,10.66 6.37,10 10.5,14.58 14.63,10 15.37,10.66\"/><line fill=\"none\" stroke=\"#000\" x1=\"10.5\" y1=\"4\" x2=\"10.5\" y2=\"15\"/></svg>",
	      "arrow-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"10 14 5 9.5 10 5\"/><line fill=\"none\" stroke=\"#000\" x1=\"16\" y1=\"9.5\" x2=\"5\" y2=\"9.52\"/></svg>",
	      "arrow-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"10 5 15 9.5 10 14\"/><line fill=\"none\" stroke=\"#000\" x1=\"4\" y1=\"9.5\" x2=\"15\" y2=\"9.5\"/></svg>",
	      "arrow-up": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"10.5,4 15.37,9.4 14.63,10.08 10.5,5.49 6.37,10.08 5.63,9.4\"/><line fill=\"none\" stroke=\"#000\" x1=\"10.5\" y1=\"16\" x2=\"10.5\" y2=\"5\"/></svg>",
	      "ban": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"4\" y1=\"3.5\" x2=\"16\" y2=\"16.5\"/></svg>",
	      "behance": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.5,10.6c-0.4-0.5-0.9-0.9-1.6-1.1c1.7-1,2.2-3.2,0.7-4.7C7.8,4,6.3,4,5.2,4C3.5,4,1.7,4,0,4v12c1.7,0,3.4,0,5.2,0 c1,0,2.1,0,3.1-0.5C10.2,14.6,10.5,12.3,9.5,10.6L9.5,10.6z M5.6,6.1c1.8,0,1.8,2.7-0.1,2.7c-1,0-2,0-2.9,0V6.1H5.6z M2.6,13.8v-3.1 c1.1,0,2.1,0,3.2,0c2.1,0,2.1,3.2,0.1,3.2L2.6,13.8z\"/><path d=\"M19.9,10.9C19.7,9.2,18.7,7.6,17,7c-4.2-1.3-7.3,3.4-5.3,7.1c0.9,1.7,2.8,2.3,4.7,2.1c1.7-0.2,2.9-1.3,3.4-2.9h-2.2 c-0.4,1.3-2.4,1.5-3.5,0.6c-0.4-0.4-0.6-1.1-0.6-1.7H20C20,11.7,19.9,10.9,19.9,10.9z M13.5,10.6c0-1.6,2.3-2.7,3.5-1.4 c0.4,0.4,0.5,0.9,0.6,1.4H13.5L13.5,10.6z\"/><rect x=\"13\" y=\"4\" width=\"5\" height=\"1.4\"/></svg>",
	      "bell": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M17,15.5 L3,15.5 C2.99,14.61 3.79,13.34 4.1,12.51 C4.58,11.3 4.72,10.35 5.19,7.01 C5.54,4.53 5.89,3.2 7.28,2.16 C8.13,1.56 9.37,1.5 9.81,1.5 L9.96,1.5 C9.96,1.5 11.62,1.41 12.67,2.17 C14.08,3.2 14.42,4.54 14.77,7.02 C15.26,10.35 15.4,11.31 15.87,12.52 C16.2,13.34 17.01,14.61 17,15.5 L17,15.5 Z\"/><path fill=\"none\" stroke=\"#000\" d=\"M12.39,16 C12.39,17.37 11.35,18.43 9.91,18.43 C8.48,18.43 7.42,17.37 7.42,16\"/></svg>",
	      "bold": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5,15.3 C5.66,15.3 5.9,15 5.9,14.53 L5.9,5.5 C5.9,4.92 5.56,4.7 5,4.7 L5,4 L8.95,4 C12.6,4 13.7,5.37 13.7,6.9 C13.7,7.87 13.14,9.17 10.86,9.59 L10.86,9.7 C13.25,9.86 14.29,11.28 14.3,12.54 C14.3,14.47 12.94,16 9,16 L5,16 L5,15.3 Z M9,9.3 C11.19,9.3 11.8,8.5 11.85,7 C11.85,5.65 11.3,4.8 9,4.8 L7.67,4.8 L7.67,9.3 L9,9.3 Z M9.185,15.22 C11.97,15 12.39,14 12.4,12.58 C12.4,11.15 11.39,10 9,10 L7.67,10 L7.67,15 L9.18,15 Z\"/></svg>",
	      "bolt": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.74,20 L7.73,12 L3,12 L15.43,1 L12.32,9 L17.02,9 L4.74,20 L4.74,20 L4.74,20 Z M9.18,11 L7.1,16.39 L14.47,10 L10.86,10 L12.99,4.67 L5.61,11 L9.18,11 L9.18,11 L9.18,11 Z\"/></svg>",
	      "bookmark": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"5.5 1.5 15.5 1.5 15.5 17.5 10.5 12.5 5.5 17.5\"/></svg>",
	      "calendar": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M 2,3 2,17 18,17 18,3 2,3 Z M 17,16 3,16 3,8 17,8 17,16 Z M 17,7 3,7 3,4 17,4 17,7 Z\"/><rect width=\"1\" height=\"3\" x=\"6\" y=\"2\"/><rect width=\"1\" height=\"3\" x=\"13\" y=\"2\"/></svg>",
	      "camera": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10.8\" r=\"3.8\"/><path fill=\"none\" stroke=\"#000\" d=\"M1,4.5 C0.7,4.5 0.5,4.7 0.5,5 L0.5,17 C0.5,17.3 0.7,17.5 1,17.5 L19,17.5 C19.3,17.5 19.5,17.3 19.5,17 L19.5,5 C19.5,4.7 19.3,4.5 19,4.5 L13.5,4.5 L13.5,2.9 C13.5,2.6 13.3,2.5 13,2.5 L7,2.5 C6.7,2.5 6.5,2.6 6.5,2.9 L6.5,4.5 L1,4.5 L1,4.5 Z\"/></svg>",
	      "cart": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"7.3\" cy=\"17.3\" r=\"1.4\"/><circle cx=\"13.3\" cy=\"17.3\" r=\"1.4\"/><polyline fill=\"none\" stroke=\"#000\" points=\"0 2 3.2 4 5.3 12.5 16 12.5 18 6.5 8 6.5\"/></svg>",
	      "check": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"4,10 8,15 17,4\"/></svg>",
	      "chevron-double-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"10 14 6 10 10 6\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"14 14 10 10 14 6\"/></svg>",
	      "chevron-double-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"10 6 14 10 10 14\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"6 6 10 10 6 14\"/></svg>",
	      "chevron-down": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"16 7 10 13 4 7\"/></svg>",
	      "chevron-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"13 16 7 10 13 4\"/></svg>",
	      "chevron-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"7 4 13 10 7 16\"/></svg>",
	      "chevron-up": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"4 13 10 7 16 13\"/></svg>",
	      "clock": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><rect x=\"9\" y=\"4\" width=\"1\" height=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M13.018,14.197 L9.445,10.625\"/></svg>",
	      "close": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.06\" d=\"M16,16 L4,4\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.06\" d=\"M16,4 L4,16\"/></svg>",
	      "cloud-download": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.3,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6\"/><polyline fill=\"none\" stroke=\"#000\" points=\"11.75 16 9.5 18.25 7.25 16\"/><path fill=\"none\" stroke=\"#000\" d=\"M9.5,18 L9.5,9.5\"/></svg>",
	      "cloud-upload": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.31,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6\"/><polyline fill=\"none\" stroke=\"#000\" points=\"7.25 11.75 9.5 9.5 11.75 11.75\"/><path fill=\"none\" stroke=\"#000\" d=\"M9.5,18 L9.5,9.5\"/></svg>",
	      "code": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"13,4 19,10 13,16\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"7,4 1,10 7,16\"/></svg>",
	      "cog": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" cx=\"9.997\" cy=\"10\" r=\"3.31\"/><path fill=\"none\" stroke=\"#000\" d=\"M18.488,12.285 L16.205,16.237 C15.322,15.496 14.185,15.281 13.303,15.791 C12.428,16.289 12.047,17.373 12.246,18.5 L7.735,18.5 C7.938,17.374 7.553,16.299 6.684,15.791 C5.801,15.27 4.655,15.492 3.773,16.237 L1.5,12.285 C2.573,11.871 3.317,10.999 3.317,9.991 C3.305,8.98 2.573,8.121 1.5,7.716 L3.765,3.784 C4.645,4.516 5.794,4.738 6.687,4.232 C7.555,3.722 7.939,2.637 7.735,1.5 L12.263,1.5 C12.072,2.637 12.441,3.71 13.314,4.22 C14.206,4.73 15.343,4.516 16.225,3.794 L18.487,7.714 C17.404,8.117 16.661,8.988 16.67,10.009 C16.672,11.018 17.415,11.88 18.488,12.285 L18.488,12.285 Z\"/></svg>",
	      "comment": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6,18.71 L6,14 L1,14 L1,1 L19,1 L19,14 L10.71,14 L6,18.71 L6,18.71 Z M2,13 L7,13 L7,16.29 L10.29,13 L18,13 L18,2 L2,2 L2,13 L2,13 Z\"/></svg>",
	      "commenting": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"1.5,1.5 18.5,1.5 18.5,13.5 10.5,13.5 6.5,17.5 6.5,13.5 1.5,13.5\"/><circle cx=\"10\" cy=\"8\" r=\"1\"/><circle cx=\"6\" cy=\"8\" r=\"1\"/><circle cx=\"14\" cy=\"8\" r=\"1\"/></svg>",
	      "comments": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"2 0.5 19.5 0.5 19.5 13\"/><path d=\"M5,19.71 L5,15 L0,15 L0,2 L18,2 L18,15 L9.71,15 L5,19.71 L5,19.71 L5,19.71 Z M1,14 L6,14 L6,17.29 L9.29,14 L17,14 L17,3 L1,3 L1,14 L1,14 L1,14 Z\"/></svg>",
	      "copy": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"2.5\" width=\"12\" height=\"16\"/><polyline fill=\"none\" stroke=\"#000\" points=\"5 0.5 17.5 0.5 17.5 17\"/></svg>",
	      "credit-card": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"4.5\" width=\"17\" height=\"12\"/><rect x=\"1\" y=\"7\" width=\"18\" height=\"3\"/></svg>",
	      "database": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><ellipse fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"4.64\" rx=\"7.5\" ry=\"3.14\"/><path fill=\"none\" stroke=\"#000\" d=\"M17.5,8.11 C17.5,9.85 14.14,11.25 10,11.25 C5.86,11.25 2.5,9.84 2.5,8.11\"/><path fill=\"none\" stroke=\"#000\" d=\"M17.5,11.25 C17.5,12.99 14.14,14.39 10,14.39 C5.86,14.39 2.5,12.98 2.5,11.25\"/><path fill=\"none\" stroke=\"#000\" d=\"M17.49,4.64 L17.5,14.36 C17.5,16.1 14.14,17.5 10,17.5 C5.86,17.5 2.5,16.09 2.5,14.36 L2.5,4.64\"/></svg>",
	      "desktop": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"8\" y=\"15\" width=\"1\" height=\"2\"/><rect x=\"11\" y=\"15\" width=\"1\" height=\"2\"/><rect x=\"5\" y=\"16\" width=\"10\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"3.5\" width=\"17\" height=\"11\"/></svg>",
	      "download": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"14,10 9.5,14.5 5,10\"/><rect x=\"3\" y=\"17\" width=\"13\" height=\"1\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"13.91\" x2=\"9.5\" y2=\"3\"/></svg>",
	      "dribbble": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" d=\"M1.3,8.9c0,0,5,0.1,8.6-1c1.4-0.4,2.6-0.9,4-1.9 c1.4-1.1,2.5-2.5,2.5-2.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" d=\"M3.9,16.6c0,0,1.7-2.8,3.5-4.2 c1.8-1.3,4-2,5.7-2.2C16,10,19,10.6,19,10.6\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" d=\"M6.9,1.6c0,0,3.3,4.6,4.2,6.8 c0.4,0.9,1.3,3.1,1.9,5.2c0.6,2,0.9,4.4,0.9,4.4\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" cx=\"10\" cy=\"10\" r=\"9\"/></svg>",
	      "etsy": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><path d=\"M8,4.26C8,4.07,8,4,8.31,4h4.46c.79,0,1.22.67,1.53,1.91l.25,1h.76c.14-2.82.26-4,.26-4S13.65,3,12.52,3H6.81L3.75,2.92v.84l1,.2c.73.11.9.27,1,1,0,0,.06,2,.06,5.17s-.06,5.14-.06,5.14c0,.59-.23.81-1,.94l-1,.2v.84l3.06-.1h5.11c1.15,0,3.82.1,3.82.1,0-.7.45-3.88.51-4.22h-.73l-.76,1.69a2.25,2.25,0,0,1-2.45,1.47H9.4c-1,0-1.44-.4-1.44-1.24V10.44s2.16,0,2.86.06c.55,0,.85.19,1.06,1l.23,1H13L12.9,9.94,13,7.41h-.85l-.28,1.13c-.16.74-.28.84-1,1-1,.1-2.89.09-2.89.09Z\"/></svg>",
	      "expand": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"13 2 18 2 18 7 17 7 17 3 13 3\"/><polygon points=\"2 13 3 13 3 17 7 17 7 18 2 18\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M11,9 L17,3\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M3,17 L9,11\"/></svg>",
	      "facebook": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11,10h2.6l0.4-3H11V5.3c0-0.9,0.2-1.5,1.5-1.5H14V1.1c-0.3,0-1-0.1-2.1-0.1C9.6,1,8,2.4,8,5v2H5.5v3H8v8h3V10z\"/></svg>",
	      "file-edit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M18.65,1.68 C18.41,1.45 18.109,1.33 17.81,1.33 C17.499,1.33 17.209,1.45 16.98,1.68 L8.92,9.76 L8,12.33 L10.55,11.41 L18.651,3.34 C19.12,2.87 19.12,2.15 18.65,1.68 L18.65,1.68 L18.65,1.68 Z\"/><polyline fill=\"none\" stroke=\"#000\" points=\"16.5 8.482 16.5 18.5 3.5 18.5 3.5 1.5 14.211 1.5\"/></svg>",
	      "file-pdf": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" width=\"13\" height=\"17\" x=\"3.5\" y=\"1.5\"/><path d=\"M14.65 11.67c-.48.3-1.37-.19-1.79-.37a4.65 4.65 0 0 1 1.49.06c.35.1.36.28.3.31zm-6.3.06l.43-.79a14.7 14.7 0 0 0 .75-1.64 5.48 5.48 0 0 0 1.25 1.55l.2.15a16.36 16.36 0 0 0-2.63.73zM9.5 5.32c.2 0 .32.5.32.97a1.99 1.99 0 0 1-.23 1.04 5.05 5.05 0 0 1-.17-1.3s0-.71.08-.71zm-3.9 9a4.35 4.35 0 0 1 1.21-1.46l.24-.22a4.35 4.35 0 0 1-1.46 1.68zm9.23-3.3a2.05 2.05 0 0 0-1.32-.3 11.07 11.07 0 0 0-1.58.11 4.09 4.09 0 0 1-.74-.5 5.39 5.39 0 0 1-1.32-2.06 10.37 10.37 0 0 0 .28-2.62 1.83 1.83 0 0 0-.07-.25.57.57 0 0 0-.52-.4H9.4a.59.59 0 0 0-.6.38 6.95 6.95 0 0 0 .37 3.14c-.26.63-1 2.12-1 2.12-.3.58-.57 1.08-.82 1.5l-.8.44A3.11 3.11 0 0 0 5 14.16a.39.39 0 0 0 .15.42l.24.13c1.15.56 2.28-1.74 2.66-2.42a23.1 23.1 0 0 1 3.59-.85 4.56 4.56 0 0 0 2.91.8.5.5 0 0 0 .3-.21 1.1 1.1 0 0 0 .12-.75.84.84 0 0 0-.14-.25z\"/></svg>",
	      "file-text": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" width=\"13\" height=\"17\" x=\"3.5\" y=\"1.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"12\" y1=\"12.5\" y2=\"12.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"14\" y1=\"8.5\" y2=\"8.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"14\" y1=\"6.5\" y2=\"6.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"14\" y1=\"10.5\" y2=\"10.5\"/></svg>",
	      "file": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"1.5\" width=\"13\" height=\"17\"/></svg>",
	      "flickr": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"5.5\" cy=\"9.5\" r=\"3.5\"/><circle cx=\"14.5\" cy=\"9.5\" r=\"3.5\"/></svg>",
	      "folder": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"9.5 5.5 8.5 3.5 1.5 3.5 1.5 16.5 18.5 16.5 18.5 5.5\"/></svg>",
	      "forward": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2.47,13.11 C4.02,10.02 6.27,7.85 9.04,6.61 C9.48,6.41 10.27,6.13 11,5.91 L11,2 L18.89,9 L11,16 L11,12.13 C9.25,12.47 7.58,13.19 6.02,14.25 C3.03,16.28 1.63,18.54 1.63,18.54 C1.63,18.54 1.38,15.28 2.47,13.11 L2.47,13.11 Z M5.3,13.53 C6.92,12.4 9.04,11.4 12,10.92 L12,13.63 L17.36,9 L12,4.25 L12,6.8 C11.71,6.86 10.86,7.02 9.67,7.49 C6.79,8.65 4.58,10.96 3.49,13.08 C3.18,13.7 2.68,14.87 2.49,16 C3.28,15.05 4.4,14.15 5.3,13.53 L5.3,13.53 Z\"/></svg>",
	      "foursquare": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.23,2 C15.96,2 16.4,2.41 16.5,2.86 C16.57,3.15 16.56,3.44 16.51,3.73 C16.46,4.04 14.86,11.72 14.75,12.03 C14.56,12.56 14.16,12.82 13.61,12.83 C13.03,12.84 11.09,12.51 10.69,13 C10.38,13.38 7.79,16.39 6.81,17.53 C6.61,17.76 6.4,17.96 6.08,17.99 C5.68,18.04 5.29,17.87 5.17,17.45 C5.12,17.28 5.1,17.09 5.1,16.91 C5.1,12.4 4.86,7.81 5.11,3.31 C5.17,2.5 5.81,2.12 6.53,2 L15.23,2 L15.23,2 Z M9.76,11.42 C9.94,11.19 10.17,11.1 10.45,11.1 L12.86,11.1 C13.12,11.1 13.31,10.94 13.36,10.69 C13.37,10.64 13.62,9.41 13.74,8.83 C13.81,8.52 13.53,8.28 13.27,8.28 C12.35,8.29 11.42,8.28 10.5,8.28 C9.84,8.28 9.83,7.69 9.82,7.21 C9.8,6.85 10.13,6.55 10.5,6.55 C11.59,6.56 12.67,6.55 13.76,6.55 C14.03,6.55 14.23,6.4 14.28,6.14 C14.34,5.87 14.67,4.29 14.67,4.29 C14.67,4.29 14.82,3.74 14.19,3.74 L7.34,3.74 C7,3.75 6.84,4.02 6.84,4.33 C6.84,7.58 6.85,14.95 6.85,14.99 C6.87,15 8.89,12.51 9.76,11.42 L9.76,11.42 Z\"/></svg>",
	      "future": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"19 2 18 2 18 6 14 6 14 7 19 7 19 2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M18,6.548 C16.709,3.29 13.354,1 9.6,1 C4.6,1 0.6,5 0.6,10 C0.6,15 4.6,19 9.6,19 C14.6,19 18.6,15 18.6,10\"/><rect x=\"9\" y=\"4\" width=\"1\" height=\"7\"/><path d=\"M13.018,14.197 L9.445,10.625\" fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\"/></svg>",
	      "git-branch": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"7\" cy=\"3\" r=\"2\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"14\" cy=\"6\" r=\"2\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"7\" cy=\"17\" r=\"2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"2\" d=\"M14,8 C14,10.41 12.43,10.87 10.56,11.25 C9.09,11.54 7,12.06 7,15 L7,5\"/></svg>",
	      "git-fork": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"5.79\" cy=\"2.79\" r=\"1.79\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"14.19\" cy=\"2.79\" r=\"1.79\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"10.03\" cy=\"16.79\" r=\"1.79\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"2\" d=\"M5.79,4.57 L5.79,6.56 C5.79,9.19 10.03,10.22 10.03,13.31 C10.03,14.86 10.04,14.55 10.04,14.55 C10.04,14.37 10.04,14.86 10.04,13.31 C10.04,10.22 14.2,9.19 14.2,6.56 L14.2,4.57\"/></svg>",
	      "github-alt": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,0.5 C4.75,0.5 0.5,4.76 0.5,10.01 C0.5,15.26 4.75,19.51 10,19.51 C15.24,19.51 19.5,15.26 19.5,10.01 C19.5,4.76 15.25,0.5 10,0.5 L10,0.5 Z M12.81,17.69 C12.81,17.69 12.81,17.7 12.79,17.69 C12.47,17.75 12.35,17.59 12.35,17.36 L12.35,16.17 C12.35,15.45 12.09,14.92 11.58,14.56 C12.2,14.51 12.77,14.39 13.26,14.21 C13.87,13.98 14.36,13.69 14.74,13.29 C15.42,12.59 15.76,11.55 15.76,10.17 C15.76,9.25 15.45,8.46 14.83,7.8 C15.1,7.08 15.07,6.29 14.75,5.44 L14.51,5.42 C14.34,5.4 14.06,5.46 13.67,5.61 C13.25,5.78 12.79,6.03 12.31,6.35 C11.55,6.16 10.81,6.05 10.09,6.05 C9.36,6.05 8.61,6.15 7.88,6.35 C7.28,5.96 6.75,5.68 6.26,5.54 C6.07,5.47 5.9,5.44 5.78,5.44 L5.42,5.44 C5.06,6.29 5.04,7.08 5.32,7.8 C4.7,8.46 4.4,9.25 4.4,10.17 C4.4,11.94 4.96,13.16 6.08,13.84 C6.53,14.13 7.05,14.32 7.69,14.43 C8.03,14.5 8.32,14.54 8.55,14.55 C8.07,14.89 7.82,15.42 7.82,16.16 L7.82,17.51 C7.8,17.69 7.7,17.8 7.51,17.8 C4.21,16.74 1.82,13.65 1.82,10.01 C1.82,5.5 5.49,1.83 10,1.83 C14.5,1.83 18.17,5.5 18.17,10.01 C18.18,13.53 15.94,16.54 12.81,17.69 L12.81,17.69 Z\"/></svg>",
	      "github": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,1 C5.03,1 1,5.03 1,10 C1,13.98 3.58,17.35 7.16,18.54 C7.61,18.62 7.77,18.34 7.77,18.11 C7.77,17.9 7.76,17.33 7.76,16.58 C5.26,17.12 4.73,15.37 4.73,15.37 C4.32,14.33 3.73,14.05 3.73,14.05 C2.91,13.5 3.79,13.5 3.79,13.5 C4.69,13.56 5.17,14.43 5.17,14.43 C5.97,15.8 7.28,15.41 7.79,15.18 C7.87,14.6 8.1,14.2 8.36,13.98 C6.36,13.75 4.26,12.98 4.26,9.53 C4.26,8.55 4.61,7.74 5.19,7.11 C5.1,6.88 4.79,5.97 5.28,4.73 C5.28,4.73 6.04,4.49 7.75,5.65 C8.47,5.45 9.24,5.35 10,5.35 C10.76,5.35 11.53,5.45 12.25,5.65 C13.97,4.48 14.72,4.73 14.72,4.73 C15.21,5.97 14.9,6.88 14.81,7.11 C15.39,7.74 15.73,8.54 15.73,9.53 C15.73,12.99 13.63,13.75 11.62,13.97 C11.94,14.25 12.23,14.8 12.23,15.64 C12.23,16.84 12.22,17.81 12.22,18.11 C12.22,18.35 12.38,18.63 12.84,18.54 C16.42,17.35 19,13.98 19,10 C19,5.03 14.97,1 10,1 L10,1 Z\"/></svg>",
	      "gitter": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"3.5\" y=\"1\" width=\"1.531\" height=\"11.471\"/><rect x=\"7.324\" y=\"4.059\" width=\"1.529\" height=\"15.294\"/><rect x=\"11.148\" y=\"4.059\" width=\"1.527\" height=\"15.294\"/><rect x=\"14.971\" y=\"4.059\" width=\"1.529\" height=\"8.412\"/></svg>",
	      "google-plus": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.9,9c0,2.7-0.6,5-3.2,6.3c-3.7,1.8-8.1,0.2-9.4-3.6C-1.1,7.6,1.9,3.3,6.1,3c1.7-0.1,3.2,0.3,4.6,1.3 c0.1,0.1,0.3,0.2,0.4,0.4c-0.5,0.5-1.2,1-1.7,1.6c-1-0.8-2.1-1.1-3.5-0.9C5,5.6,4.2,6,3.6,6.7c-1.3,1.3-1.5,3.4-0.5,5 c1,1.7,2.6,2.3,4.6,1.9c1.4-0.3,2.4-1.2,2.6-2.6H6.9V9H12.9z\"/><polygon points=\"20,9 20,11 18,11 18,13 16,13 16,11 14,11 14,9 16,9 16,7 18,7 18,9\"/></svg>",
	      "google": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.86,9.09 C18.46,12.12 17.14,16.05 13.81,17.56 C9.45,19.53 4.13,17.68 2.47,12.87 C0.68,7.68 4.22,2.42 9.5,2.03 C11.57,1.88 13.42,2.37 15.05,3.65 C15.22,3.78 15.37,3.93 15.61,4.14 C14.9,4.81 14.23,5.45 13.5,6.14 C12.27,5.08 10.84,4.72 9.28,4.98 C8.12,5.17 7.16,5.76 6.37,6.63 C4.88,8.27 4.62,10.86 5.76,12.82 C6.95,14.87 9.17,15.8 11.57,15.25 C13.27,14.87 14.76,13.33 14.89,11.75 L10.51,11.75 L10.51,9.09 L17.86,9.09 L17.86,9.09 Z\"/></svg>",
	      "grid": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"2\" y=\"2\" width=\"3\" height=\"3\"/><rect x=\"8\" y=\"2\" width=\"3\" height=\"3\"/><rect x=\"14\" y=\"2\" width=\"3\" height=\"3\"/><rect x=\"2\" y=\"8\" width=\"3\" height=\"3\"/><rect x=\"8\" y=\"8\" width=\"3\" height=\"3\"/><rect x=\"14\" y=\"8\" width=\"3\" height=\"3\"/><rect x=\"2\" y=\"14\" width=\"3\" height=\"3\"/><rect x=\"8\" y=\"14\" width=\"3\" height=\"3\"/><rect x=\"14\" y=\"14\" width=\"3\" height=\"3\"/></svg>",
	      "happy": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"13\" cy=\"7\" r=\"1\"/><circle cx=\"7\" cy=\"7\" r=\"1\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"10\" r=\"8.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M14.6,11.4 C13.9,13.3 12.1,14.5 10,14.5 C7.9,14.5 6.1,13.3 5.4,11.4\"/></svg>",
	      "hashtag": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.431,8 L15.661,7 L12.911,7 L13.831,3 L12.901,3 L11.98,7 L9.29,7 L10.21,3 L9.281,3 L8.361,7 L5.23,7 L5,8 L8.13,8 L7.21,12 L4.23,12 L4,13 L6.98,13 L6.061,17 L6.991,17 L7.911,13 L10.601,13 L9.681,17 L10.611,17 L11.531,13 L14.431,13 L14.661,12 L11.76,12 L12.681,8 L15.431,8 Z M10.831,12 L8.141,12 L9.061,8 L11.75,8 L10.831,12 Z\"/></svg>",
	      "heart": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" d=\"M10,4 C10,4 8.1,2 5.74,2 C3.38,2 1,3.55 1,6.73 C1,8.84 2.67,10.44 2.67,10.44 L10,18 L17.33,10.44 C17.33,10.44 19,8.84 19,6.73 C19,3.55 16.62,2 14.26,2 C11.9,2 10,4 10,4 L10,4 Z\"/></svg>",
	      "history": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"#000\" points=\"1 2 2 2 2 6 6 6 6 7 1 7 1 2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M2.1,6.548 C3.391,3.29 6.746,1 10.5,1 C15.5,1 19.5,5 19.5,10 C19.5,15 15.5,19 10.5,19 C5.5,19 1.5,15 1.5,10\"/><rect x=\"9\" y=\"4\" width=\"1\" height=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M13.018,14.197 L9.445,10.625\"/></svg>",
	      "home": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"18.65 11.35 10 2.71 1.35 11.35 0.65 10.65 10 1.29 19.35 10.65\"/><polygon points=\"15 4 18 4 18 7 17 7 17 5 15 5\"/><polygon points=\"3 11 4 11 4 18 7 18 7 12 12 12 12 18 16 18 16 11 17 11 17 19 11 19 11 13 8 13 8 19 3 19\"/></svg>",
	      "image": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"16.1\" cy=\"6.1\" r=\"1.1\"/><rect fill=\"none\" stroke=\"#000\" x=\".5\" y=\"2.5\" width=\"19\" height=\"15\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"4,13 8,9 13,14\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"11,12 12.5,10.5 16,14\"/></svg>",
	      "info": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.13,11.59 C11.97,12.84 10.35,14.12 9.1,14.16 C6.17,14.2 9.89,9.46 8.74,8.37 C9.3,8.16 10.62,7.83 10.62,8.81 C10.62,9.63 10.12,10.55 9.88,11.32 C8.66,15.16 12.13,11.15 12.14,11.18 C12.16,11.21 12.16,11.35 12.13,11.59 C12.08,11.95 12.16,11.35 12.13,11.59 L12.13,11.59 Z M11.56,5.67 C11.56,6.67 9.36,7.15 9.36,6.03 C9.36,5 11.56,4.54 11.56,5.67 L11.56,5.67 Z\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/></svg>",
	      "instagram": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M13.55,1H6.46C3.45,1,1,3.44,1,6.44v7.12c0,3,2.45,5.44,5.46,5.44h7.08c3.02,0,5.46-2.44,5.46-5.44V6.44 C19.01,3.44,16.56,1,13.55,1z M17.5,14c0,1.93-1.57,3.5-3.5,3.5H6c-1.93,0-3.5-1.57-3.5-3.5V6c0-1.93,1.57-3.5,3.5-3.5h8 c1.93,0,3.5,1.57,3.5,3.5V14z\"/><circle cx=\"14.87\" cy=\"5.26\" r=\"1.09\"/><path d=\"M10.03,5.45c-2.55,0-4.63,2.06-4.63,4.6c0,2.55,2.07,4.61,4.63,4.61c2.56,0,4.63-2.061,4.63-4.61 C14.65,7.51,12.58,5.45,10.03,5.45L10.03,5.45L10.03,5.45z M10.08,13c-1.66,0-3-1.34-3-2.99c0-1.65,1.34-2.99,3-2.99s3,1.34,3,2.99 C13.08,11.66,11.74,13,10.08,13L10.08,13L10.08,13z\"/></svg>",
	      "italic": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.63,5.48 L10.15,14.52 C10,15.08 10.37,15.25 11.92,15.3 L11.72,16 L6,16 L6.2,15.31 C7.78,15.26 8.19,15.09 8.34,14.53 L10.82,5.49 C10.97,4.92 10.63,4.76 9.09,4.71 L9.28,4 L15,4 L14.81,4.69 C13.23,4.75 12.78,4.91 12.63,5.48 L12.63,5.48 Z\"/></svg>",
	      "joomla": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M7.8,13.4l1.7-1.7L5.9,8c-0.6-0.5-0.6-1.5,0-2c0.6-0.6,1.4-0.6,2,0l1.7-1.7c-1-1-2.3-1.3-3.6-1C5.8,2.2,4.8,1.4,3.7,1.4 c-1.3,0-2.3,1-2.3,2.3c0,1.1,0.8,2,1.8,2.3c-0.4,1.3-0.1,2.8,1,3.8L7.8,13.4L7.8,13.4z\"/><path d=\"M10.2,4.3c1-1,2.5-1.4,3.8-1c0.2-1.1,1.1-2,2.3-2c1.3,0,2.3,1,2.3,2.3c0,1.2-0.9,2.2-2,2.3c0.4,1.3,0,2.8-1,3.8L13.9,8 c0.6-0.5,0.6-1.5,0-2c-0.5-0.6-1.5-0.6-2,0L8.2,9.7L6.5,8\"/><path d=\"M14.1,16.8c-1.3,0.4-2.8,0.1-3.8-1l1.7-1.7c0.6,0.6,1.5,0.6,2,0c0.5-0.6,0.6-1.5,0-2l-3.7-3.7L12,6.7l3.7,3.7 c1,1,1.3,2.4,1,3.6c1.1,0.2,2,1.1,2,2.3c0,1.3-1,2.3-2.3,2.3C15.2,18.6,14.3,17.8,14.1,16.8\"/><path d=\"M13.2,12.2l-3.7,3.7c-1,1-2.4,1.3-3.6,1c-0.2,1-1.2,1.8-2.2,1.8c-1.3,0-2.3-1-2.3-2.3c0-1.1,0.8-2,1.8-2.3 c-0.3-1.3,0-2.7,1-3.7l1.7,1.7c-0.6,0.6-0.6,1.5,0,2c0.6,0.6,1.4,0.6,2,0l3.7-3.7\"/></svg>",
	      "laptop": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect y=\"16\" width=\"20\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"2.5\" y=\"4.5\" width=\"15\" height=\"10\"/></svg>",
	      "lifesaver": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,0.5 C4.76,0.5 0.5,4.76 0.5,10 C0.5,15.24 4.76,19.5 10,19.5 C15.24,19.5 19.5,15.24 19.5,10 C19.5,4.76 15.24,0.5 10,0.5 L10,0.5 Z M10,1.5 C11.49,1.5 12.89,1.88 14.11,2.56 L11.85,4.82 C11.27,4.61 10.65,4.5 10,4.5 C9.21,4.5 8.47,4.67 7.79,4.96 L5.58,2.75 C6.87,1.95 8.38,1.5 10,1.5 L10,1.5 Z M4.96,7.8 C4.67,8.48 4.5,9.21 4.5,10 C4.5,10.65 4.61,11.27 4.83,11.85 L2.56,14.11 C1.88,12.89 1.5,11.49 1.5,10 C1.5,8.38 1.95,6.87 2.75,5.58 L4.96,7.79 L4.96,7.8 L4.96,7.8 Z M10,18.5 C8.25,18.5 6.62,17.97 5.27,17.06 L7.46,14.87 C8.22,15.27 9.08,15.5 10,15.5 C10.79,15.5 11.53,15.33 12.21,15.04 L14.42,17.25 C13.13,18.05 11.62,18.5 10,18.5 L10,18.5 Z M10,14.5 C7.52,14.5 5.5,12.48 5.5,10 C5.5,7.52 7.52,5.5 10,5.5 C12.48,5.5 14.5,7.52 14.5,10 C14.5,12.48 12.48,14.5 10,14.5 L10,14.5 Z M15.04,12.21 C15.33,11.53 15.5,10.79 15.5,10 C15.5,9.08 15.27,8.22 14.87,7.46 L17.06,5.27 C17.97,6.62 18.5,8.25 18.5,10 C18.5,11.62 18.05,13.13 17.25,14.42 L15.04,12.21 L15.04,12.21 Z\"/></svg>",
	      "link": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M10.625,12.375 L7.525,15.475 C6.825,16.175 5.925,16.175 5.225,15.475 L4.525,14.775 C3.825,14.074 3.825,13.175 4.525,12.475 L7.625,9.375\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M9.325,7.375 L12.425,4.275 C13.125,3.575 14.025,3.575 14.724,4.275 L15.425,4.975 C16.125,5.675 16.125,6.575 15.425,7.275 L12.325,10.375\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M7.925,11.875 L11.925,7.975\"/></svg>",
	      "linkedin": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5.77,17.89 L5.77,7.17 L2.21,7.17 L2.21,17.89 L5.77,17.89 L5.77,17.89 Z M3.99,5.71 C5.23,5.71 6.01,4.89 6.01,3.86 C5.99,2.8 5.24,2 4.02,2 C2.8,2 2,2.8 2,3.85 C2,4.88 2.77,5.7 3.97,5.7 L3.99,5.7 L3.99,5.71 L3.99,5.71 Z\"/><path d=\"M7.75,17.89 L11.31,17.89 L11.31,11.9 C11.31,11.58 11.33,11.26 11.43,11.03 C11.69,10.39 12.27,9.73 13.26,9.73 C14.55,9.73 15.06,10.71 15.06,12.15 L15.06,17.89 L18.62,17.89 L18.62,11.74 C18.62,8.45 16.86,6.92 14.52,6.92 C12.6,6.92 11.75,7.99 11.28,8.73 L11.3,8.73 L11.3,7.17 L7.75,7.17 C7.79,8.17 7.75,17.89 7.75,17.89 L7.75,17.89 L7.75,17.89 Z\"/></svg>",
	      "list": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"6\" y=\"4\" width=\"12\" height=\"1\"/><rect x=\"6\" y=\"9\" width=\"12\" height=\"1\"/><rect x=\"6\" y=\"14\" width=\"12\" height=\"1\"/><rect x=\"2\" y=\"4\" width=\"2\" height=\"1\"/><rect x=\"2\" y=\"9\" width=\"2\" height=\"1\"/><rect x=\"2\" y=\"14\" width=\"2\" height=\"1\"/></svg>",
	      "location": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" d=\"M10,0.5 C6.41,0.5 3.5,3.39 3.5,6.98 C3.5,11.83 10,19 10,19 C10,19 16.5,11.83 16.5,6.98 C16.5,3.39 13.59,0.5 10,0.5 L10,0.5 Z\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"6.8\" r=\"2.3\"/></svg>",
	      "lock": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" height=\"10\" width=\"13\" y=\"8.5\" x=\"3.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M6.5,8 L6.5,4.88 C6.5,3.01 8.07,1.5 10,1.5 C11.93,1.5 13.5,3.01 13.5,4.88 L13.5,8\"/></svg>",
	      "mail": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"1.4,6.5 10,11 18.6,6.5\"/><path d=\"M 1,4 1,16 19,16 19,4 1,4 Z M 18,15 2,15 2,5 18,5 18,15 Z\"/></svg>",
	      "menu": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"2\" y=\"4\" width=\"16\" height=\"1\"/><rect x=\"2\" y=\"9\" width=\"16\" height=\"1\"/><rect x=\"2\" y=\"14\" width=\"16\" height=\"1\"/></svg>",
	      "microphone": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" x1=\"10\" x2=\"10\" y1=\"16.44\" y2=\"18.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"7\" x2=\"13\" y1=\"18.5\" y2=\"18.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M13.5 4.89v5.87a3.5 3.5 0 0 1-7 0V4.89a3.5 3.5 0 0 1 7 0z\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M15.5 10.36V11a5.5 5.5 0 0 1-11 0v-.6\"/></svg>",
	      "minus-circle": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9.5\" cy=\"9.5\" r=\"9\"/><line fill=\"none\" stroke=\"#000\" x1=\"5\" y1=\"9.5\" x2=\"14\" y2=\"9.5\"/></svg>",
	      "minus": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect height=\"1\" width=\"18\" y=\"9\" x=\"1\"/></svg>",
	      "more-vertical": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"10\" cy=\"3\" r=\"2\"/><circle cx=\"10\" cy=\"10\" r=\"2\"/><circle cx=\"10\" cy=\"17\" r=\"2\"/></svg>",
	      "more": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"3\" cy=\"10\" r=\"2\"/><circle cx=\"10\" cy=\"10\" r=\"2\"/><circle cx=\"17\" cy=\"10\" r=\"2\"/></svg>",
	      "move": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"4,5 1,5 1,9 2,9 2,6 4,6\"/><polygon points=\"1,16 2,16 2,18 4,18 4,19 1,19\"/><polygon points=\"14,16 14,19 11,19 11,18 13,18 13,16\"/><rect fill=\"none\" stroke=\"#000\" x=\"5.5\" y=\"1.5\" width=\"13\" height=\"13\"/><rect x=\"1\" y=\"11\" width=\"1\" height=\"3\"/><rect x=\"6\" y=\"18\" width=\"3\" height=\"1\"/></svg>",
	      "nut": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"2.5,5.7 10,1.3 17.5,5.7 17.5,14.3 10,18.7 2.5,14.3\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"10\" r=\"3.5\"/></svg>",
	      "pagekit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"3,1 17,1 17,16 10,16 10,13 14,13 14,4 6,4 6,16 10,16 10,19 3,19\"/></svg>",
	      "paint-bucket": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.21,1 L0,11.21 L8.1,19.31 L18.31,9.1 L10.21,1 L10.21,1 Z M16.89,9.1 L15,11 L1.7,11 L10.21,2.42 L16.89,9.1 Z\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M6.42,2.33 L11.7,7.61\"/><path d=\"M18.49,12 C18.49,12 20,14.06 20,15.36 C20,16.28 19.24,17 18.49,17 L18.49,17 C17.74,17 17,16.28 17,15.36 C17,14.06 18.49,12 18.49,12 L18.49,12 Z\"/></svg>",
	      "pencil": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M17.25,6.01 L7.12,16.1 L3.82,17.2 L5.02,13.9 L15.12,3.88 C15.71,3.29 16.66,3.29 17.25,3.88 C17.83,4.47 17.83,5.42 17.25,6.01 L17.25,6.01 Z\"/><path fill=\"none\" stroke=\"#000\" d=\"M15.98,7.268 L13.851,5.148\"/></svg>",
	      "phone-landscape": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M17,5.5 C17.8,5.5 18.5,6.2 18.5,7 L18.5,14 C18.5,14.8 17.8,15.5 17,15.5 L3,15.5 C2.2,15.5 1.5,14.8 1.5,14 L1.5,7 C1.5,6.2 2.2,5.5 3,5.5 L17,5.5 L17,5.5 L17,5.5 Z\"/><circle cx=\"3.8\" cy=\"10.5\" r=\".8\"/></svg>",
	      "phone": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M15.5,17 C15.5,17.8 14.8,18.5 14,18.5 L7,18.5 C6.2,18.5 5.5,17.8 5.5,17 L5.5,3 C5.5,2.2 6.2,1.5 7,1.5 L14,1.5 C14.8,1.5 15.5,2.2 15.5,3 L15.5,17 L15.5,17 L15.5,17 Z\"/><circle cx=\"10.5\" cy=\"16.5\" r=\".8\"/></svg>",
	      "pinterest": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.21,1 C5.5,1 3,4.16 3,7.61 C3,9.21 3.85,11.2 5.22,11.84 C5.43,11.94 5.54,11.89 5.58,11.69 C5.62,11.54 5.8,10.8 5.88,10.45 C5.91,10.34 5.89,10.24 5.8,10.14 C5.36,9.59 5,8.58 5,7.65 C5,5.24 6.82,2.91 9.93,2.91 C12.61,2.91 14.49,4.74 14.49,7.35 C14.49,10.3 13,12.35 11.06,12.35 C9.99,12.35 9.19,11.47 9.44,10.38 C9.75,9.08 10.35,7.68 10.35,6.75 C10.35,5.91 9.9,5.21 8.97,5.21 C7.87,5.21 6.99,6.34 6.99,7.86 C6.99,8.83 7.32,9.48 7.32,9.48 C7.32,9.48 6.24,14.06 6.04,14.91 C5.7,16.35 6.08,18.7 6.12,18.9 C6.14,19.01 6.26,19.05 6.33,18.95 C6.44,18.81 7.74,16.85 8.11,15.44 C8.24,14.93 8.79,12.84 8.79,12.84 C9.15,13.52 10.19,14.09 11.29,14.09 C14.58,14.09 16.96,11.06 16.96,7.3 C16.94,3.7 14,1 10.21,1\"/></svg>",
	      "play-circle": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"8.5 7 13.5 10 8.5 13\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/></svg>",
	      "play": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"6.5,5 14.5,10 6.5,15\"/></svg>",
	      "plus-circle": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9.5\" cy=\"9.5\" r=\"9\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"5\" x2=\"9.5\" y2=\"14\"/><line fill=\"none\" stroke=\"#000\" x1=\"5\" y1=\"9.5\" x2=\"14\" y2=\"9.5\"/></svg>",
	      "plus": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"9\" y=\"1\" width=\"1\" height=\"17\"/><rect x=\"1\" y=\"9\" width=\"17\" height=\"1\"/></svg>",
	      "print": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"4.5 13.5 1.5 13.5 1.5 6.5 18.5 6.5 18.5 13.5 15.5 13.5\"/><polyline fill=\"none\" stroke=\"#000\" points=\"15.5 6.5 15.5 2.5 4.5 2.5 4.5 6.5\"/><rect fill=\"none\" stroke=\"#000\" width=\"11\" height=\"6\" x=\"4.5\" y=\"11.5\"/><rect width=\"8\" height=\"1\" x=\"6\" y=\"13\"/><rect width=\"8\" height=\"1\" x=\"6\" y=\"15\"/></svg>",
	      "pull": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"6.85,8 9.5,10.6 12.15,8 12.85,8.7 9.5,12 6.15,8.7\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"11\" x2=\"9.5\" y2=\"2\"/><polyline fill=\"none\" stroke=\"#000\" points=\"6,5.5 3.5,5.5 3.5,18.5 15.5,18.5 15.5,5.5 13,5.5\"/></svg>",
	      "push": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"12.15,4 9.5,1.4 6.85,4 6.15,3.3 9.5,0 12.85,3.3\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"10\" x2=\"9.5\" y2=\"1\"/><polyline fill=\"none\" stroke=\"#000\" points=\"6 5.5 3.5 5.5 3.5 18.5 15.5 18.5 15.5 5.5 13 5.5\"/></svg>",
	      "question": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><circle cx=\"10.44\" cy=\"14.42\" r=\"1.05\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" d=\"M8.17,7.79 C8.17,4.75 12.72,4.73 12.72,7.72 C12.72,8.67 11.81,9.15 11.23,9.75 C10.75,10.24 10.51,10.73 10.45,11.4 C10.44,11.53 10.43,11.64 10.43,11.75\"/></svg>",
	      "quote-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.27,7.79 C17.27,9.45 16.97,10.43 15.99,12.02 C14.98,13.64 13,15.23 11.56,15.97 L11.1,15.08 C12.34,14.2 13.14,13.51 14.02,11.82 C14.27,11.34 14.41,10.92 14.49,10.54 C14.3,10.58 14.09,10.6 13.88,10.6 C12.06,10.6 10.59,9.12 10.59,7.3 C10.59,5.48 12.06,4 13.88,4 C15.39,4 16.67,5.02 17.05,6.42 C17.19,6.82 17.27,7.27 17.27,7.79 L17.27,7.79 Z\"/><path d=\"M8.68,7.79 C8.68,9.45 8.38,10.43 7.4,12.02 C6.39,13.64 4.41,15.23 2.97,15.97 L2.51,15.08 C3.75,14.2 4.55,13.51 5.43,11.82 C5.68,11.34 5.82,10.92 5.9,10.54 C5.71,10.58 5.5,10.6 5.29,10.6 C3.47,10.6 2,9.12 2,7.3 C2,5.48 3.47,4 5.29,4 C6.8,4 8.08,5.02 8.46,6.42 C8.6,6.82 8.68,7.27 8.68,7.79 L8.68,7.79 Z\"/></svg>",
	      "receiver": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" d=\"M6.189,13.611C8.134,15.525 11.097,18.239 13.867,18.257C16.47,18.275 18.2,16.241 18.2,16.241L14.509,12.551L11.539,13.639L6.189,8.29L7.313,5.355L3.76,1.8C3.76,1.8 1.732,3.537 1.7,6.092C1.667,8.809 4.347,11.738 6.189,13.611\"/></svg>",
	      "reddit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19 9.05a2.56 2.56 0 0 0-2.56-2.56 2.59 2.59 0 0 0-1.88.82 10.63 10.63 0 0 0-4.14-1v-.08c.58-1.62 1.58-3.89 2.7-4.1.38-.08.77.12 1.19.57a1.15 1.15 0 0 0-.06.37 1.48 1.48 0 1 0 1.51-1.45 1.43 1.43 0 0 0-.76.19A2.29 2.29 0 0 0 12.91 1c-2.11.43-3.39 4.38-3.63 5.19 0 0 0 .11-.06.11a10.65 10.65 0 0 0-3.75 1A2.56 2.56 0 0 0 1 9.05a2.42 2.42 0 0 0 .72 1.76A5.18 5.18 0 0 0 1.24 13c0 3.66 3.92 6.64 8.73 6.64s8.74-3 8.74-6.64a5.23 5.23 0 0 0-.46-2.13A2.58 2.58 0 0 0 19 9.05zm-16.88 0a1.44 1.44 0 0 1 2.27-1.19 7.68 7.68 0 0 0-2.07 1.91 1.33 1.33 0 0 1-.2-.72zM10 18.4c-4.17 0-7.55-2.4-7.55-5.4S5.83 7.53 10 7.53 17.5 10 17.5 13s-3.38 5.4-7.5 5.4zm7.69-8.61a7.62 7.62 0 0 0-2.09-1.91 1.41 1.41 0 0 1 .84-.28 1.47 1.47 0 0 1 1.44 1.45 1.34 1.34 0 0 1-.21.72z\"/><path d=\"M6.69 12.58a1.39 1.39 0 1 1 1.39-1.39 1.38 1.38 0 0 1-1.38 1.39z\"/><path d=\"M14.26 11.2a1.39 1.39 0 1 1-1.39-1.39 1.39 1.39 0 0 1 1.39 1.39z\"/><path d=\"M13.09 14.88a.54.54 0 0 1-.09.77 5.3 5.3 0 0 1-3.26 1.19 5.61 5.61 0 0 1-3.4-1.22.55.55 0 1 1 .73-.83 4.09 4.09 0 0 0 5.25 0 .56.56 0 0 1 .77.09z\"/></svg>",
	      "refresh": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M17.08,11.15 C17.09,11.31 17.1,11.47 17.1,11.64 C17.1,15.53 13.94,18.69 10.05,18.69 C6.16,18.68 3,15.53 3,11.63 C3,7.74 6.16,4.58 10.05,4.58 C10.9,4.58 11.71,4.73 12.46,5\"/><polyline fill=\"none\" stroke=\"#000\" points=\"9.9 2 12.79 4.89 9.79 7.9\"/></svg>",
	      "reply": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.7,13.11 C16.12,10.02 13.84,7.85 11.02,6.61 C10.57,6.41 9.75,6.13 9,5.91 L9,2 L1,9 L9,16 L9,12.13 C10.78,12.47 12.5,13.19 14.09,14.25 C17.13,16.28 18.56,18.54 18.56,18.54 C18.56,18.54 18.81,15.28 17.7,13.11 L17.7,13.11 Z M14.82,13.53 C13.17,12.4 11.01,11.4 8,10.92 L8,13.63 L2.55,9 L8,4.25 L8,6.8 C8.3,6.86 9.16,7.02 10.37,7.49 C13.3,8.65 15.54,10.96 16.65,13.08 C16.97,13.7 17.48,14.86 17.68,16 C16.87,15.05 15.73,14.15 14.82,13.53 L14.82,13.53 Z\"/></svg>",
	      "rss": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"3.12\" cy=\"16.8\" r=\"1.85\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1.5,8.2 C1.78,8.18 2.06,8.16 2.35,8.16 C7.57,8.16 11.81,12.37 11.81,17.57 C11.81,17.89 11.79,18.19 11.76,18.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1.5,2.52 C1.78,2.51 2.06,2.5 2.35,2.5 C10.72,2.5 17.5,9.24 17.5,17.57 C17.5,17.89 17.49,18.19 17.47,18.5\"/></svg>",
	      "search": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9\" cy=\"9\" r=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M14,14 L18,18 L14,14 Z\"/></svg>",
	      "server": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"3\" y=\"3\" width=\"1\" height=\"2\"/><rect x=\"5\" y=\"3\" width=\"1\" height=\"2\"/><rect x=\"7\" y=\"3\" width=\"1\" height=\"2\"/><rect x=\"16\" y=\"3\" width=\"1\" height=\"1\"/><rect x=\"16\" y=\"10\" width=\"1\" height=\"1\"/><circle fill=\"none\" stroke=\"#000\" cx=\"9.9\" cy=\"17.4\" r=\"1.4\"/><rect x=\"3\" y=\"10\" width=\"1\" height=\"2\"/><rect x=\"5\" y=\"10\" width=\"1\" height=\"2\"/><rect x=\"9.5\" y=\"14\" width=\"1\" height=\"2\"/><rect x=\"3\" y=\"17\" width=\"6\" height=\"1\"/><rect x=\"11\" y=\"17\" width=\"6\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"1.5\" width=\"17\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"8.5\" width=\"17\" height=\"5\"/></svg>",
	      "settings": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><ellipse fill=\"none\" stroke=\"#000\" cx=\"6.11\" cy=\"3.55\" rx=\"2.11\" ry=\"2.15\"/><ellipse fill=\"none\" stroke=\"#000\" cx=\"6.11\" cy=\"15.55\" rx=\"2.11\" ry=\"2.15\"/><circle fill=\"none\" stroke=\"#000\" cx=\"13.15\" cy=\"9.55\" r=\"2.15\"/><rect x=\"1\" y=\"3\" width=\"3\" height=\"1\"/><rect x=\"10\" y=\"3\" width=\"8\" height=\"1\"/><rect x=\"1\" y=\"9\" width=\"8\" height=\"1\"/><rect x=\"15\" y=\"9\" width=\"3\" height=\"1\"/><rect x=\"1\" y=\"15\" width=\"3\" height=\"1\"/><rect x=\"10\" y=\"15\" width=\"8\" height=\"1\"/></svg>",
	      "shrink": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"11 4 12 4 12 8 16 8 16 9 11 9\"/><polygon points=\"4 11 9 11 9 16 8 16 8 12 4 12\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M12,8 L18,2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M2,18 L8,12\"/></svg>",
	      "sign-in": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"7 2 17 2 17 17 7 17 7 16 16 16 16 3 7 3\"/><polygon points=\"9.1 13.4 8.5 12.8 11.28 10 4 10 4 9 11.28 9 8.5 6.2 9.1 5.62 13 9.5\"/></svg>",
	      "sign-out": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"13.1 13.4 12.5 12.8 15.28 10 8 10 8 9 15.28 9 12.5 6.2 13.1 5.62 17 9.5\"/><polygon points=\"13 2 3 2 3 17 13 17 13 16 4 16 4 3 13 3\"/></svg>",
	      "social": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13.4\" y1=\"14\" x2=\"6.3\" y2=\"10.7\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13.5\" y1=\"5.5\" x2=\"6.5\" y2=\"8.8\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"15.5\" cy=\"4.6\" r=\"2.3\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"15.5\" cy=\"14.8\" r=\"2.3\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"4.5\" cy=\"9.8\" r=\"2.3\"/></svg>",
	      "soundcloud": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.2,9.4c-0.4,0-0.8,0.1-1.101,0.2c-0.199-2.5-2.399-4.5-5-4.5c-0.6,0-1.2,0.1-1.7,0.3C9.2,5.5,9.1,5.6,9.1,5.6V15h8 c1.601,0,2.801-1.2,2.801-2.8C20,10.7,18.7,9.4,17.2,9.4L17.2,9.4z\"/><rect x=\"6\" y=\"6.5\" width=\"1.5\" height=\"8.5\"/><rect x=\"3\" y=\"8\" width=\"1.5\" height=\"7\"/><rect y=\"10\" width=\"1.5\" height=\"5\"/></svg>",
	      "star": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"10 2 12.63 7.27 18.5 8.12 14.25 12.22 15.25 18 10 15.27 4.75 18 5.75 12.22 1.5 8.12 7.37 7.27\"/></svg>",
	      "strikethrough": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6,13.02 L6.65,13.02 C7.64,15.16 8.86,16.12 10.41,16.12 C12.22,16.12 12.92,14.93 12.92,13.89 C12.92,12.55 11.99,12.03 9.74,11.23 C8.05,10.64 6.23,10.11 6.23,7.83 C6.23,5.5 8.09,4.09 10.4,4.09 C11.44,4.09 12.13,4.31 12.72,4.54 L13.33,4 L13.81,4 L13.81,7.59 L13.16,7.59 C12.55,5.88 11.52,4.89 10.07,4.89 C8.84,4.89 7.89,5.69 7.89,7.03 C7.89,8.29 8.89,8.78 10.88,9.45 C12.57,10.03 14.38,10.6 14.38,12.91 C14.38,14.75 13.27,16.93 10.18,16.93 C9.18,16.93 8.17,16.69 7.46,16.39 L6.52,17 L6,17 L6,13.02 L6,13.02 Z\"/><rect x=\"3\" y=\"10\" width=\"15\" height=\"1\"/></svg>",
	      "table": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"1\" y=\"3\" width=\"18\" height=\"1\"/><rect x=\"1\" y=\"7\" width=\"18\" height=\"1\"/><rect x=\"1\" y=\"11\" width=\"18\" height=\"1\"/><rect x=\"1\" y=\"15\" width=\"18\" height=\"1\"/></svg>",
	      "tablet-landscape": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M1.5,5 C1.5,4.2 2.2,3.5 3,3.5 L17,3.5 C17.8,3.5 18.5,4.2 18.5,5 L18.5,16 C18.5,16.8 17.8,17.5 17,17.5 L3,17.5 C2.2,17.5 1.5,16.8 1.5,16 L1.5,5 L1.5,5 L1.5,5 Z\"/><circle cx=\"3.7\" cy=\"10.5\" r=\".8\"/></svg>",
	      "tablet": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M5,18.5 C4.2,18.5 3.5,17.8 3.5,17 L3.5,3 C3.5,2.2 4.2,1.5 5,1.5 L16,1.5 C16.8,1.5 17.5,2.2 17.5,3 L17.5,17 C17.5,17.8 16.8,18.5 16,18.5 L5,18.5 L5,18.5 L5,18.5 Z\"/><circle cx=\"10.5\" cy=\"16.3\" r=\".8\"/></svg>",
	      "tag": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M17.5,3.71 L17.5,7.72 C17.5,7.96 17.4,8.2 17.21,8.39 L8.39,17.2 C7.99,17.6 7.33,17.6 6.93,17.2 L2.8,13.07 C2.4,12.67 2.4,12.01 2.8,11.61 L11.61,2.8 C11.81,2.6 12.08,2.5 12.34,2.5 L16.19,2.5 C16.52,2.5 16.86,2.63 17.11,2.88 C17.35,3.11 17.48,3.4 17.5,3.71 L17.5,3.71 Z\"/><circle cx=\"14\" cy=\"6\" r=\"1\"/></svg>",
	      "thumbnails": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"3.5\" width=\"5\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"11.5\" y=\"3.5\" width=\"5\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"11.5\" y=\"11.5\" width=\"5\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"11.5\" width=\"5\" height=\"5\"/></svg>",
	      "trash": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"6.5 3 6.5 1.5 13.5 1.5 13.5 3\"/><polyline fill=\"none\" stroke=\"#000\" points=\"4.5 4 4.5 18.5 15.5 18.5 15.5 4\"/><rect x=\"8\" y=\"7\" width=\"1\" height=\"9\"/><rect x=\"11\" y=\"7\" width=\"1\" height=\"9\"/><rect x=\"2\" y=\"3\" width=\"16\" height=\"1\"/></svg>",
	      "triangle-down": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"5 7 15 7 10 12\"/></svg>",
	      "triangle-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"12 5 7 10 12 15\"/></svg>",
	      "triangle-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"8 5 13 10 8 15\"/></svg>",
	      "triangle-up": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"5 13 10 8 15 13\"/></svg>",
	      "tripadvisor": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19.021,7.866C19.256,6.862,20,5.854,20,5.854h-3.346C14.781,4.641,12.504,4,9.98,4C7.363,4,4.999,4.651,3.135,5.876H0\tc0,0,0.738,0.987,0.976,1.988c-0.611,0.837-0.973,1.852-0.973,2.964c0,2.763,2.249,5.009,5.011,5.009\tc1.576,0,2.976-0.737,3.901-1.879l1.063,1.599l1.075-1.615c0.475,0.611,1.1,1.111,1.838,1.451c1.213,0.547,2.574,0.612,3.825,0.15\tc2.589-0.963,3.913-3.852,2.964-6.439c-0.175-0.463-0.4-0.876-0.675-1.238H19.021z M16.38,14.594\tc-1.002,0.371-2.088,0.328-3.06-0.119c-0.688-0.317-1.252-0.817-1.657-1.438c-0.164-0.25-0.313-0.52-0.417-0.811\tc-0.124-0.328-0.186-0.668-0.217-1.014c-0.063-0.689,0.037-1.396,0.339-2.043c0.448-0.971,1.251-1.71,2.25-2.079\tc2.075-0.765,4.375,0.3,5.14,2.366c0.762,2.066-0.301,4.37-2.363,5.134L16.38,14.594L16.38,14.594z M8.322,13.066\tc-0.72,1.059-1.935,1.76-3.309,1.76c-2.207,0-4.001-1.797-4.001-3.996c0-2.203,1.795-4.002,4.001-4.002\tc2.204,0,3.999,1.8,3.999,4.002c0,0.137-0.024,0.261-0.04,0.396c-0.067,0.678-0.284,1.313-0.648,1.853v-0.013H8.322z M2.472,10.775\tc0,1.367,1.112,2.479,2.476,2.479c1.363,0,2.472-1.11,2.472-2.479c0-1.359-1.11-2.468-2.472-2.468\tC3.584,8.306,2.473,9.416,2.472,10.775L2.472,10.775z M12.514,10.775c0,1.367,1.104,2.479,2.471,2.479\tc1.363,0,2.474-1.108,2.474-2.479c0-1.359-1.11-2.468-2.474-2.468c-1.364,0-2.477,1.109-2.477,2.468H12.514z M3.324,10.775\tc0-0.893,0.726-1.618,1.614-1.618c0.889,0,1.625,0.727,1.625,1.618c0,0.898-0.725,1.627-1.625,1.627\tc-0.901,0-1.625-0.729-1.625-1.627H3.324z M13.354,10.775c0-0.893,0.726-1.618,1.627-1.618c0.886,0,1.61,0.727,1.61,1.618\tc0,0.898-0.726,1.627-1.626,1.627s-1.625-0.729-1.625-1.627H13.354z M9.977,4.875c1.798,0,3.425,0.324,4.849,0.968\tc-0.535,0.015-1.061,0.108-1.586,0.3c-1.264,0.463-2.264,1.388-2.815,2.604c-0.262,0.551-0.398,1.133-0.448,1.72\tC9.79,7.905,7.677,5.873,5.076,5.82C6.501,5.208,8.153,4.875,9.94,4.875H9.977z\"/></svg>",
	      "tumblr": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6.885,8.598c0,0,0,3.393,0,4.996c0,0.282,0,0.66,0.094,0.942c0.377,1.509,1.131,2.545,2.545,3.11 c1.319,0.472,2.356,0.472,3.676,0c0.565-0.188,1.132-0.659,1.132-0.659l-0.849-2.263c0,0-1.036,0.378-1.603,0.283 c-0.565-0.094-1.226-0.66-1.226-1.508c0-1.603,0-4.902,0-4.902h2.828V5.771h-2.828V2H8.205c0,0-0.094,0.66-0.188,0.942 C7.828,3.791,7.262,4.733,6.603,5.394C5.848,6.147,5,6.43,5,6.43v2.168H6.885z\"/></svg>",
	      "tv": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"7\" y=\"16\" width=\"6\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\".5\" y=\"3.5\" width=\"19\" height=\"11\"/></svg>",
	      "twitter": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19,4.74 C18.339,5.029 17.626,5.229 16.881,5.32 C17.644,4.86 18.227,4.139 18.503,3.28 C17.79,3.7 17.001,4.009 16.159,4.17 C15.485,3.45 14.526,3 13.464,3 C11.423,3 9.771,4.66 9.771,6.7 C9.771,6.99 9.804,7.269 9.868,7.539 C6.795,7.38 4.076,5.919 2.254,3.679 C1.936,4.219 1.754,4.86 1.754,5.539 C1.754,6.82 2.405,7.95 3.397,8.61 C2.79,8.589 2.22,8.429 1.723,8.149 L1.723,8.189 C1.723,9.978 2.997,11.478 4.686,11.82 C4.376,11.899 4.049,11.939 3.713,11.939 C3.475,11.939 3.245,11.919 3.018,11.88 C3.49,13.349 4.852,14.419 6.469,14.449 C5.205,15.429 3.612,16.019 1.882,16.019 C1.583,16.019 1.29,16.009 1,15.969 C2.635,17.019 4.576,17.629 6.662,17.629 C13.454,17.629 17.17,12 17.17,7.129 C17.17,6.969 17.166,6.809 17.157,6.649 C17.879,6.129 18.504,5.478 19,4.74\"/></svg>",
	      "uikit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"14.4,3.1 11.3,5.1 15,7.3 15,12.9 10,15.7 5,12.9 5,8.5 2,6.8 2,14.8 9.9,19.5 18,14.8 18,5.3\"/><polygon points=\"9.8,4.2 6.7,2.4 9.8,0.4 12.9,2.3\"/></svg>",
	      "unlock": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"8.5\" width=\"13\" height=\"10\"/><path fill=\"none\" stroke=\"#000\" d=\"M6.5,8.5 L6.5,4.9 C6.5,3 8.1,1.5 10,1.5 C11.9,1.5 13.5,3 13.5,4.9\"/></svg>",
	      "upload": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"5 8 9.5 3.5 14 8\"/><rect x=\"3\" y=\"17\" width=\"13\" height=\"1\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"15\" x2=\"9.5\" y2=\"4\"/></svg>",
	      "user": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9.9\" cy=\"6.4\" r=\"4.4\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1.5,19 C2.3,14.5 5.8,11.2 10,11.2 C14.2,11.2 17.7,14.6 18.5,19.2\"/></svg>",
	      "users": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"7.7\" cy=\"8.6\" r=\"3.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1,18.1 C1.7,14.6 4.4,12.1 7.6,12.1 C10.9,12.1 13.7,14.8 14.3,18.3\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M11.4,4 C12.8,2.4 15.4,2.8 16.3,4.7 C17.2,6.6 15.7,8.9 13.6,8.9 C16.5,8.9 18.8,11.3 19.2,14.1\"/></svg>",
	      "video-camera": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"17.5 6.9 17.5 13.1 13.5 10.4 13.5 14.5 2.5 14.5 2.5 5.5 13.5 5.5 13.5 9.6 17.5 6.9\"/></svg>",
	      "vimeo": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2.065,7.59C1.84,7.367,1.654,7.082,1.468,6.838c-0.332-0.42-0.137-0.411,0.274-0.772c1.026-0.91,2.004-1.896,3.127-2.688 c1.017-0.713,2.365-1.173,3.286-0.039c0.849,1.045,0.869,2.629,1.084,3.891c0.215,1.309,0.421,2.648,0.88,3.901 c0.127,0.352,0.37,1.018,0.81,1.074c0.567,0.078,1.145-0.917,1.408-1.289c0.684-0.987,1.611-2.317,1.494-3.587 c-0.115-1.349-1.572-1.095-2.482-0.773c0.146-1.514,1.555-3.216,2.912-3.792c1.439-0.597,3.579-0.587,4.302,1.036 c0.772,1.759,0.078,3.802-0.763,5.396c-0.918,1.731-2.1,3.333-3.363,4.829c-1.114,1.329-2.432,2.787-4.093,3.422 c-1.897,0.723-3.021-0.686-3.667-2.318c-0.705-1.777-1.056-3.771-1.565-5.621C4.898,8.726,4.644,7.836,4.136,7.191 C3.473,6.358,2.72,7.141,2.065,7.59C1.977,7.502,2.115,7.551,2.065,7.59L2.065,7.59z\"/></svg>",
	      "warning": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"10\" cy=\"14\" r=\"1\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><path d=\"M10.97,7.72 C10.85,9.54 10.56,11.29 10.56,11.29 C10.51,11.87 10.27,12 9.99,12 C9.69,12 9.49,11.87 9.43,11.29 C9.43,11.29 9.16,9.54 9.03,7.72 C8.96,6.54 9.03,6 9.03,6 C9.03,5.45 9.46,5.02 9.99,5 C10.53,5.01 10.97,5.44 10.97,6 C10.97,6 11.04,6.54 10.97,7.72 L10.97,7.72 Z\"/></svg>",
	      "whatsapp": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M16.7,3.3c-1.8-1.8-4.1-2.8-6.7-2.8c-5.2,0-9.4,4.2-9.4,9.4c0,1.7,0.4,3.3,1.3,4.7l-1.3,4.9l5-1.3c1.4,0.8,2.9,1.2,4.5,1.2 l0,0l0,0c5.2,0,9.4-4.2,9.4-9.4C19.5,7.4,18.5,5,16.7,3.3 M10.1,17.7L10.1,17.7c-1.4,0-2.8-0.4-4-1.1l-0.3-0.2l-3,0.8l0.8-2.9 l-0.2-0.3c-0.8-1.2-1.2-2.7-1.2-4.2c0-4.3,3.5-7.8,7.8-7.8c2.1,0,4.1,0.8,5.5,2.3c1.5,1.5,2.3,3.4,2.3,5.5 C17.9,14.2,14.4,17.7,10.1,17.7 M14.4,11.9c-0.2-0.1-1.4-0.7-1.6-0.8c-0.2-0.1-0.4-0.1-0.5,0.1c-0.2,0.2-0.6,0.8-0.8,0.9 c-0.1,0.2-0.3,0.2-0.5,0.1c-0.2-0.1-1-0.4-1.9-1.2c-0.7-0.6-1.2-1.4-1.3-1.6c-0.1-0.2,0-0.4,0.1-0.5C8,8.8,8.1,8.7,8.2,8.5 c0.1-0.1,0.2-0.2,0.2-0.4c0.1-0.2,0-0.3,0-0.4C8.4,7.6,7.9,6.5,7.7,6C7.5,5.5,7.3,5.6,7.2,5.6c-0.1,0-0.3,0-0.4,0 c-0.2,0-0.4,0.1-0.6,0.3c-0.2,0.2-0.8,0.8-0.8,2c0,1.2,0.8,2.3,1,2.4c0.1,0.2,1.7,2.5,4,3.5c0.6,0.2,1,0.4,1.3,0.5 c0.6,0.2,1.1,0.2,1.5,0.1c0.5-0.1,1.4-0.6,1.6-1.1c0.2-0.5,0.2-1,0.1-1.1C14.8,12.1,14.6,12,14.4,11.9\"/></svg>",
	      "wordpress": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,0.5c-5.2,0-9.5,4.3-9.5,9.5s4.3,9.5,9.5,9.5c5.2,0,9.5-4.3,9.5-9.5S15.2,0.5,10,0.5L10,0.5L10,0.5z M15.6,3.9h-0.1 c-0.8,0-1.4,0.7-1.4,1.5c0,0.7,0.4,1.3,0.8,1.9c0.3,0.6,0.7,1.3,0.7,2.3c0,0.7-0.3,1.5-0.6,2.7L14.1,15l-3-8.9 c0.5,0,0.9-0.1,0.9-0.1C12.5,6,12.5,5.3,12,5.4c0,0-1.3,0.1-2.2,0.1C9,5.5,7.7,5.4,7.7,5.4C7.2,5.3,7.2,6,7.6,6c0,0,0.4,0.1,0.9,0.1 l1.3,3.5L8,15L5,6.1C5.5,6.1,5.9,6,5.9,6C6.4,6,6.3,5.3,5.9,5.4c0,0-1.3,0.1-2.2,0.1c-0.2,0-0.3,0-0.5,0c1.5-2.2,4-3.7,6.9-3.7 C12.2,1.7,14.1,2.6,15.6,3.9L15.6,3.9L15.6,3.9z M2.5,6.6l3.9,10.8c-2.7-1.3-4.6-4.2-4.6-7.4C1.8,8.8,2,7.6,2.5,6.6L2.5,6.6L2.5,6.6 z M10.2,10.7l2.5,6.9c0,0,0,0.1,0.1,0.1C11.9,18,11,18.2,10,18.2c-0.8,0-1.6-0.1-2.3-0.3L10.2,10.7L10.2,10.7L10.2,10.7z M14.2,17.1 l2.5-7.3c0.5-1.2,0.6-2.1,0.6-2.9c0-0.3,0-0.6-0.1-0.8c0.6,1.2,1,2.5,1,4C18.3,13,16.6,15.7,14.2,17.1L14.2,17.1L14.2,17.1z\"/></svg>",
	      "world": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M1,10.5 L19,10.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M2.35,15.5 L17.65,15.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M2.35,5.5 L17.523,5.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M10,19.46 L9.98,19.46 C7.31,17.33 5.61,14.141 5.61,10.58 C5.61,7.02 7.33,3.83 10,1.7 C10.01,1.7 9.99,1.7 10,1.7 L10,1.7 C12.67,3.83 14.4,7.02 14.4,10.58 C14.4,14.141 12.67,17.33 10,19.46 L10,19.46 L10,19.46 L10,19.46 Z\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"10.5\" r=\"9\"/></svg>",
	      "xing": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.4,4.56 C4.24,4.56 4.11,4.61 4.05,4.72 C3.98,4.83 3.99,4.97 4.07,5.12 L5.82,8.16 L5.82,8.17 L3.06,13.04 C2.99,13.18 2.99,13.33 3.06,13.44 C3.12,13.55 3.24,13.62 3.4,13.62 L6,13.62 C6.39,13.62 6.57,13.36 6.71,13.12 C6.71,13.12 9.41,8.35 9.51,8.16 C9.49,8.14 7.72,5.04 7.72,5.04 C7.58,4.81 7.39,4.56 6.99,4.56 L4.4,4.56 L4.4,4.56 Z\"/><path d=\"M15.3,1 C14.91,1 14.74,1.25 14.6,1.5 C14.6,1.5 9.01,11.42 8.82,11.74 C8.83,11.76 12.51,18.51 12.51,18.51 C12.64,18.74 12.84,19 13.23,19 L15.82,19 C15.98,19 16.1,18.94 16.16,18.83 C16.23,18.72 16.23,18.57 16.16,18.43 L12.5,11.74 L12.5,11.72 L18.25,1.56 C18.32,1.42 18.32,1.27 18.25,1.16 C18.21,1.06 18.08,1 17.93,1 L15.3,1 L15.3,1 Z\"/></svg>",
	      "yelp": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.175,14.971c-0.112,0.77-1.686,2.767-2.406,3.054c-0.246,0.1-0.487,0.076-0.675-0.069\tc-0.122-0.096-2.446-3.859-2.446-3.859c-0.194-0.293-0.157-0.682,0.083-0.978c0.234-0.284,0.581-0.393,0.881-0.276\tc0.016,0.01,4.21,1.394,4.332,1.482c0.178,0.148,0.263,0.379,0.225,0.646L17.175,14.971L17.175,14.971z M11.464,10.789\tc-0.203-0.307-0.199-0.666,0.009-0.916c0,0,2.625-3.574,2.745-3.657c0.203-0.135,0.452-0.141,0.69-0.025\tc0.691,0.335,2.085,2.405,2.167,3.199v0.027c0.024,0.271-0.082,0.491-0.273,0.623c-0.132,0.083-4.43,1.155-4.43,1.155\tc-0.322,0.096-0.68-0.06-0.882-0.381L11.464,10.789z M9.475,9.563C9.32,9.609,8.848,9.757,8.269,8.817c0,0-3.916-6.16-4.007-6.351\tc-0.057-0.212,0.011-0.455,0.202-0.65C5.047,1.211,8.21,0.327,9.037,0.529c0.27,0.069,0.457,0.238,0.522,0.479\tc0.047,0.266,0.433,5.982,0.488,7.264C10.098,9.368,9.629,9.517,9.475,9.563z M9.927,19.066c-0.083,0.225-0.273,0.373-0.54,0.421\tc-0.762,0.13-3.15-0.751-3.647-1.342c-0.096-0.131-0.155-0.262-0.167-0.394c-0.011-0.095,0-0.189,0.036-0.272\tc0.061-0.155,2.917-3.538,2.917-3.538c0.214-0.272,0.595-0.355,0.952-0.213c0.345,0.13,0.56,0.428,0.536,0.749\tC10.014,14.479,9.977,18.923,9.927,19.066z M3.495,13.912c-0.235-0.009-0.444-0.148-0.568-0.382c-0.089-0.17-0.151-0.453-0.19-0.794\tC2.63,11.701,2.761,10.144,3.07,9.648c0.145-0.226,0.357-0.345,0.592-0.336c0.154,0,4.255,1.667,4.255,1.667\tc0.321,0.118,0.521,0.453,0.5,0.833c-0.023,0.37-0.236,0.655-0.551,0.738L3.495,13.912z\"/></svg>",
	      "youtube": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15,4.1c1,0.1,2.3,0,3,0.8c0.8,0.8,0.9,2.1,0.9,3.1C19,9.2,19,10.9,19,12c-0.1,1.1,0,2.4-0.5,3.4c-0.5,1.1-1.4,1.5-2.5,1.6 c-1.2,0.1-8.6,0.1-11,0c-1.1-0.1-2.4-0.1-3.2-1c-0.7-0.8-0.7-2-0.8-3C1,11.8,1,10.1,1,8.9c0-1.1,0-2.4,0.5-3.4C2,4.5,3,4.3,4.1,4.2 C5.3,4.1,12.6,4,15,4.1z M8,7.5v6l5.5-3L8,7.5z\"/></svg>"
	    });
	  }

	  if (typeof window !== 'undefined' && window.UIkit) {
	    window.UIkit.use(plugin);
	  }

	  return plugin;
	});
	});

	const execute = () => {
	  const buttons = document.querySelectorAll('button[data-event="showPassword"]');
	  buttons.forEach(button => {
	    button.addEventListener('click', () => {
	      let inputID = button.getAttribute('data-input');
	      let input = document.getElementById(inputID);
	      let inputType = input.getAttribute('type');

	      if (inputType === 'password') {
	        input.setAttribute('type', 'text');
	      } else {
	        input.setAttribute('type', 'password');
	      }
	    });
	  });
	};

	const execute$1 = () => {
	  document.addEventListener('click', event => {
	    let element = event.target;

	    if (element.classList.contains('quantity__button--plus') || element.classList.contains('quantity__button--minus')) {
	      const updateButton = document.querySelector('button[name="update_cart"]');
	      let qtyInputName = element.getAttribute('data-input');
	      let qtyInputs = document.querySelectorAll(`input[name="${qtyInputName}"]`);
	      qtyInputs.forEach(qtyInput => {
	        let max = parseFloat(qtyInput.getAttribute('max'));
	        let min = parseFloat(qtyInput.getAttribute('min'));
	        let step = parseFloat(qtyInput.getAttribute('step'));
	        let val = parseFloat(qtyInput.value);

	        if (element.classList.contains('quantity__button--plus')) {
	          if (val === max) return false;

	          if (val + step > max) {
	            qtyInput.value = max;
	          } else {
	            qtyInput.value = val + step;
	          }
	        } else if (element.classList.contains('quantity__button--minus')) {
	          if (val === min) return false;

	          if (val + step < min) {
	            qtyInput.value = min;
	          } else {
	            qtyInput.value = val - step;
	          }
	        }
	      });
	      updateButton.disabled = false;
	      updateButton.click();
	    }
	  });
	  jQuery(document).on('change', '#woocommerce-cart-form input.qty', function () {
	    const updateButton = document.querySelector('button[name="update_cart"]');
	    let name = jQuery(this).attr('name');
	    let val = jQuery(this).val();
	    jQuery('input[name="' + name + '"]').val(val);
	    updateButton.disabled = false;
	    updateButton.click();
	  });
	};

	var pl = createCommonjsModule(function (module, exports) {
	(function (global, factory) {
	   factory(exports) ;
	})(commonjsGlobal, function (exports) {

	  var fp = typeof window !== "undefined" && window.flatpickr !== undefined ? window.flatpickr : {
	    l10ns: {}
	  };
	  var Polish = {
	    weekdays: {
	      shorthand: ["Nd", "Pn", "Wt", "r", "Cz", "Pt", "So"],
	      longhand: ["Niedziela", "Poniedziaek", "Wtorek", "roda", "Czwartek", "Pitek", "Sobota"]
	    },
	    months: {
	      shorthand: ["Sty", "Lut", "Mar", "Kwi", "Maj", "Cze", "Lip", "Sie", "Wrz", "Pa", "Lis", "Gru"],
	      longhand: ["Stycze", "Luty", "Marzec", "Kwiecie", "Maj", "Czerwiec", "Lipiec", "Sierpie", "Wrzesie", "Padziernik", "Listopad", "Grudzie"]
	    },
	    rangeSeparator: " do ",
	    weekAbbreviation: "tydz.",
	    scrollTitle: "Przewi, aby zwikszy",
	    toggleTitle: "Kliknij, aby przeczy",
	    firstDayOfWeek: 1,
	    time_24hr: true,
	    ordinal: function () {
	      return ".";
	    }
	  };
	  fp.l10ns.pl = Polish;
	  var pl = fp.l10ns;
	  exports.Polish = Polish;
	  exports.default = pl;
	  Object.defineProperty(exports, '__esModule', {
	    value: true
	  });
	});
	});

	unwrapExports(pl);

	var moment = createCommonjsModule(function (module, exports) {

	(function (global, factory) {
	   module.exports = factory() ;
	})(commonjsGlobal, function () {

	  var hookCallback;

	  function hooks() {
	    return hookCallback.apply(null, arguments);
	  } // This is done to register the method called with moment()
	  // without creating circular dependencies.


	  function setHookCallback(callback) {
	    hookCallback = callback;
	  }

	  function isArray(input) {
	    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
	  }

	  function isObject(input) {
	    // IE8 will treat undefined and null as object if it wasn't for
	    // input != null
	    return input != null && Object.prototype.toString.call(input) === '[object Object]';
	  }

	  function isObjectEmpty(obj) {
	    if (Object.getOwnPropertyNames) {
	      return Object.getOwnPropertyNames(obj).length === 0;
	    } else {
	      var k;

	      for (k in obj) {
	        if (obj.hasOwnProperty(k)) {
	          return false;
	        }
	      }

	      return true;
	    }
	  }

	  function isUndefined(input) {
	    return input === void 0;
	  }

	  function isNumber(input) {
	    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
	  }

	  function isDate(input) {
	    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
	  }

	  function map(arr, fn) {
	    var res = [],
	        i;

	    for (i = 0; i < arr.length; ++i) {
	      res.push(fn(arr[i], i));
	    }

	    return res;
	  }

	  function hasOwnProp(a, b) {
	    return Object.prototype.hasOwnProperty.call(a, b);
	  }

	  function extend(a, b) {
	    for (var i in b) {
	      if (hasOwnProp(b, i)) {
	        a[i] = b[i];
	      }
	    }

	    if (hasOwnProp(b, 'toString')) {
	      a.toString = b.toString;
	    }

	    if (hasOwnProp(b, 'valueOf')) {
	      a.valueOf = b.valueOf;
	    }

	    return a;
	  }

	  function createUTC(input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, true).utc();
	  }

	  function defaultParsingFlags() {
	    // We need to deep clone this object.
	    return {
	      empty: false,
	      unusedTokens: [],
	      unusedInput: [],
	      overflow: -2,
	      charsLeftOver: 0,
	      nullInput: false,
	      invalidMonth: null,
	      invalidFormat: false,
	      userInvalidated: false,
	      iso: false,
	      parsedDateParts: [],
	      meridiem: null,
	      rfc2822: false,
	      weekdayMismatch: false
	    };
	  }

	  function getParsingFlags(m) {
	    if (m._pf == null) {
	      m._pf = defaultParsingFlags();
	    }

	    return m._pf;
	  }

	  var some;

	  if (Array.prototype.some) {
	    some = Array.prototype.some;
	  } else {
	    some = function (fun) {
	      var t = Object(this);
	      var len = t.length >>> 0;

	      for (var i = 0; i < len; i++) {
	        if (i in t && fun.call(this, t[i], i, t)) {
	          return true;
	        }
	      }

	      return false;
	    };
	  }

	  function isValid(m) {
	    if (m._isValid == null) {
	      var flags = getParsingFlags(m);
	      var parsedParts = some.call(flags.parsedDateParts, function (i) {
	        return i != null;
	      });
	      var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

	      if (m._strict) {
	        isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
	      }

	      if (Object.isFrozen == null || !Object.isFrozen(m)) {
	        m._isValid = isNowValid;
	      } else {
	        return isNowValid;
	      }
	    }

	    return m._isValid;
	  }

	  function createInvalid(flags) {
	    var m = createUTC(NaN);

	    if (flags != null) {
	      extend(getParsingFlags(m), flags);
	    } else {
	      getParsingFlags(m).userInvalidated = true;
	    }

	    return m;
	  } // Plugins that add properties should also add the key here (null value),
	  // so we can properly clone ourselves.


	  var momentProperties = hooks.momentProperties = [];

	  function copyConfig(to, from) {
	    var i, prop, val;

	    if (!isUndefined(from._isAMomentObject)) {
	      to._isAMomentObject = from._isAMomentObject;
	    }

	    if (!isUndefined(from._i)) {
	      to._i = from._i;
	    }

	    if (!isUndefined(from._f)) {
	      to._f = from._f;
	    }

	    if (!isUndefined(from._l)) {
	      to._l = from._l;
	    }

	    if (!isUndefined(from._strict)) {
	      to._strict = from._strict;
	    }

	    if (!isUndefined(from._tzm)) {
	      to._tzm = from._tzm;
	    }

	    if (!isUndefined(from._isUTC)) {
	      to._isUTC = from._isUTC;
	    }

	    if (!isUndefined(from._offset)) {
	      to._offset = from._offset;
	    }

	    if (!isUndefined(from._pf)) {
	      to._pf = getParsingFlags(from);
	    }

	    if (!isUndefined(from._locale)) {
	      to._locale = from._locale;
	    }

	    if (momentProperties.length > 0) {
	      for (i = 0; i < momentProperties.length; i++) {
	        prop = momentProperties[i];
	        val = from[prop];

	        if (!isUndefined(val)) {
	          to[prop] = val;
	        }
	      }
	    }

	    return to;
	  }

	  var updateInProgress = false; // Moment prototype object

	  function Moment(config) {
	    copyConfig(this, config);
	    this._d = new Date(config._d != null ? config._d.getTime() : NaN);

	    if (!this.isValid()) {
	      this._d = new Date(NaN);
	    } // Prevent infinite loop in case updateOffset creates new moment
	    // objects.


	    if (updateInProgress === false) {
	      updateInProgress = true;
	      hooks.updateOffset(this);
	      updateInProgress = false;
	    }
	  }

	  function isMoment(obj) {
	    return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
	  }

	  function absFloor(number) {
	    if (number < 0) {
	      // -0 -> 0
	      return Math.ceil(number) || 0;
	    } else {
	      return Math.floor(number);
	    }
	  }

	  function toInt(argumentForCoercion) {
	    var coercedNumber = +argumentForCoercion,
	        value = 0;

	    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
	      value = absFloor(coercedNumber);
	    }

	    return value;
	  } // compare two arrays, return the number of differences


	  function compareArrays(array1, array2, dontConvert) {
	    var len = Math.min(array1.length, array2.length),
	        lengthDiff = Math.abs(array1.length - array2.length),
	        diffs = 0,
	        i;

	    for (i = 0; i < len; i++) {
	      if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
	        diffs++;
	      }
	    }

	    return diffs + lengthDiff;
	  }

	  function warn(msg) {
	    if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
	      console.warn('Deprecation warning: ' + msg);
	    }
	  }

	  function deprecate(msg, fn) {
	    var firstTime = true;
	    return extend(function () {
	      if (hooks.deprecationHandler != null) {
	        hooks.deprecationHandler(null, msg);
	      }

	      if (firstTime) {
	        var args = [];
	        var arg;

	        for (var i = 0; i < arguments.length; i++) {
	          arg = '';

	          if (typeof arguments[i] === 'object') {
	            arg += '\n[' + i + '] ';

	            for (var key in arguments[0]) {
	              arg += key + ': ' + arguments[0][key] + ', ';
	            }

	            arg = arg.slice(0, -2); // Remove trailing comma and space
	          } else {
	            arg = arguments[i];
	          }

	          args.push(arg);
	        }

	        warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
	        firstTime = false;
	      }

	      return fn.apply(this, arguments);
	    }, fn);
	  }

	  var deprecations = {};

	  function deprecateSimple(name, msg) {
	    if (hooks.deprecationHandler != null) {
	      hooks.deprecationHandler(name, msg);
	    }

	    if (!deprecations[name]) {
	      warn(msg);
	      deprecations[name] = true;
	    }
	  }

	  hooks.suppressDeprecationWarnings = false;
	  hooks.deprecationHandler = null;

	  function isFunction(input) {
	    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
	  }

	  function set(config) {
	    var prop, i;

	    for (i in config) {
	      prop = config[i];

	      if (isFunction(prop)) {
	        this[i] = prop;
	      } else {
	        this['_' + i] = prop;
	      }
	    }

	    this._config = config; // Lenient ordinal parsing accepts just a number in addition to
	    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
	    // TODO: Remove "ordinalParse" fallback in next major release.

	    this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
	  }

	  function mergeConfigs(parentConfig, childConfig) {
	    var res = extend({}, parentConfig),
	        prop;

	    for (prop in childConfig) {
	      if (hasOwnProp(childConfig, prop)) {
	        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
	          res[prop] = {};
	          extend(res[prop], parentConfig[prop]);
	          extend(res[prop], childConfig[prop]);
	        } else if (childConfig[prop] != null) {
	          res[prop] = childConfig[prop];
	        } else {
	          delete res[prop];
	        }
	      }
	    }

	    for (prop in parentConfig) {
	      if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
	        // make sure changes to properties don't modify parent config
	        res[prop] = extend({}, res[prop]);
	      }
	    }

	    return res;
	  }

	  function Locale(config) {
	    if (config != null) {
	      this.set(config);
	    }
	  }

	  var keys;

	  if (Object.keys) {
	    keys = Object.keys;
	  } else {
	    keys = function (obj) {
	      var i,
	          res = [];

	      for (i in obj) {
	        if (hasOwnProp(obj, i)) {
	          res.push(i);
	        }
	      }

	      return res;
	    };
	  }

	  var defaultCalendar = {
	    sameDay: '[Today at] LT',
	    nextDay: '[Tomorrow at] LT',
	    nextWeek: 'dddd [at] LT',
	    lastDay: '[Yesterday at] LT',
	    lastWeek: '[Last] dddd [at] LT',
	    sameElse: 'L'
	  };

	  function calendar(key, mom, now) {
	    var output = this._calendar[key] || this._calendar['sameElse'];
	    return isFunction(output) ? output.call(mom, now) : output;
	  }

	  var defaultLongDateFormat = {
	    LTS: 'h:mm:ss A',
	    LT: 'h:mm A',
	    L: 'MM/DD/YYYY',
	    LL: 'MMMM D, YYYY',
	    LLL: 'MMMM D, YYYY h:mm A',
	    LLLL: 'dddd, MMMM D, YYYY h:mm A'
	  };

	  function longDateFormat(key) {
	    var format = this._longDateFormat[key],
	        formatUpper = this._longDateFormat[key.toUpperCase()];

	    if (format || !formatUpper) {
	      return format;
	    }

	    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
	      return val.slice(1);
	    });
	    return this._longDateFormat[key];
	  }

	  var defaultInvalidDate = 'Invalid date';

	  function invalidDate() {
	    return this._invalidDate;
	  }

	  var defaultOrdinal = '%d';
	  var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

	  function ordinal(number) {
	    return this._ordinal.replace('%d', number);
	  }

	  var defaultRelativeTime = {
	    future: 'in %s',
	    past: '%s ago',
	    s: 'a few seconds',
	    ss: '%d seconds',
	    m: 'a minute',
	    mm: '%d minutes',
	    h: 'an hour',
	    hh: '%d hours',
	    d: 'a day',
	    dd: '%d days',
	    M: 'a month',
	    MM: '%d months',
	    y: 'a year',
	    yy: '%d years'
	  };

	  function relativeTime(number, withoutSuffix, string, isFuture) {
	    var output = this._relativeTime[string];
	    return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
	  }

	  function pastFuture(diff, output) {
	    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
	    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
	  }

	  var aliases = {};

	  function addUnitAlias(unit, shorthand) {
	    var lowerCase = unit.toLowerCase();
	    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
	  }

	  function normalizeUnits(units) {
	    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
	  }

	  function normalizeObjectUnits(inputObject) {
	    var normalizedInput = {},
	        normalizedProp,
	        prop;

	    for (prop in inputObject) {
	      if (hasOwnProp(inputObject, prop)) {
	        normalizedProp = normalizeUnits(prop);

	        if (normalizedProp) {
	          normalizedInput[normalizedProp] = inputObject[prop];
	        }
	      }
	    }

	    return normalizedInput;
	  }

	  var priorities = {};

	  function addUnitPriority(unit, priority) {
	    priorities[unit] = priority;
	  }

	  function getPrioritizedUnits(unitsObj) {
	    var units = [];

	    for (var u in unitsObj) {
	      units.push({
	        unit: u,
	        priority: priorities[u]
	      });
	    }

	    units.sort(function (a, b) {
	      return a.priority - b.priority;
	    });
	    return units;
	  }

	  function zeroFill(number, targetLength, forceSign) {
	    var absNumber = '' + Math.abs(number),
	        zerosToFill = targetLength - absNumber.length,
	        sign = number >= 0;
	    return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
	  }

	  var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
	  var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
	  var formatFunctions = {};
	  var formatTokenFunctions = {}; // token:    'M'
	  // padded:   ['MM', 2]
	  // ordinal:  'Mo'
	  // callback: function () { this.month() + 1 }

	  function addFormatToken(token, padded, ordinal, callback) {
	    var func = callback;

	    if (typeof callback === 'string') {
	      func = function () {
	        return this[callback]();
	      };
	    }

	    if (token) {
	      formatTokenFunctions[token] = func;
	    }

	    if (padded) {
	      formatTokenFunctions[padded[0]] = function () {
	        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
	      };
	    }

	    if (ordinal) {
	      formatTokenFunctions[ordinal] = function () {
	        return this.localeData().ordinal(func.apply(this, arguments), token);
	      };
	    }
	  }

	  function removeFormattingTokens(input) {
	    if (input.match(/\[[\s\S]/)) {
	      return input.replace(/^\[|\]$/g, '');
	    }

	    return input.replace(/\\/g, '');
	  }

	  function makeFormatFunction(format) {
	    var array = format.match(formattingTokens),
	        i,
	        length;

	    for (i = 0, length = array.length; i < length; i++) {
	      if (formatTokenFunctions[array[i]]) {
	        array[i] = formatTokenFunctions[array[i]];
	      } else {
	        array[i] = removeFormattingTokens(array[i]);
	      }
	    }

	    return function (mom) {
	      var output = '',
	          i;

	      for (i = 0; i < length; i++) {
	        output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
	      }

	      return output;
	    };
	  } // format date using native date object


	  function formatMoment(m, format) {
	    if (!m.isValid()) {
	      return m.localeData().invalidDate();
	    }

	    format = expandFormat(format, m.localeData());
	    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
	    return formatFunctions[format](m);
	  }

	  function expandFormat(format, locale) {
	    var i = 5;

	    function replaceLongDateFormatTokens(input) {
	      return locale.longDateFormat(input) || input;
	    }

	    localFormattingTokens.lastIndex = 0;

	    while (i >= 0 && localFormattingTokens.test(format)) {
	      format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
	      localFormattingTokens.lastIndex = 0;
	      i -= 1;
	    }

	    return format;
	  }

	  var match1 = /\d/; //       0 - 9

	  var match2 = /\d\d/; //      00 - 99

	  var match3 = /\d{3}/; //     000 - 999

	  var match4 = /\d{4}/; //    0000 - 9999

	  var match6 = /[+-]?\d{6}/; // -999999 - 999999

	  var match1to2 = /\d\d?/; //       0 - 99

	  var match3to4 = /\d\d\d\d?/; //     999 - 9999

	  var match5to6 = /\d\d\d\d\d\d?/; //   99999 - 999999

	  var match1to3 = /\d{1,3}/; //       0 - 999

	  var match1to4 = /\d{1,4}/; //       0 - 9999

	  var match1to6 = /[+-]?\d{1,6}/; // -999999 - 999999

	  var matchUnsigned = /\d+/; //       0 - inf

	  var matchSigned = /[+-]?\d+/; //    -inf - inf

	  var matchOffset = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

	  var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

	  var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
	  // any word (or two) characters or numbers including two/three word month in arabic.
	  // includes scottish gaelic two word and hyphenated months

	  var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
	  var regexes = {};

	  function addRegexToken(token, regex, strictRegex) {
	    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
	      return isStrict && strictRegex ? strictRegex : regex;
	    };
	  }

	  function getParseRegexForToken(token, config) {
	    if (!hasOwnProp(regexes, token)) {
	      return new RegExp(unescapeFormat(token));
	    }

	    return regexes[token](config._strict, config._locale);
	  } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript


	  function unescapeFormat(s) {
	    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
	      return p1 || p2 || p3 || p4;
	    }));
	  }

	  function regexEscape(s) {
	    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
	  }

	  var tokens = {};

	  function addParseToken(token, callback) {
	    var i,
	        func = callback;

	    if (typeof token === 'string') {
	      token = [token];
	    }

	    if (isNumber(callback)) {
	      func = function (input, array) {
	        array[callback] = toInt(input);
	      };
	    }

	    for (i = 0; i < token.length; i++) {
	      tokens[token[i]] = func;
	    }
	  }

	  function addWeekParseToken(token, callback) {
	    addParseToken(token, function (input, array, config, token) {
	      config._w = config._w || {};
	      callback(input, config._w, config, token);
	    });
	  }

	  function addTimeToArrayFromToken(token, input, config) {
	    if (input != null && hasOwnProp(tokens, token)) {
	      tokens[token](input, config._a, config, token);
	    }
	  }

	  var YEAR = 0;
	  var MONTH = 1;
	  var DATE = 2;
	  var HOUR = 3;
	  var MINUTE = 4;
	  var SECOND = 5;
	  var MILLISECOND = 6;
	  var WEEK = 7;
	  var WEEKDAY = 8; // FORMATTING

	  addFormatToken('Y', 0, 0, function () {
	    var y = this.year();
	    return y <= 9999 ? '' + y : '+' + y;
	  });
	  addFormatToken(0, ['YY', 2], 0, function () {
	    return this.year() % 100;
	  });
	  addFormatToken(0, ['YYYY', 4], 0, 'year');
	  addFormatToken(0, ['YYYYY', 5], 0, 'year');
	  addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES

	  addUnitAlias('year', 'y'); // PRIORITIES

	  addUnitPriority('year', 1); // PARSING

	  addRegexToken('Y', matchSigned);
	  addRegexToken('YY', match1to2, match2);
	  addRegexToken('YYYY', match1to4, match4);
	  addRegexToken('YYYYY', match1to6, match6);
	  addRegexToken('YYYYYY', match1to6, match6);
	  addParseToken(['YYYYY', 'YYYYYY'], YEAR);
	  addParseToken('YYYY', function (input, array) {
	    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
	  });
	  addParseToken('YY', function (input, array) {
	    array[YEAR] = hooks.parseTwoDigitYear(input);
	  });
	  addParseToken('Y', function (input, array) {
	    array[YEAR] = parseInt(input, 10);
	  }); // HELPERS

	  function daysInYear(year) {
	    return isLeapYear(year) ? 366 : 365;
	  }

	  function isLeapYear(year) {
	    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
	  } // HOOKS


	  hooks.parseTwoDigitYear = function (input) {
	    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
	  }; // MOMENTS


	  var getSetYear = makeGetSet('FullYear', true);

	  function getIsLeapYear() {
	    return isLeapYear(this.year());
	  }

	  function makeGetSet(unit, keepTime) {
	    return function (value) {
	      if (value != null) {
	        set$1(this, unit, value);
	        hooks.updateOffset(this, keepTime);
	        return this;
	      } else {
	        return get(this, unit);
	      }
	    };
	  }

	  function get(mom, unit) {
	    return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
	  }

	  function set$1(mom, unit, value) {
	    if (mom.isValid() && !isNaN(value)) {
	      if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
	      } else {
	        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
	      }
	    }
	  } // MOMENTS


	  function stringGet(units) {
	    units = normalizeUnits(units);

	    if (isFunction(this[units])) {
	      return this[units]();
	    }

	    return this;
	  }

	  function stringSet(units, value) {
	    if (typeof units === 'object') {
	      units = normalizeObjectUnits(units);
	      var prioritized = getPrioritizedUnits(units);

	      for (var i = 0; i < prioritized.length; i++) {
	        this[prioritized[i].unit](units[prioritized[i].unit]);
	      }
	    } else {
	      units = normalizeUnits(units);

	      if (isFunction(this[units])) {
	        return this[units](value);
	      }
	    }

	    return this;
	  }

	  function mod(n, x) {
	    return (n % x + x) % x;
	  }

	  var indexOf;

	  if (Array.prototype.indexOf) {
	    indexOf = Array.prototype.indexOf;
	  } else {
	    indexOf = function (o) {
	      // I know
	      var i;

	      for (i = 0; i < this.length; ++i) {
	        if (this[i] === o) {
	          return i;
	        }
	      }

	      return -1;
	    };
	  }

	  function daysInMonth(year, month) {
	    if (isNaN(year) || isNaN(month)) {
	      return NaN;
	    }

	    var modMonth = mod(month, 12);
	    year += (month - modMonth) / 12;
	    return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
	  } // FORMATTING


	  addFormatToken('M', ['MM', 2], 'Mo', function () {
	    return this.month() + 1;
	  });
	  addFormatToken('MMM', 0, 0, function (format) {
	    return this.localeData().monthsShort(this, format);
	  });
	  addFormatToken('MMMM', 0, 0, function (format) {
	    return this.localeData().months(this, format);
	  }); // ALIASES

	  addUnitAlias('month', 'M'); // PRIORITY

	  addUnitPriority('month', 8); // PARSING

	  addRegexToken('M', match1to2);
	  addRegexToken('MM', match1to2, match2);
	  addRegexToken('MMM', function (isStrict, locale) {
	    return locale.monthsShortRegex(isStrict);
	  });
	  addRegexToken('MMMM', function (isStrict, locale) {
	    return locale.monthsRegex(isStrict);
	  });
	  addParseToken(['M', 'MM'], function (input, array) {
	    array[MONTH] = toInt(input) - 1;
	  });
	  addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
	    var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.


	    if (month != null) {
	      array[MONTH] = month;
	    } else {
	      getParsingFlags(config).invalidMonth = input;
	    }
	  }); // LOCALES

	  var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
	  var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');

	  function localeMonths(m, format) {
	    if (!m) {
	      return isArray(this._months) ? this._months : this._months['standalone'];
	    }

	    return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
	  }

	  var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');

	  function localeMonthsShort(m, format) {
	    if (!m) {
	      return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
	    }

	    return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
	  }

	  function handleStrictParse(monthName, format, strict) {
	    var i,
	        ii,
	        mom,
	        llc = monthName.toLocaleLowerCase();

	    if (!this._monthsParse) {
	      // this is not used
	      this._monthsParse = [];
	      this._longMonthsParse = [];
	      this._shortMonthsParse = [];

	      for (i = 0; i < 12; ++i) {
	        mom = createUTC([2000, i]);
	        this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
	        this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
	      }
	    }

	    if (strict) {
	      if (format === 'MMM') {
	        ii = indexOf.call(this._shortMonthsParse, llc);
	        return ii !== -1 ? ii : null;
	      } else {
	        ii = indexOf.call(this._longMonthsParse, llc);
	        return ii !== -1 ? ii : null;
	      }
	    } else {
	      if (format === 'MMM') {
	        ii = indexOf.call(this._shortMonthsParse, llc);

	        if (ii !== -1) {
	          return ii;
	        }

	        ii = indexOf.call(this._longMonthsParse, llc);
	        return ii !== -1 ? ii : null;
	      } else {
	        ii = indexOf.call(this._longMonthsParse, llc);

	        if (ii !== -1) {
	          return ii;
	        }

	        ii = indexOf.call(this._shortMonthsParse, llc);
	        return ii !== -1 ? ii : null;
	      }
	    }
	  }

	  function localeMonthsParse(monthName, format, strict) {
	    var i, mom, regex;

	    if (this._monthsParseExact) {
	      return handleStrictParse.call(this, monthName, format, strict);
	    }

	    if (!this._monthsParse) {
	      this._monthsParse = [];
	      this._longMonthsParse = [];
	      this._shortMonthsParse = [];
	    } // TODO: add sorting
	    // Sorting makes sure if one month (or abbr) is a prefix of another
	    // see sorting in computeMonthsParse


	    for (i = 0; i < 12; i++) {
	      // make the regex if we don't have it already
	      mom = createUTC([2000, i]);

	      if (strict && !this._longMonthsParse[i]) {
	        this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
	        this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
	      }

	      if (!strict && !this._monthsParse[i]) {
	        regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
	        this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
	      } // test the regex


	      if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
	        return i;
	      } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
	        return i;
	      } else if (!strict && this._monthsParse[i].test(monthName)) {
	        return i;
	      }
	    }
	  } // MOMENTS


	  function setMonth(mom, value) {
	    var dayOfMonth;

	    if (!mom.isValid()) {
	      // No op
	      return mom;
	    }

	    if (typeof value === 'string') {
	      if (/^\d+$/.test(value)) {
	        value = toInt(value);
	      } else {
	        value = mom.localeData().monthsParse(value); // TODO: Another silent failure?

	        if (!isNumber(value)) {
	          return mom;
	        }
	      }
	    }

	    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));

	    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);

	    return mom;
	  }

	  function getSetMonth(value) {
	    if (value != null) {
	      setMonth(this, value);
	      hooks.updateOffset(this, true);
	      return this;
	    } else {
	      return get(this, 'Month');
	    }
	  }

	  function getDaysInMonth() {
	    return daysInMonth(this.year(), this.month());
	  }

	  var defaultMonthsShortRegex = matchWord;

	  function monthsShortRegex(isStrict) {
	    if (this._monthsParseExact) {
	      if (!hasOwnProp(this, '_monthsRegex')) {
	        computeMonthsParse.call(this);
	      }

	      if (isStrict) {
	        return this._monthsShortStrictRegex;
	      } else {
	        return this._monthsShortRegex;
	      }
	    } else {
	      if (!hasOwnProp(this, '_monthsShortRegex')) {
	        this._monthsShortRegex = defaultMonthsShortRegex;
	      }

	      return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
	    }
	  }

	  var defaultMonthsRegex = matchWord;

	  function monthsRegex(isStrict) {
	    if (this._monthsParseExact) {
	      if (!hasOwnProp(this, '_monthsRegex')) {
	        computeMonthsParse.call(this);
	      }

	      if (isStrict) {
	        return this._monthsStrictRegex;
	      } else {
	        return this._monthsRegex;
	      }
	    } else {
	      if (!hasOwnProp(this, '_monthsRegex')) {
	        this._monthsRegex = defaultMonthsRegex;
	      }

	      return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
	    }
	  }

	  function computeMonthsParse() {
	    function cmpLenRev(a, b) {
	      return b.length - a.length;
	    }

	    var shortPieces = [],
	        longPieces = [],
	        mixedPieces = [],
	        i,
	        mom;

	    for (i = 0; i < 12; i++) {
	      // make the regex if we don't have it already
	      mom = createUTC([2000, i]);
	      shortPieces.push(this.monthsShort(mom, ''));
	      longPieces.push(this.months(mom, ''));
	      mixedPieces.push(this.months(mom, ''));
	      mixedPieces.push(this.monthsShort(mom, ''));
	    } // Sorting makes sure if one month (or abbr) is a prefix of another it
	    // will match the longer piece.


	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);

	    for (i = 0; i < 12; i++) {
	      shortPieces[i] = regexEscape(shortPieces[i]);
	      longPieces[i] = regexEscape(longPieces[i]);
	    }

	    for (i = 0; i < 24; i++) {
	      mixedPieces[i] = regexEscape(mixedPieces[i]);
	    }

	    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	    this._monthsShortRegex = this._monthsRegex;
	    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	  }

	  function createDate(y, m, d, h, M, s, ms) {
	    // can't just apply() to create a date:
	    // https://stackoverflow.com/q/181348
	    var date; // the date constructor remaps years 0-99 to 1900-1999

	    if (y < 100 && y >= 0) {
	      // preserve leap years using a full 400 year cycle, then reset
	      date = new Date(y + 400, m, d, h, M, s, ms);

	      if (isFinite(date.getFullYear())) {
	        date.setFullYear(y);
	      }
	    } else {
	      date = new Date(y, m, d, h, M, s, ms);
	    }

	    return date;
	  }

	  function createUTCDate(y) {
	    var date; // the Date.UTC function remaps years 0-99 to 1900-1999

	    if (y < 100 && y >= 0) {
	      var args = Array.prototype.slice.call(arguments); // preserve leap years using a full 400 year cycle, then reset

	      args[0] = y + 400;
	      date = new Date(Date.UTC.apply(null, args));

	      if (isFinite(date.getUTCFullYear())) {
	        date.setUTCFullYear(y);
	      }
	    } else {
	      date = new Date(Date.UTC.apply(null, arguments));
	    }

	    return date;
	  } // start-of-first-week - start-of-year


	  function firstWeekOffset(year, dow, doy) {
	    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
	    fwd = 7 + dow - doy,
	        // first-week day local weekday -- which local weekday is fwd
	    fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
	    return -fwdlw + fwd - 1;
	  } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday


	  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
	    var localWeekday = (7 + weekday - dow) % 7,
	        weekOffset = firstWeekOffset(year, dow, doy),
	        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
	        resYear,
	        resDayOfYear;

	    if (dayOfYear <= 0) {
	      resYear = year - 1;
	      resDayOfYear = daysInYear(resYear) + dayOfYear;
	    } else if (dayOfYear > daysInYear(year)) {
	      resYear = year + 1;
	      resDayOfYear = dayOfYear - daysInYear(year);
	    } else {
	      resYear = year;
	      resDayOfYear = dayOfYear;
	    }

	    return {
	      year: resYear,
	      dayOfYear: resDayOfYear
	    };
	  }

	  function weekOfYear(mom, dow, doy) {
	    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
	        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
	        resWeek,
	        resYear;

	    if (week < 1) {
	      resYear = mom.year() - 1;
	      resWeek = week + weeksInYear(resYear, dow, doy);
	    } else if (week > weeksInYear(mom.year(), dow, doy)) {
	      resWeek = week - weeksInYear(mom.year(), dow, doy);
	      resYear = mom.year() + 1;
	    } else {
	      resYear = mom.year();
	      resWeek = week;
	    }

	    return {
	      week: resWeek,
	      year: resYear
	    };
	  }

	  function weeksInYear(year, dow, doy) {
	    var weekOffset = firstWeekOffset(year, dow, doy),
	        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
	    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
	  } // FORMATTING


	  addFormatToken('w', ['ww', 2], 'wo', 'week');
	  addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES

	  addUnitAlias('week', 'w');
	  addUnitAlias('isoWeek', 'W'); // PRIORITIES

	  addUnitPriority('week', 5);
	  addUnitPriority('isoWeek', 5); // PARSING

	  addRegexToken('w', match1to2);
	  addRegexToken('ww', match1to2, match2);
	  addRegexToken('W', match1to2);
	  addRegexToken('WW', match1to2, match2);
	  addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
	    week[token.substr(0, 1)] = toInt(input);
	  }); // HELPERS
	  // LOCALES

	  function localeWeek(mom) {
	    return weekOfYear(mom, this._week.dow, this._week.doy).week;
	  }

	  var defaultLocaleWeek = {
	    dow: 0,
	    // Sunday is the first day of the week.
	    doy: 6 // The week that contains Jan 6th is the first week of the year.

	  };

	  function localeFirstDayOfWeek() {
	    return this._week.dow;
	  }

	  function localeFirstDayOfYear() {
	    return this._week.doy;
	  } // MOMENTS


	  function getSetWeek(input) {
	    var week = this.localeData().week(this);
	    return input == null ? week : this.add((input - week) * 7, 'd');
	  }

	  function getSetISOWeek(input) {
	    var week = weekOfYear(this, 1, 4).week;
	    return input == null ? week : this.add((input - week) * 7, 'd');
	  } // FORMATTING


	  addFormatToken('d', 0, 'do', 'day');
	  addFormatToken('dd', 0, 0, function (format) {
	    return this.localeData().weekdaysMin(this, format);
	  });
	  addFormatToken('ddd', 0, 0, function (format) {
	    return this.localeData().weekdaysShort(this, format);
	  });
	  addFormatToken('dddd', 0, 0, function (format) {
	    return this.localeData().weekdays(this, format);
	  });
	  addFormatToken('e', 0, 0, 'weekday');
	  addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES

	  addUnitAlias('day', 'd');
	  addUnitAlias('weekday', 'e');
	  addUnitAlias('isoWeekday', 'E'); // PRIORITY

	  addUnitPriority('day', 11);
	  addUnitPriority('weekday', 11);
	  addUnitPriority('isoWeekday', 11); // PARSING

	  addRegexToken('d', match1to2);
	  addRegexToken('e', match1to2);
	  addRegexToken('E', match1to2);
	  addRegexToken('dd', function (isStrict, locale) {
	    return locale.weekdaysMinRegex(isStrict);
	  });
	  addRegexToken('ddd', function (isStrict, locale) {
	    return locale.weekdaysShortRegex(isStrict);
	  });
	  addRegexToken('dddd', function (isStrict, locale) {
	    return locale.weekdaysRegex(isStrict);
	  });
	  addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
	    var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid


	    if (weekday != null) {
	      week.d = weekday;
	    } else {
	      getParsingFlags(config).invalidWeekday = input;
	    }
	  });
	  addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
	    week[token] = toInt(input);
	  }); // HELPERS

	  function parseWeekday(input, locale) {
	    if (typeof input !== 'string') {
	      return input;
	    }

	    if (!isNaN(input)) {
	      return parseInt(input, 10);
	    }

	    input = locale.weekdaysParse(input);

	    if (typeof input === 'number') {
	      return input;
	    }

	    return null;
	  }

	  function parseIsoWeekday(input, locale) {
	    if (typeof input === 'string') {
	      return locale.weekdaysParse(input) % 7 || 7;
	    }

	    return isNaN(input) ? null : input;
	  } // LOCALES


	  function shiftWeekdays(ws, n) {
	    return ws.slice(n, 7).concat(ws.slice(0, n));
	  }

	  var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');

	  function localeWeekdays(m, format) {
	    var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
	    return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
	  }

	  var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');

	  function localeWeekdaysShort(m) {
	    return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
	  }

	  var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');

	  function localeWeekdaysMin(m) {
	    return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
	  }

	  function handleStrictParse$1(weekdayName, format, strict) {
	    var i,
	        ii,
	        mom,
	        llc = weekdayName.toLocaleLowerCase();

	    if (!this._weekdaysParse) {
	      this._weekdaysParse = [];
	      this._shortWeekdaysParse = [];
	      this._minWeekdaysParse = [];

	      for (i = 0; i < 7; ++i) {
	        mom = createUTC([2000, 1]).day(i);
	        this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
	        this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
	        this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
	      }
	    }

	    if (strict) {
	      if (format === 'dddd') {
	        ii = indexOf.call(this._weekdaysParse, llc);
	        return ii !== -1 ? ii : null;
	      } else if (format === 'ddd') {
	        ii = indexOf.call(this._shortWeekdaysParse, llc);
	        return ii !== -1 ? ii : null;
	      } else {
	        ii = indexOf.call(this._minWeekdaysParse, llc);
	        return ii !== -1 ? ii : null;
	      }
	    } else {
	      if (format === 'dddd') {
	        ii = indexOf.call(this._weekdaysParse, llc);

	        if (ii !== -1) {
	          return ii;
	        }

	        ii = indexOf.call(this._shortWeekdaysParse, llc);

	        if (ii !== -1) {
	          return ii;
	        }

	        ii = indexOf.call(this._minWeekdaysParse, llc);
	        return ii !== -1 ? ii : null;
	      } else if (format === 'ddd') {
	        ii = indexOf.call(this._shortWeekdaysParse, llc);

	        if (ii !== -1) {
	          return ii;
	        }

	        ii = indexOf.call(this._weekdaysParse, llc);

	        if (ii !== -1) {
	          return ii;
	        }

	        ii = indexOf.call(this._minWeekdaysParse, llc);
	        return ii !== -1 ? ii : null;
	      } else {
	        ii = indexOf.call(this._minWeekdaysParse, llc);

	        if (ii !== -1) {
	          return ii;
	        }

	        ii = indexOf.call(this._weekdaysParse, llc);

	        if (ii !== -1) {
	          return ii;
	        }

	        ii = indexOf.call(this._shortWeekdaysParse, llc);
	        return ii !== -1 ? ii : null;
	      }
	    }
	  }

	  function localeWeekdaysParse(weekdayName, format, strict) {
	    var i, mom, regex;

	    if (this._weekdaysParseExact) {
	      return handleStrictParse$1.call(this, weekdayName, format, strict);
	    }

	    if (!this._weekdaysParse) {
	      this._weekdaysParse = [];
	      this._minWeekdaysParse = [];
	      this._shortWeekdaysParse = [];
	      this._fullWeekdaysParse = [];
	    }

	    for (i = 0; i < 7; i++) {
	      // make the regex if we don't have it already
	      mom = createUTC([2000, 1]).day(i);

	      if (strict && !this._fullWeekdaysParse[i]) {
	        this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
	        this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
	        this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
	      }

	      if (!this._weekdaysParse[i]) {
	        regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
	        this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
	      } // test the regex


	      if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
	        return i;
	      } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
	        return i;
	      } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
	        return i;
	      } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
	        return i;
	      }
	    }
	  } // MOMENTS


	  function getSetDayOfWeek(input) {
	    if (!this.isValid()) {
	      return input != null ? this : NaN;
	    }

	    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();

	    if (input != null) {
	      input = parseWeekday(input, this.localeData());
	      return this.add(input - day, 'd');
	    } else {
	      return day;
	    }
	  }

	  function getSetLocaleDayOfWeek(input) {
	    if (!this.isValid()) {
	      return input != null ? this : NaN;
	    }

	    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
	    return input == null ? weekday : this.add(input - weekday, 'd');
	  }

	  function getSetISODayOfWeek(input) {
	    if (!this.isValid()) {
	      return input != null ? this : NaN;
	    } // behaves the same as moment#day except
	    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
	    // as a setter, sunday should belong to the previous week.


	    if (input != null) {
	      var weekday = parseIsoWeekday(input, this.localeData());
	      return this.day(this.day() % 7 ? weekday : weekday - 7);
	    } else {
	      return this.day() || 7;
	    }
	  }

	  var defaultWeekdaysRegex = matchWord;

	  function weekdaysRegex(isStrict) {
	    if (this._weekdaysParseExact) {
	      if (!hasOwnProp(this, '_weekdaysRegex')) {
	        computeWeekdaysParse.call(this);
	      }

	      if (isStrict) {
	        return this._weekdaysStrictRegex;
	      } else {
	        return this._weekdaysRegex;
	      }
	    } else {
	      if (!hasOwnProp(this, '_weekdaysRegex')) {
	        this._weekdaysRegex = defaultWeekdaysRegex;
	      }

	      return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
	    }
	  }

	  var defaultWeekdaysShortRegex = matchWord;

	  function weekdaysShortRegex(isStrict) {
	    if (this._weekdaysParseExact) {
	      if (!hasOwnProp(this, '_weekdaysRegex')) {
	        computeWeekdaysParse.call(this);
	      }

	      if (isStrict) {
	        return this._weekdaysShortStrictRegex;
	      } else {
	        return this._weekdaysShortRegex;
	      }
	    } else {
	      if (!hasOwnProp(this, '_weekdaysShortRegex')) {
	        this._weekdaysShortRegex = defaultWeekdaysShortRegex;
	      }

	      return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
	    }
	  }

	  var defaultWeekdaysMinRegex = matchWord;

	  function weekdaysMinRegex(isStrict) {
	    if (this._weekdaysParseExact) {
	      if (!hasOwnProp(this, '_weekdaysRegex')) {
	        computeWeekdaysParse.call(this);
	      }

	      if (isStrict) {
	        return this._weekdaysMinStrictRegex;
	      } else {
	        return this._weekdaysMinRegex;
	      }
	    } else {
	      if (!hasOwnProp(this, '_weekdaysMinRegex')) {
	        this._weekdaysMinRegex = defaultWeekdaysMinRegex;
	      }

	      return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
	    }
	  }

	  function computeWeekdaysParse() {
	    function cmpLenRev(a, b) {
	      return b.length - a.length;
	    }

	    var minPieces = [],
	        shortPieces = [],
	        longPieces = [],
	        mixedPieces = [],
	        i,
	        mom,
	        minp,
	        shortp,
	        longp;

	    for (i = 0; i < 7; i++) {
	      // make the regex if we don't have it already
	      mom = createUTC([2000, 1]).day(i);
	      minp = this.weekdaysMin(mom, '');
	      shortp = this.weekdaysShort(mom, '');
	      longp = this.weekdays(mom, '');
	      minPieces.push(minp);
	      shortPieces.push(shortp);
	      longPieces.push(longp);
	      mixedPieces.push(minp);
	      mixedPieces.push(shortp);
	      mixedPieces.push(longp);
	    } // Sorting makes sure if one weekday (or abbr) is a prefix of another it
	    // will match the longer piece.


	    minPieces.sort(cmpLenRev);
	    shortPieces.sort(cmpLenRev);
	    longPieces.sort(cmpLenRev);
	    mixedPieces.sort(cmpLenRev);

	    for (i = 0; i < 7; i++) {
	      shortPieces[i] = regexEscape(shortPieces[i]);
	      longPieces[i] = regexEscape(longPieces[i]);
	      mixedPieces[i] = regexEscape(mixedPieces[i]);
	    }

	    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
	    this._weekdaysShortRegex = this._weekdaysRegex;
	    this._weekdaysMinRegex = this._weekdaysRegex;
	    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
	    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
	    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
	  } // FORMATTING


	  function hFormat() {
	    return this.hours() % 12 || 12;
	  }

	  function kFormat() {
	    return this.hours() || 24;
	  }

	  addFormatToken('H', ['HH', 2], 0, 'hour');
	  addFormatToken('h', ['hh', 2], 0, hFormat);
	  addFormatToken('k', ['kk', 2], 0, kFormat);
	  addFormatToken('hmm', 0, 0, function () {
	    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
	  });
	  addFormatToken('hmmss', 0, 0, function () {
	    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
	  });
	  addFormatToken('Hmm', 0, 0, function () {
	    return '' + this.hours() + zeroFill(this.minutes(), 2);
	  });
	  addFormatToken('Hmmss', 0, 0, function () {
	    return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
	  });

	  function meridiem(token, lowercase) {
	    addFormatToken(token, 0, 0, function () {
	      return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
	    });
	  }

	  meridiem('a', true);
	  meridiem('A', false); // ALIASES

	  addUnitAlias('hour', 'h'); // PRIORITY

	  addUnitPriority('hour', 13); // PARSING

	  function matchMeridiem(isStrict, locale) {
	    return locale._meridiemParse;
	  }

	  addRegexToken('a', matchMeridiem);
	  addRegexToken('A', matchMeridiem);
	  addRegexToken('H', match1to2);
	  addRegexToken('h', match1to2);
	  addRegexToken('k', match1to2);
	  addRegexToken('HH', match1to2, match2);
	  addRegexToken('hh', match1to2, match2);
	  addRegexToken('kk', match1to2, match2);
	  addRegexToken('hmm', match3to4);
	  addRegexToken('hmmss', match5to6);
	  addRegexToken('Hmm', match3to4);
	  addRegexToken('Hmmss', match5to6);
	  addParseToken(['H', 'HH'], HOUR);
	  addParseToken(['k', 'kk'], function (input, array, config) {
	    var kInput = toInt(input);
	    array[HOUR] = kInput === 24 ? 0 : kInput;
	  });
	  addParseToken(['a', 'A'], function (input, array, config) {
	    config._isPm = config._locale.isPM(input);
	    config._meridiem = input;
	  });
	  addParseToken(['h', 'hh'], function (input, array, config) {
	    array[HOUR] = toInt(input);
	    getParsingFlags(config).bigHour = true;
	  });
	  addParseToken('hmm', function (input, array, config) {
	    var pos = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos));
	    array[MINUTE] = toInt(input.substr(pos));
	    getParsingFlags(config).bigHour = true;
	  });
	  addParseToken('hmmss', function (input, array, config) {
	    var pos1 = input.length - 4;
	    var pos2 = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos1));
	    array[MINUTE] = toInt(input.substr(pos1, 2));
	    array[SECOND] = toInt(input.substr(pos2));
	    getParsingFlags(config).bigHour = true;
	  });
	  addParseToken('Hmm', function (input, array, config) {
	    var pos = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos));
	    array[MINUTE] = toInt(input.substr(pos));
	  });
	  addParseToken('Hmmss', function (input, array, config) {
	    var pos1 = input.length - 4;
	    var pos2 = input.length - 2;
	    array[HOUR] = toInt(input.substr(0, pos1));
	    array[MINUTE] = toInt(input.substr(pos1, 2));
	    array[SECOND] = toInt(input.substr(pos2));
	  }); // LOCALES

	  function localeIsPM(input) {
	    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
	    // Using charAt should be more compatible.
	    return (input + '').toLowerCase().charAt(0) === 'p';
	  }

	  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;

	  function localeMeridiem(hours, minutes, isLower) {
	    if (hours > 11) {
	      return isLower ? 'pm' : 'PM';
	    } else {
	      return isLower ? 'am' : 'AM';
	    }
	  } // MOMENTS
	  // Setting the hour should keep the time, because the user explicitly
	  // specified which hour they want. So trying to maintain the same hour (in
	  // a new timezone) makes sense. Adding/subtracting hours does not follow
	  // this rule.


	  var getSetHour = makeGetSet('Hours', true);
	  var baseConfig = {
	    calendar: defaultCalendar,
	    longDateFormat: defaultLongDateFormat,
	    invalidDate: defaultInvalidDate,
	    ordinal: defaultOrdinal,
	    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
	    relativeTime: defaultRelativeTime,
	    months: defaultLocaleMonths,
	    monthsShort: defaultLocaleMonthsShort,
	    week: defaultLocaleWeek,
	    weekdays: defaultLocaleWeekdays,
	    weekdaysMin: defaultLocaleWeekdaysMin,
	    weekdaysShort: defaultLocaleWeekdaysShort,
	    meridiemParse: defaultLocaleMeridiemParse
	  }; // internal storage for locale config files

	  var locales = {};
	  var localeFamilies = {};
	  var globalLocale;

	  function normalizeLocale(key) {
	    return key ? key.toLowerCase().replace('_', '-') : key;
	  } // pick the locale from the array
	  // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
	  // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root


	  function chooseLocale(names) {
	    var i = 0,
	        j,
	        next,
	        locale,
	        split;

	    while (i < names.length) {
	      split = normalizeLocale(names[i]).split('-');
	      j = split.length;
	      next = normalizeLocale(names[i + 1]);
	      next = next ? next.split('-') : null;

	      while (j > 0) {
	        locale = loadLocale(split.slice(0, j).join('-'));

	        if (locale) {
	          return locale;
	        }

	        if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
	          //the next array item is better than a shallower substring of this one
	          break;
	        }

	        j--;
	      }

	      i++;
	    }

	    return globalLocale;
	  }

	  function loadLocale(name) {
	    var oldLocale = null; // TODO: Find a better way to register and load all the locales in Node

	    if (!locales[name] && 'object' !== 'undefined' && module && module.exports) {
	      try {
	        oldLocale = globalLocale._abbr;
	        var aliasedRequire = commonjsRequire;
	        aliasedRequire('./locale/' + name);
	        getSetGlobalLocale(oldLocale);
	      } catch (e) {}
	    }

	    return locales[name];
	  } // This function will load locale and then set the global locale.  If
	  // no arguments are passed in, it will simply return the current global
	  // locale key.


	  function getSetGlobalLocale(key, values) {
	    var data;

	    if (key) {
	      if (isUndefined(values)) {
	        data = getLocale(key);
	      } else {
	        data = defineLocale(key, values);
	      }

	      if (data) {
	        // moment.duration._locale = moment._locale = data;
	        globalLocale = data;
	      } else {
	        if (typeof console !== 'undefined' && console.warn) {
	          //warn user if arguments are passed but the locale could not be set
	          console.warn('Locale ' + key + ' not found. Did you forget to load it?');
	        }
	      }
	    }

	    return globalLocale._abbr;
	  }

	  function defineLocale(name, config) {
	    if (config !== null) {
	      var locale,
	          parentConfig = baseConfig;
	      config.abbr = name;

	      if (locales[name] != null) {
	        deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
	        parentConfig = locales[name]._config;
	      } else if (config.parentLocale != null) {
	        if (locales[config.parentLocale] != null) {
	          parentConfig = locales[config.parentLocale]._config;
	        } else {
	          locale = loadLocale(config.parentLocale);

	          if (locale != null) {
	            parentConfig = locale._config;
	          } else {
	            if (!localeFamilies[config.parentLocale]) {
	              localeFamilies[config.parentLocale] = [];
	            }

	            localeFamilies[config.parentLocale].push({
	              name: name,
	              config: config
	            });
	            return null;
	          }
	        }
	      }

	      locales[name] = new Locale(mergeConfigs(parentConfig, config));

	      if (localeFamilies[name]) {
	        localeFamilies[name].forEach(function (x) {
	          defineLocale(x.name, x.config);
	        });
	      } // backwards compat for now: also set the locale
	      // make sure we set the locale AFTER all child locales have been
	      // created, so we won't end up with the child locale set.


	      getSetGlobalLocale(name);
	      return locales[name];
	    } else {
	      // useful for testing
	      delete locales[name];
	      return null;
	    }
	  }

	  function updateLocale(name, config) {
	    if (config != null) {
	      var locale,
	          tmpLocale,
	          parentConfig = baseConfig; // MERGE

	      tmpLocale = loadLocale(name);

	      if (tmpLocale != null) {
	        parentConfig = tmpLocale._config;
	      }

	      config = mergeConfigs(parentConfig, config);
	      locale = new Locale(config);
	      locale.parentLocale = locales[name];
	      locales[name] = locale; // backwards compat for now: also set the locale

	      getSetGlobalLocale(name);
	    } else {
	      // pass null for config to unupdate, useful for tests
	      if (locales[name] != null) {
	        if (locales[name].parentLocale != null) {
	          locales[name] = locales[name].parentLocale;
	        } else if (locales[name] != null) {
	          delete locales[name];
	        }
	      }
	    }

	    return locales[name];
	  } // returns locale data


	  function getLocale(key) {
	    var locale;

	    if (key && key._locale && key._locale._abbr) {
	      key = key._locale._abbr;
	    }

	    if (!key) {
	      return globalLocale;
	    }

	    if (!isArray(key)) {
	      //short-circuit everything else
	      locale = loadLocale(key);

	      if (locale) {
	        return locale;
	      }

	      key = [key];
	    }

	    return chooseLocale(key);
	  }

	  function listLocales() {
	    return keys(locales);
	  }

	  function checkOverflow(m) {
	    var overflow;
	    var a = m._a;

	    if (a && getParsingFlags(m).overflow === -2) {
	      overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

	      if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
	        overflow = DATE;
	      }

	      if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
	        overflow = WEEK;
	      }

	      if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
	        overflow = WEEKDAY;
	      }

	      getParsingFlags(m).overflow = overflow;
	    }

	    return m;
	  } // Pick the first defined of two or three arguments.


	  function defaults(a, b, c) {
	    if (a != null) {
	      return a;
	    }

	    if (b != null) {
	      return b;
	    }

	    return c;
	  }

	  function currentDateArray(config) {
	    // hooks is actually the exported moment object
	    var nowValue = new Date(hooks.now());

	    if (config._useUTC) {
	      return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
	    }

	    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
	  } // convert an array to a date.
	  // the array should mirror the parameters below
	  // note: all values past the year are optional and will default to the lowest possible value.
	  // [year, month, day , hour, minute, second, millisecond]


	  function configFromArray(config) {
	    var i,
	        date,
	        input = [],
	        currentDate,
	        expectedWeekday,
	        yearToUse;

	    if (config._d) {
	      return;
	    }

	    currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

	    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
	      dayOfYearFromWeekInfo(config);
	    } //if the day of the year is set, figure out what it is


	    if (config._dayOfYear != null) {
	      yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

	      if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
	        getParsingFlags(config)._overflowDayOfYear = true;
	      }

	      date = createUTCDate(yearToUse, 0, config._dayOfYear);
	      config._a[MONTH] = date.getUTCMonth();
	      config._a[DATE] = date.getUTCDate();
	    } // Default to current date.
	    // * if no year, month, day of month are given, default to today
	    // * if day of month is given, default month and year
	    // * if month is given, default only year
	    // * if year is given, don't default anything


	    for (i = 0; i < 3 && config._a[i] == null; ++i) {
	      config._a[i] = input[i] = currentDate[i];
	    } // Zero out whatever was not defaulted, including time


	    for (; i < 7; i++) {
	      config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
	    } // Check for 24:00:00.000


	    if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
	      config._nextDay = true;
	      config._a[HOUR] = 0;
	    }

	    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
	    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed
	    // with parseZone.

	    if (config._tzm != null) {
	      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
	    }

	    if (config._nextDay) {
	      config._a[HOUR] = 24;
	    } // check for mismatching day of week


	    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
	      getParsingFlags(config).weekdayMismatch = true;
	    }
	  }

	  function dayOfYearFromWeekInfo(config) {
	    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
	    w = config._w;

	    if (w.GG != null || w.W != null || w.E != null) {
	      dow = 1;
	      doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
	      // how we interpret now (local, utc, fixed offset). So create
	      // a now version of current config (take local/utc/offset flags, and
	      // create now).

	      weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
	      week = defaults(w.W, 1);
	      weekday = defaults(w.E, 1);

	      if (weekday < 1 || weekday > 7) {
	        weekdayOverflow = true;
	      }
	    } else {
	      dow = config._locale._week.dow;
	      doy = config._locale._week.doy;
	      var curWeek = weekOfYear(createLocal(), dow, doy);
	      weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.

	      week = defaults(w.w, curWeek.week);

	      if (w.d != null) {
	        // weekday -- low day numbers are considered next week
	        weekday = w.d;

	        if (weekday < 0 || weekday > 6) {
	          weekdayOverflow = true;
	        }
	      } else if (w.e != null) {
	        // local weekday -- counting starts from beginning of week
	        weekday = w.e + dow;

	        if (w.e < 0 || w.e > 6) {
	          weekdayOverflow = true;
	        }
	      } else {
	        // default to beginning of week
	        weekday = dow;
	      }
	    }

	    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
	      getParsingFlags(config)._overflowWeeks = true;
	    } else if (weekdayOverflow != null) {
	      getParsingFlags(config)._overflowWeekday = true;
	    } else {
	      temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
	      config._a[YEAR] = temp.year;
	      config._dayOfYear = temp.dayOfYear;
	    }
	  } // iso 8601 regex
	  // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)


	  var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	  var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
	  var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
	  var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], // YYYYMM is NOT allowed by the standard
	  ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]]; // iso time formats and regexes

	  var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
	  var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i; // date from iso format

	  function configFromISO(config) {
	    var i,
	        l,
	        string = config._i,
	        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
	        allowTime,
	        dateFormat,
	        timeFormat,
	        tzFormat;

	    if (match) {
	      getParsingFlags(config).iso = true;

	      for (i = 0, l = isoDates.length; i < l; i++) {
	        if (isoDates[i][1].exec(match[1])) {
	          dateFormat = isoDates[i][0];
	          allowTime = isoDates[i][2] !== false;
	          break;
	        }
	      }

	      if (dateFormat == null) {
	        config._isValid = false;
	        return;
	      }

	      if (match[3]) {
	        for (i = 0, l = isoTimes.length; i < l; i++) {
	          if (isoTimes[i][1].exec(match[3])) {
	            // match[2] should be 'T' or space
	            timeFormat = (match[2] || ' ') + isoTimes[i][0];
	            break;
	          }
	        }

	        if (timeFormat == null) {
	          config._isValid = false;
	          return;
	        }
	      }

	      if (!allowTime && timeFormat != null) {
	        config._isValid = false;
	        return;
	      }

	      if (match[4]) {
	        if (tzRegex.exec(match[4])) {
	          tzFormat = 'Z';
	        } else {
	          config._isValid = false;
	          return;
	        }
	      }

	      config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
	      configFromStringAndFormat(config);
	    } else {
	      config._isValid = false;
	    }
	  } // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3


	  var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

	  function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
	    var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

	    if (secondStr) {
	      result.push(parseInt(secondStr, 10));
	    }

	    return result;
	  }

	  function untruncateYear(yearStr) {
	    var year = parseInt(yearStr, 10);

	    if (year <= 49) {
	      return 2000 + year;
	    } else if (year <= 999) {
	      return 1900 + year;
	    }

	    return year;
	  }

	  function preprocessRFC2822(s) {
	    // Remove comments and folding whitespace and replace multiple-spaces with a single space
	    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
	  }

	  function checkWeekday(weekdayStr, parsedInput, config) {
	    if (weekdayStr) {
	      // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
	      var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
	          weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();

	      if (weekdayProvided !== weekdayActual) {
	        getParsingFlags(config).weekdayMismatch = true;
	        config._isValid = false;
	        return false;
	      }
	    }

	    return true;
	  }

	  var obsOffsets = {
	    UT: 0,
	    GMT: 0,
	    EDT: -4 * 60,
	    EST: -5 * 60,
	    CDT: -5 * 60,
	    CST: -6 * 60,
	    MDT: -6 * 60,
	    MST: -7 * 60,
	    PDT: -7 * 60,
	    PST: -8 * 60
	  };

	  function calculateOffset(obsOffset, militaryOffset, numOffset) {
	    if (obsOffset) {
	      return obsOffsets[obsOffset];
	    } else if (militaryOffset) {
	      // the only allowed military tz is Z
	      return 0;
	    } else {
	      var hm = parseInt(numOffset, 10);
	      var m = hm % 100,
	          h = (hm - m) / 100;
	      return h * 60 + m;
	    }
	  } // date and time from ref 2822 format


	  function configFromRFC2822(config) {
	    var match = rfc2822.exec(preprocessRFC2822(config._i));

	    if (match) {
	      var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);

	      if (!checkWeekday(match[1], parsedArray, config)) {
	        return;
	      }

	      config._a = parsedArray;
	      config._tzm = calculateOffset(match[8], match[9], match[10]);
	      config._d = createUTCDate.apply(null, config._a);

	      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

	      getParsingFlags(config).rfc2822 = true;
	    } else {
	      config._isValid = false;
	    }
	  } // date from iso format or fallback


	  function configFromString(config) {
	    var matched = aspNetJsonRegex.exec(config._i);

	    if (matched !== null) {
	      config._d = new Date(+matched[1]);
	      return;
	    }

	    configFromISO(config);

	    if (config._isValid === false) {
	      delete config._isValid;
	    } else {
	      return;
	    }

	    configFromRFC2822(config);

	    if (config._isValid === false) {
	      delete config._isValid;
	    } else {
	      return;
	    } // Final attempt, use Input Fallback


	    hooks.createFromInputFallback(config);
	  }

	  hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
	    config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
	  }); // constant that refers to the ISO standard

	  hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


	  hooks.RFC_2822 = function () {}; // date from string and format string


	  function configFromStringAndFormat(config) {
	    // TODO: Move this to another part of the creation flow to prevent circular deps
	    if (config._f === hooks.ISO_8601) {
	      configFromISO(config);
	      return;
	    }

	    if (config._f === hooks.RFC_2822) {
	      configFromRFC2822(config);
	      return;
	    }

	    config._a = [];
	    getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

	    var string = '' + config._i,
	        i,
	        parsedInput,
	        tokens,
	        token,
	        skipped,
	        stringLength = string.length,
	        totalParsedInputLength = 0;
	    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

	    for (i = 0; i < tokens.length; i++) {
	      token = tokens[i];
	      parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]; // console.log('token', token, 'parsedInput', parsedInput,
	      //         'regex', getParseRegexForToken(token, config));

	      if (parsedInput) {
	        skipped = string.substr(0, string.indexOf(parsedInput));

	        if (skipped.length > 0) {
	          getParsingFlags(config).unusedInput.push(skipped);
	        }

	        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
	        totalParsedInputLength += parsedInput.length;
	      } // don't parse if it's not a known token


	      if (formatTokenFunctions[token]) {
	        if (parsedInput) {
	          getParsingFlags(config).empty = false;
	        } else {
	          getParsingFlags(config).unusedTokens.push(token);
	        }

	        addTimeToArrayFromToken(token, parsedInput, config);
	      } else if (config._strict && !parsedInput) {
	        getParsingFlags(config).unusedTokens.push(token);
	      }
	    } // add remaining unparsed input length to the string


	    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;

	    if (string.length > 0) {
	      getParsingFlags(config).unusedInput.push(string);
	    } // clear _12h flag if hour is <= 12


	    if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
	      getParsingFlags(config).bigHour = undefined;
	    }

	    getParsingFlags(config).parsedDateParts = config._a.slice(0);
	    getParsingFlags(config).meridiem = config._meridiem; // handle meridiem

	    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
	    configFromArray(config);
	    checkOverflow(config);
	  }

	  function meridiemFixWrap(locale, hour, meridiem) {
	    var isPm;

	    if (meridiem == null) {
	      // nothing to do
	      return hour;
	    }

	    if (locale.meridiemHour != null) {
	      return locale.meridiemHour(hour, meridiem);
	    } else if (locale.isPM != null) {
	      // Fallback
	      isPm = locale.isPM(meridiem);

	      if (isPm && hour < 12) {
	        hour += 12;
	      }

	      if (!isPm && hour === 12) {
	        hour = 0;
	      }

	      return hour;
	    } else {
	      // this is not supposed to happen
	      return hour;
	    }
	  } // date from string and array of format strings


	  function configFromStringAndArray(config) {
	    var tempConfig, bestMoment, scoreToBeat, i, currentScore;

	    if (config._f.length === 0) {
	      getParsingFlags(config).invalidFormat = true;
	      config._d = new Date(NaN);
	      return;
	    }

	    for (i = 0; i < config._f.length; i++) {
	      currentScore = 0;
	      tempConfig = copyConfig({}, config);

	      if (config._useUTC != null) {
	        tempConfig._useUTC = config._useUTC;
	      }

	      tempConfig._f = config._f[i];
	      configFromStringAndFormat(tempConfig);

	      if (!isValid(tempConfig)) {
	        continue;
	      } // if there is any input that was not parsed add a penalty for that format


	      currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens

	      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
	      getParsingFlags(tempConfig).score = currentScore;

	      if (scoreToBeat == null || currentScore < scoreToBeat) {
	        scoreToBeat = currentScore;
	        bestMoment = tempConfig;
	      }
	    }

	    extend(config, bestMoment || tempConfig);
	  }

	  function configFromObject(config) {
	    if (config._d) {
	      return;
	    }

	    var i = normalizeObjectUnits(config._i);
	    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
	      return obj && parseInt(obj, 10);
	    });
	    configFromArray(config);
	  }

	  function createFromConfig(config) {
	    var res = new Moment(checkOverflow(prepareConfig(config)));

	    if (res._nextDay) {
	      // Adding is smart enough around DST
	      res.add(1, 'd');
	      res._nextDay = undefined;
	    }

	    return res;
	  }

	  function prepareConfig(config) {
	    var input = config._i,
	        format = config._f;
	    config._locale = config._locale || getLocale(config._l);

	    if (input === null || format === undefined && input === '') {
	      return createInvalid({
	        nullInput: true
	      });
	    }

	    if (typeof input === 'string') {
	      config._i = input = config._locale.preparse(input);
	    }

	    if (isMoment(input)) {
	      return new Moment(checkOverflow(input));
	    } else if (isDate(input)) {
	      config._d = input;
	    } else if (isArray(format)) {
	      configFromStringAndArray(config);
	    } else if (format) {
	      configFromStringAndFormat(config);
	    } else {
	      configFromInput(config);
	    }

	    if (!isValid(config)) {
	      config._d = null;
	    }

	    return config;
	  }

	  function configFromInput(config) {
	    var input = config._i;

	    if (isUndefined(input)) {
	      config._d = new Date(hooks.now());
	    } else if (isDate(input)) {
	      config._d = new Date(input.valueOf());
	    } else if (typeof input === 'string') {
	      configFromString(config);
	    } else if (isArray(input)) {
	      config._a = map(input.slice(0), function (obj) {
	        return parseInt(obj, 10);
	      });
	      configFromArray(config);
	    } else if (isObject(input)) {
	      configFromObject(config);
	    } else if (isNumber(input)) {
	      // from milliseconds
	      config._d = new Date(input);
	    } else {
	      hooks.createFromInputFallback(config);
	    }
	  }

	  function createLocalOrUTC(input, format, locale, strict, isUTC) {
	    var c = {};

	    if (locale === true || locale === false) {
	      strict = locale;
	      locale = undefined;
	    }

	    if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
	      input = undefined;
	    } // object construction must be done this way.
	    // https://github.com/moment/moment/issues/1423


	    c._isAMomentObject = true;
	    c._useUTC = c._isUTC = isUTC;
	    c._l = locale;
	    c._i = input;
	    c._f = format;
	    c._strict = strict;
	    return createFromConfig(c);
	  }

	  function createLocal(input, format, locale, strict) {
	    return createLocalOrUTC(input, format, locale, strict, false);
	  }

	  var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
	    var other = createLocal.apply(null, arguments);

	    if (this.isValid() && other.isValid()) {
	      return other < this ? this : other;
	    } else {
	      return createInvalid();
	    }
	  });
	  var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
	    var other = createLocal.apply(null, arguments);

	    if (this.isValid() && other.isValid()) {
	      return other > this ? this : other;
	    } else {
	      return createInvalid();
	    }
	  }); // Pick a moment m from moments so that m[fn](other) is true for all
	  // other. This relies on the function fn to be transitive.
	  //
	  // moments should either be an array of moment objects or an array, whose
	  // first element is an array of moment objects.

	  function pickBy(fn, moments) {
	    var res, i;

	    if (moments.length === 1 && isArray(moments[0])) {
	      moments = moments[0];
	    }

	    if (!moments.length) {
	      return createLocal();
	    }

	    res = moments[0];

	    for (i = 1; i < moments.length; ++i) {
	      if (!moments[i].isValid() || moments[i][fn](res)) {
	        res = moments[i];
	      }
	    }

	    return res;
	  } // TODO: Use [].sort instead?


	  function min() {
	    var args = [].slice.call(arguments, 0);
	    return pickBy('isBefore', args);
	  }

	  function max() {
	    var args = [].slice.call(arguments, 0);
	    return pickBy('isAfter', args);
	  }

	  var now = function () {
	    return Date.now ? Date.now() : +new Date();
	  };

	  var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

	  function isDurationValid(m) {
	    for (var key in m) {
	      if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
	        return false;
	      }
	    }

	    var unitHasDecimal = false;

	    for (var i = 0; i < ordering.length; ++i) {
	      if (m[ordering[i]]) {
	        if (unitHasDecimal) {
	          return false; // only allow non-integers for smallest unit
	        }

	        if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
	          unitHasDecimal = true;
	        }
	      }
	    }

	    return true;
	  }

	  function isValid$1() {
	    return this._isValid;
	  }

	  function createInvalid$1() {
	    return createDuration(NaN);
	  }

	  function Duration(duration) {
	    var normalizedInput = normalizeObjectUnits(duration),
	        years = normalizedInput.year || 0,
	        quarters = normalizedInput.quarter || 0,
	        months = normalizedInput.month || 0,
	        weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
	        days = normalizedInput.day || 0,
	        hours = normalizedInput.hour || 0,
	        minutes = normalizedInput.minute || 0,
	        seconds = normalizedInput.second || 0,
	        milliseconds = normalizedInput.millisecond || 0;
	    this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove

	    this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
	    minutes * 6e4 + // 1000 * 60
	    hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
	    // Because of dateAddRemove treats 24 hours as different from a
	    // day when working around DST, we need to store them separately

	    this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing
	    // which months you are are talking about, so we have to store
	    // it separately.

	    this._months = +months + quarters * 3 + years * 12;
	    this._data = {};
	    this._locale = getLocale();

	    this._bubble();
	  }

	  function isDuration(obj) {
	    return obj instanceof Duration;
	  }

	  function absRound(number) {
	    if (number < 0) {
	      return Math.round(-1 * number) * -1;
	    } else {
	      return Math.round(number);
	    }
	  } // FORMATTING


	  function offset(token, separator) {
	    addFormatToken(token, 0, 0, function () {
	      var offset = this.utcOffset();
	      var sign = '+';

	      if (offset < 0) {
	        offset = -offset;
	        sign = '-';
	      }

	      return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
	    });
	  }

	  offset('Z', ':');
	  offset('ZZ', ''); // PARSING

	  addRegexToken('Z', matchShortOffset);
	  addRegexToken('ZZ', matchShortOffset);
	  addParseToken(['Z', 'ZZ'], function (input, array, config) {
	    config._useUTC = true;
	    config._tzm = offsetFromString(matchShortOffset, input);
	  }); // HELPERS
	  // timezone chunker
	  // '+10:00' > ['10',  '00']
	  // '-1530'  > ['-15', '30']

	  var chunkOffset = /([\+\-]|\d\d)/gi;

	  function offsetFromString(matcher, string) {
	    var matches = (string || '').match(matcher);

	    if (matches === null) {
	      return null;
	    }

	    var chunk = matches[matches.length - 1] || [];
	    var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
	    var minutes = +(parts[1] * 60) + toInt(parts[2]);
	    return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
	  } // Return a moment from input, that is local/utc/zone equivalent to model.


	  function cloneWithOffset(input, model) {
	    var res, diff;

	    if (model._isUTC) {
	      res = model.clone();
	      diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

	      res._d.setTime(res._d.valueOf() + diff);

	      hooks.updateOffset(res, false);
	      return res;
	    } else {
	      return createLocal(input).local();
	    }
	  }

	  function getDateOffset(m) {
	    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
	    // https://github.com/moment/moment/pull/1871
	    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
	  } // HOOKS
	  // This function will be called whenever a moment is mutated.
	  // It is intended to keep the offset in sync with the timezone.


	  hooks.updateOffset = function () {}; // MOMENTS
	  // keepLocalTime = true means only change the timezone, without
	  // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
	  // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
	  // +0200, so we adjust the time as needed, to be valid.
	  //
	  // Keeping the time actually adds/subtracts (one hour)
	  // from the actual represented time. That is why we call updateOffset
	  // a second time. In case it wants us to change the offset again
	  // _changeInProgress == true case, then we have to adjust, because
	  // there is no such time in the given timezone.


	  function getSetOffset(input, keepLocalTime, keepMinutes) {
	    var offset = this._offset || 0,
	        localAdjust;

	    if (!this.isValid()) {
	      return input != null ? this : NaN;
	    }

	    if (input != null) {
	      if (typeof input === 'string') {
	        input = offsetFromString(matchShortOffset, input);

	        if (input === null) {
	          return this;
	        }
	      } else if (Math.abs(input) < 16 && !keepMinutes) {
	        input = input * 60;
	      }

	      if (!this._isUTC && keepLocalTime) {
	        localAdjust = getDateOffset(this);
	      }

	      this._offset = input;
	      this._isUTC = true;

	      if (localAdjust != null) {
	        this.add(localAdjust, 'm');
	      }

	      if (offset !== input) {
	        if (!keepLocalTime || this._changeInProgress) {
	          addSubtract(this, createDuration(input - offset, 'm'), 1, false);
	        } else if (!this._changeInProgress) {
	          this._changeInProgress = true;
	          hooks.updateOffset(this, true);
	          this._changeInProgress = null;
	        }
	      }

	      return this;
	    } else {
	      return this._isUTC ? offset : getDateOffset(this);
	    }
	  }

	  function getSetZone(input, keepLocalTime) {
	    if (input != null) {
	      if (typeof input !== 'string') {
	        input = -input;
	      }

	      this.utcOffset(input, keepLocalTime);
	      return this;
	    } else {
	      return -this.utcOffset();
	    }
	  }

	  function setOffsetToUTC(keepLocalTime) {
	    return this.utcOffset(0, keepLocalTime);
	  }

	  function setOffsetToLocal(keepLocalTime) {
	    if (this._isUTC) {
	      this.utcOffset(0, keepLocalTime);
	      this._isUTC = false;

	      if (keepLocalTime) {
	        this.subtract(getDateOffset(this), 'm');
	      }
	    }

	    return this;
	  }

	  function setOffsetToParsedOffset() {
	    if (this._tzm != null) {
	      this.utcOffset(this._tzm, false, true);
	    } else if (typeof this._i === 'string') {
	      var tZone = offsetFromString(matchOffset, this._i);

	      if (tZone != null) {
	        this.utcOffset(tZone);
	      } else {
	        this.utcOffset(0, true);
	      }
	    }

	    return this;
	  }

	  function hasAlignedHourOffset(input) {
	    if (!this.isValid()) {
	      return false;
	    }

	    input = input ? createLocal(input).utcOffset() : 0;
	    return (this.utcOffset() - input) % 60 === 0;
	  }

	  function isDaylightSavingTime() {
	    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
	  }

	  function isDaylightSavingTimeShifted() {
	    if (!isUndefined(this._isDSTShifted)) {
	      return this._isDSTShifted;
	    }

	    var c = {};
	    copyConfig(c, this);
	    c = prepareConfig(c);

	    if (c._a) {
	      var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
	      this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
	    } else {
	      this._isDSTShifted = false;
	    }

	    return this._isDSTShifted;
	  }

	  function isLocal() {
	    return this.isValid() ? !this._isUTC : false;
	  }

	  function isUtcOffset() {
	    return this.isValid() ? this._isUTC : false;
	  }

	  function isUtc() {
	    return this.isValid() ? this._isUTC && this._offset === 0 : false;
	  } // ASP.NET json date format regex


	  var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/; // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
	  // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
	  // and further modified to allow for strings containing both week and day

	  var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

	  function createDuration(input, key) {
	    var duration = input,
	        // matching against regexp is expensive, do it on demand
	    match = null,
	        sign,
	        ret,
	        diffRes;

	    if (isDuration(input)) {
	      duration = {
	        ms: input._milliseconds,
	        d: input._days,
	        M: input._months
	      };
	    } else if (isNumber(input)) {
	      duration = {};

	      if (key) {
	        duration[key] = input;
	      } else {
	        duration.milliseconds = input;
	      }
	    } else if (!!(match = aspNetRegex.exec(input))) {
	      sign = match[1] === '-' ? -1 : 1;
	      duration = {
	        y: 0,
	        d: toInt(match[DATE]) * sign,
	        h: toInt(match[HOUR]) * sign,
	        m: toInt(match[MINUTE]) * sign,
	        s: toInt(match[SECOND]) * sign,
	        ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match

	      };
	    } else if (!!(match = isoRegex.exec(input))) {
	      sign = match[1] === '-' ? -1 : 1;
	      duration = {
	        y: parseIso(match[2], sign),
	        M: parseIso(match[3], sign),
	        w: parseIso(match[4], sign),
	        d: parseIso(match[5], sign),
	        h: parseIso(match[6], sign),
	        m: parseIso(match[7], sign),
	        s: parseIso(match[8], sign)
	      };
	    } else if (duration == null) {
	      // checks for null or undefined
	      duration = {};
	    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
	      diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
	      duration = {};
	      duration.ms = diffRes.milliseconds;
	      duration.M = diffRes.months;
	    }

	    ret = new Duration(duration);

	    if (isDuration(input) && hasOwnProp(input, '_locale')) {
	      ret._locale = input._locale;
	    }

	    return ret;
	  }

	  createDuration.fn = Duration.prototype;
	  createDuration.invalid = createInvalid$1;

	  function parseIso(inp, sign) {
	    // We'd normally use ~~inp for this, but unfortunately it also
	    // converts floats to ints.
	    // inp may be undefined, so careful calling replace on it.
	    var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it

	    return (isNaN(res) ? 0 : res) * sign;
	  }

	  function positiveMomentsDifference(base, other) {
	    var res = {};
	    res.months = other.month() - base.month() + (other.year() - base.year()) * 12;

	    if (base.clone().add(res.months, 'M').isAfter(other)) {
	      --res.months;
	    }

	    res.milliseconds = +other - +base.clone().add(res.months, 'M');
	    return res;
	  }

	  function momentsDifference(base, other) {
	    var res;

	    if (!(base.isValid() && other.isValid())) {
	      return {
	        milliseconds: 0,
	        months: 0
	      };
	    }

	    other = cloneWithOffset(other, base);

	    if (base.isBefore(other)) {
	      res = positiveMomentsDifference(base, other);
	    } else {
	      res = positiveMomentsDifference(other, base);
	      res.milliseconds = -res.milliseconds;
	      res.months = -res.months;
	    }

	    return res;
	  } // TODO: remove 'name' arg after deprecation is removed


	  function createAdder(direction, name) {
	    return function (val, period) {
	      var dur, tmp; //invert the arguments, but complain about it

	      if (period !== null && !isNaN(+period)) {
	        deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
	        tmp = val;
	        val = period;
	        period = tmp;
	      }

	      val = typeof val === 'string' ? +val : val;
	      dur = createDuration(val, period);
	      addSubtract(this, dur, direction);
	      return this;
	    };
	  }

	  function addSubtract(mom, duration, isAdding, updateOffset) {
	    var milliseconds = duration._milliseconds,
	        days = absRound(duration._days),
	        months = absRound(duration._months);

	    if (!mom.isValid()) {
	      // No op
	      return;
	    }

	    updateOffset = updateOffset == null ? true : updateOffset;

	    if (months) {
	      setMonth(mom, get(mom, 'Month') + months * isAdding);
	    }

	    if (days) {
	      set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
	    }

	    if (milliseconds) {
	      mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
	    }

	    if (updateOffset) {
	      hooks.updateOffset(mom, days || months);
	    }
	  }

	  var add = createAdder(1, 'add');
	  var subtract = createAdder(-1, 'subtract');

	  function getCalendarFormat(myMoment, now) {
	    var diff = myMoment.diff(now, 'days', true);
	    return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
	  }

	  function calendar$1(time, formats) {
	    // We want to compare the start of today, vs this.
	    // Getting start-of-today depends on whether we're local/utc/offset or not.
	    var now = time || createLocal(),
	        sod = cloneWithOffset(now, this).startOf('day'),
	        format = hooks.calendarFormat(this, sod) || 'sameElse';
	    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
	    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
	  }

	  function clone() {
	    return new Moment(this);
	  }

	  function isAfter(input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input);

	    if (!(this.isValid() && localInput.isValid())) {
	      return false;
	    }

	    units = normalizeUnits(units) || 'millisecond';

	    if (units === 'millisecond') {
	      return this.valueOf() > localInput.valueOf();
	    } else {
	      return localInput.valueOf() < this.clone().startOf(units).valueOf();
	    }
	  }

	  function isBefore(input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input);

	    if (!(this.isValid() && localInput.isValid())) {
	      return false;
	    }

	    units = normalizeUnits(units) || 'millisecond';

	    if (units === 'millisecond') {
	      return this.valueOf() < localInput.valueOf();
	    } else {
	      return this.clone().endOf(units).valueOf() < localInput.valueOf();
	    }
	  }

	  function isBetween(from, to, units, inclusivity) {
	    var localFrom = isMoment(from) ? from : createLocal(from),
	        localTo = isMoment(to) ? to : createLocal(to);

	    if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
	      return false;
	    }

	    inclusivity = inclusivity || '()';
	    return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
	  }

	  function isSame(input, units) {
	    var localInput = isMoment(input) ? input : createLocal(input),
	        inputMs;

	    if (!(this.isValid() && localInput.isValid())) {
	      return false;
	    }

	    units = normalizeUnits(units) || 'millisecond';

	    if (units === 'millisecond') {
	      return this.valueOf() === localInput.valueOf();
	    } else {
	      inputMs = localInput.valueOf();
	      return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
	    }
	  }

	  function isSameOrAfter(input, units) {
	    return this.isSame(input, units) || this.isAfter(input, units);
	  }

	  function isSameOrBefore(input, units) {
	    return this.isSame(input, units) || this.isBefore(input, units);
	  }

	  function diff(input, units, asFloat) {
	    var that, zoneDelta, output;

	    if (!this.isValid()) {
	      return NaN;
	    }

	    that = cloneWithOffset(input, this);

	    if (!that.isValid()) {
	      return NaN;
	    }

	    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
	    units = normalizeUnits(units);

	    switch (units) {
	      case 'year':
	        output = monthDiff(this, that) / 12;
	        break;

	      case 'month':
	        output = monthDiff(this, that);
	        break;

	      case 'quarter':
	        output = monthDiff(this, that) / 3;
	        break;

	      case 'second':
	        output = (this - that) / 1e3;
	        break;
	      // 1000

	      case 'minute':
	        output = (this - that) / 6e4;
	        break;
	      // 1000 * 60

	      case 'hour':
	        output = (this - that) / 36e5;
	        break;
	      // 1000 * 60 * 60

	      case 'day':
	        output = (this - that - zoneDelta) / 864e5;
	        break;
	      // 1000 * 60 * 60 * 24, negate dst

	      case 'week':
	        output = (this - that - zoneDelta) / 6048e5;
	        break;
	      // 1000 * 60 * 60 * 24 * 7, negate dst

	      default:
	        output = this - that;
	    }

	    return asFloat ? output : absFloor(output);
	  }

	  function monthDiff(a, b) {
	    // difference in months
	    var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
	        // b is in (anchor - 1 month, anchor + 1 month)
	    anchor = a.clone().add(wholeMonthDiff, 'months'),
	        anchor2,
	        adjust;

	    if (b - anchor < 0) {
	      anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month

	      adjust = (b - anchor) / (anchor - anchor2);
	    } else {
	      anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month

	      adjust = (b - anchor) / (anchor2 - anchor);
	    } //check for negative zero, return zero if negative zero


	    return -(wholeMonthDiff + adjust) || 0;
	  }

	  hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
	  hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

	  function toString() {
	    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
	  }

	  function toISOString(keepOffset) {
	    if (!this.isValid()) {
	      return null;
	    }

	    var utc = keepOffset !== true;
	    var m = utc ? this.clone().utc() : this;

	    if (m.year() < 0 || m.year() > 9999) {
	      return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
	    }

	    if (isFunction(Date.prototype.toISOString)) {
	      // native implementation is ~50x faster, use it when we can
	      if (utc) {
	        return this.toDate().toISOString();
	      } else {
	        return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
	      }
	    }

	    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
	  }
	  /**
	   * Return a human readable representation of a moment that can
	   * also be evaluated to get a new moment which is the same
	   *
	   * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
	   */


	  function inspect() {
	    if (!this.isValid()) {
	      return 'moment.invalid(/* ' + this._i + ' */)';
	    }

	    var func = 'moment';
	    var zone = '';

	    if (!this.isLocal()) {
	      func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
	      zone = 'Z';
	    }

	    var prefix = '[' + func + '("]';
	    var year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
	    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
	    var suffix = zone + '[")]';
	    return this.format(prefix + year + datetime + suffix);
	  }

	  function format(inputString) {
	    if (!inputString) {
	      inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
	    }

	    var output = formatMoment(this, inputString);
	    return this.localeData().postformat(output);
	  }

	  function from(time, withoutSuffix) {
	    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
	      return createDuration({
	        to: this,
	        from: time
	      }).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	      return this.localeData().invalidDate();
	    }
	  }

	  function fromNow(withoutSuffix) {
	    return this.from(createLocal(), withoutSuffix);
	  }

	  function to(time, withoutSuffix) {
	    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
	      return createDuration({
	        from: this,
	        to: time
	      }).locale(this.locale()).humanize(!withoutSuffix);
	    } else {
	      return this.localeData().invalidDate();
	    }
	  }

	  function toNow(withoutSuffix) {
	    return this.to(createLocal(), withoutSuffix);
	  } // If passed a locale key, it will set the locale for this
	  // instance.  Otherwise, it will return the locale configuration
	  // variables for this instance.


	  function locale(key) {
	    var newLocaleData;

	    if (key === undefined) {
	      return this._locale._abbr;
	    } else {
	      newLocaleData = getLocale(key);

	      if (newLocaleData != null) {
	        this._locale = newLocaleData;
	      }

	      return this;
	    }
	  }

	  var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
	    if (key === undefined) {
	      return this.localeData();
	    } else {
	      return this.locale(key);
	    }
	  });

	  function localeData() {
	    return this._locale;
	  }

	  var MS_PER_SECOND = 1000;
	  var MS_PER_MINUTE = 60 * MS_PER_SECOND;
	  var MS_PER_HOUR = 60 * MS_PER_MINUTE;
	  var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR; // actual modulo - handles negative numbers (for dates before 1970):

	  function mod$1(dividend, divisor) {
	    return (dividend % divisor + divisor) % divisor;
	  }

	  function localStartOfDate(y, m, d) {
	    // the date constructor remaps years 0-99 to 1900-1999
	    if (y < 100 && y >= 0) {
	      // preserve leap years using a full 400 year cycle, then reset
	      return new Date(y + 400, m, d) - MS_PER_400_YEARS;
	    } else {
	      return new Date(y, m, d).valueOf();
	    }
	  }

	  function utcStartOfDate(y, m, d) {
	    // Date.UTC remaps years 0-99 to 1900-1999
	    if (y < 100 && y >= 0) {
	      // preserve leap years using a full 400 year cycle, then reset
	      return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
	    } else {
	      return Date.UTC(y, m, d);
	    }
	  }

	  function startOf(units) {
	    var time;
	    units = normalizeUnits(units);

	    if (units === undefined || units === 'millisecond' || !this.isValid()) {
	      return this;
	    }

	    var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

	    switch (units) {
	      case 'year':
	        time = startOfDate(this.year(), 0, 1);
	        break;

	      case 'quarter':
	        time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
	        break;

	      case 'month':
	        time = startOfDate(this.year(), this.month(), 1);
	        break;

	      case 'week':
	        time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
	        break;

	      case 'isoWeek':
	        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
	        break;

	      case 'day':
	      case 'date':
	        time = startOfDate(this.year(), this.month(), this.date());
	        break;

	      case 'hour':
	        time = this._d.valueOf();
	        time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
	        break;

	      case 'minute':
	        time = this._d.valueOf();
	        time -= mod$1(time, MS_PER_MINUTE);
	        break;

	      case 'second':
	        time = this._d.valueOf();
	        time -= mod$1(time, MS_PER_SECOND);
	        break;
	    }

	    this._d.setTime(time);

	    hooks.updateOffset(this, true);
	    return this;
	  }

	  function endOf(units) {
	    var time;
	    units = normalizeUnits(units);

	    if (units === undefined || units === 'millisecond' || !this.isValid()) {
	      return this;
	    }

	    var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

	    switch (units) {
	      case 'year':
	        time = startOfDate(this.year() + 1, 0, 1) - 1;
	        break;

	      case 'quarter':
	        time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
	        break;

	      case 'month':
	        time = startOfDate(this.year(), this.month() + 1, 1) - 1;
	        break;

	      case 'week':
	        time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
	        break;

	      case 'isoWeek':
	        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
	        break;

	      case 'day':
	      case 'date':
	        time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
	        break;

	      case 'hour':
	        time = this._d.valueOf();
	        time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
	        break;

	      case 'minute':
	        time = this._d.valueOf();
	        time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
	        break;

	      case 'second':
	        time = this._d.valueOf();
	        time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
	        break;
	    }

	    this._d.setTime(time);

	    hooks.updateOffset(this, true);
	    return this;
	  }

	  function valueOf() {
	    return this._d.valueOf() - (this._offset || 0) * 60000;
	  }

	  function unix() {
	    return Math.floor(this.valueOf() / 1000);
	  }

	  function toDate() {
	    return new Date(this.valueOf());
	  }

	  function toArray() {
	    var m = this;
	    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
	  }

	  function toObject() {
	    var m = this;
	    return {
	      years: m.year(),
	      months: m.month(),
	      date: m.date(),
	      hours: m.hours(),
	      minutes: m.minutes(),
	      seconds: m.seconds(),
	      milliseconds: m.milliseconds()
	    };
	  }

	  function toJSON() {
	    // new Date(NaN).toJSON() === null
	    return this.isValid() ? this.toISOString() : null;
	  }

	  function isValid$2() {
	    return isValid(this);
	  }

	  function parsingFlags() {
	    return extend({}, getParsingFlags(this));
	  }

	  function invalidAt() {
	    return getParsingFlags(this).overflow;
	  }

	  function creationData() {
	    return {
	      input: this._i,
	      format: this._f,
	      locale: this._locale,
	      isUTC: this._isUTC,
	      strict: this._strict
	    };
	  } // FORMATTING


	  addFormatToken(0, ['gg', 2], 0, function () {
	    return this.weekYear() % 100;
	  });
	  addFormatToken(0, ['GG', 2], 0, function () {
	    return this.isoWeekYear() % 100;
	  });

	  function addWeekYearFormatToken(token, getter) {
	    addFormatToken(0, [token, token.length], 0, getter);
	  }

	  addWeekYearFormatToken('gggg', 'weekYear');
	  addWeekYearFormatToken('ggggg', 'weekYear');
	  addWeekYearFormatToken('GGGG', 'isoWeekYear');
	  addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES

	  addUnitAlias('weekYear', 'gg');
	  addUnitAlias('isoWeekYear', 'GG'); // PRIORITY

	  addUnitPriority('weekYear', 1);
	  addUnitPriority('isoWeekYear', 1); // PARSING

	  addRegexToken('G', matchSigned);
	  addRegexToken('g', matchSigned);
	  addRegexToken('GG', match1to2, match2);
	  addRegexToken('gg', match1to2, match2);
	  addRegexToken('GGGG', match1to4, match4);
	  addRegexToken('gggg', match1to4, match4);
	  addRegexToken('GGGGG', match1to6, match6);
	  addRegexToken('ggggg', match1to6, match6);
	  addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
	    week[token.substr(0, 2)] = toInt(input);
	  });
	  addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
	    week[token] = hooks.parseTwoDigitYear(input);
	  }); // MOMENTS

	  function getSetWeekYear(input) {
	    return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
	  }

	  function getSetISOWeekYear(input) {
	    return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
	  }

	  function getISOWeeksInYear() {
	    return weeksInYear(this.year(), 1, 4);
	  }

	  function getWeeksInYear() {
	    var weekInfo = this.localeData()._week;

	    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
	  }

	  function getSetWeekYearHelper(input, week, weekday, dow, doy) {
	    var weeksTarget;

	    if (input == null) {
	      return weekOfYear(this, dow, doy).year;
	    } else {
	      weeksTarget = weeksInYear(input, dow, doy);

	      if (week > weeksTarget) {
	        week = weeksTarget;
	      }

	      return setWeekAll.call(this, input, week, weekday, dow, doy);
	    }
	  }

	  function setWeekAll(weekYear, week, weekday, dow, doy) {
	    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
	        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
	    this.year(date.getUTCFullYear());
	    this.month(date.getUTCMonth());
	    this.date(date.getUTCDate());
	    return this;
	  } // FORMATTING


	  addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES

	  addUnitAlias('quarter', 'Q'); // PRIORITY

	  addUnitPriority('quarter', 7); // PARSING

	  addRegexToken('Q', match1);
	  addParseToken('Q', function (input, array) {
	    array[MONTH] = (toInt(input) - 1) * 3;
	  }); // MOMENTS

	  function getSetQuarter(input) {
	    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
	  } // FORMATTING


	  addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES

	  addUnitAlias('date', 'D'); // PRIORITY

	  addUnitPriority('date', 9); // PARSING

	  addRegexToken('D', match1to2);
	  addRegexToken('DD', match1to2, match2);
	  addRegexToken('Do', function (isStrict, locale) {
	    // TODO: Remove "ordinalParse" fallback in next major release.
	    return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
	  });
	  addParseToken(['D', 'DD'], DATE);
	  addParseToken('Do', function (input, array) {
	    array[DATE] = toInt(input.match(match1to2)[0]);
	  }); // MOMENTS

	  var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING

	  addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES

	  addUnitAlias('dayOfYear', 'DDD'); // PRIORITY

	  addUnitPriority('dayOfYear', 4); // PARSING

	  addRegexToken('DDD', match1to3);
	  addRegexToken('DDDD', match3);
	  addParseToken(['DDD', 'DDDD'], function (input, array, config) {
	    config._dayOfYear = toInt(input);
	  }); // HELPERS
	  // MOMENTS

	  function getSetDayOfYear(input) {
	    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
	    return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
	  } // FORMATTING


	  addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES

	  addUnitAlias('minute', 'm'); // PRIORITY

	  addUnitPriority('minute', 14); // PARSING

	  addRegexToken('m', match1to2);
	  addRegexToken('mm', match1to2, match2);
	  addParseToken(['m', 'mm'], MINUTE); // MOMENTS

	  var getSetMinute = makeGetSet('Minutes', false); // FORMATTING

	  addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES

	  addUnitAlias('second', 's'); // PRIORITY

	  addUnitPriority('second', 15); // PARSING

	  addRegexToken('s', match1to2);
	  addRegexToken('ss', match1to2, match2);
	  addParseToken(['s', 'ss'], SECOND); // MOMENTS

	  var getSetSecond = makeGetSet('Seconds', false); // FORMATTING

	  addFormatToken('S', 0, 0, function () {
	    return ~~(this.millisecond() / 100);
	  });
	  addFormatToken(0, ['SS', 2], 0, function () {
	    return ~~(this.millisecond() / 10);
	  });
	  addFormatToken(0, ['SSS', 3], 0, 'millisecond');
	  addFormatToken(0, ['SSSS', 4], 0, function () {
	    return this.millisecond() * 10;
	  });
	  addFormatToken(0, ['SSSSS', 5], 0, function () {
	    return this.millisecond() * 100;
	  });
	  addFormatToken(0, ['SSSSSS', 6], 0, function () {
	    return this.millisecond() * 1000;
	  });
	  addFormatToken(0, ['SSSSSSS', 7], 0, function () {
	    return this.millisecond() * 10000;
	  });
	  addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
	    return this.millisecond() * 100000;
	  });
	  addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
	    return this.millisecond() * 1000000;
	  }); // ALIASES

	  addUnitAlias('millisecond', 'ms'); // PRIORITY

	  addUnitPriority('millisecond', 16); // PARSING

	  addRegexToken('S', match1to3, match1);
	  addRegexToken('SS', match1to3, match2);
	  addRegexToken('SSS', match1to3, match3);
	  var token;

	  for (token = 'SSSS'; token.length <= 9; token += 'S') {
	    addRegexToken(token, matchUnsigned);
	  }

	  function parseMs(input, array) {
	    array[MILLISECOND] = toInt(('0.' + input) * 1000);
	  }

	  for (token = 'S'; token.length <= 9; token += 'S') {
	    addParseToken(token, parseMs);
	  } // MOMENTS


	  var getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING

	  addFormatToken('z', 0, 0, 'zoneAbbr');
	  addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS

	  function getZoneAbbr() {
	    return this._isUTC ? 'UTC' : '';
	  }

	  function getZoneName() {
	    return this._isUTC ? 'Coordinated Universal Time' : '';
	  }

	  var proto = Moment.prototype;
	  proto.add = add;
	  proto.calendar = calendar$1;
	  proto.clone = clone;
	  proto.diff = diff;
	  proto.endOf = endOf;
	  proto.format = format;
	  proto.from = from;
	  proto.fromNow = fromNow;
	  proto.to = to;
	  proto.toNow = toNow;
	  proto.get = stringGet;
	  proto.invalidAt = invalidAt;
	  proto.isAfter = isAfter;
	  proto.isBefore = isBefore;
	  proto.isBetween = isBetween;
	  proto.isSame = isSame;
	  proto.isSameOrAfter = isSameOrAfter;
	  proto.isSameOrBefore = isSameOrBefore;
	  proto.isValid = isValid$2;
	  proto.lang = lang;
	  proto.locale = locale;
	  proto.localeData = localeData;
	  proto.max = prototypeMax;
	  proto.min = prototypeMin;
	  proto.parsingFlags = parsingFlags;
	  proto.set = stringSet;
	  proto.startOf = startOf;
	  proto.subtract = subtract;
	  proto.toArray = toArray;
	  proto.toObject = toObject;
	  proto.toDate = toDate;
	  proto.toISOString = toISOString;
	  proto.inspect = inspect;
	  proto.toJSON = toJSON;
	  proto.toString = toString;
	  proto.unix = unix;
	  proto.valueOf = valueOf;
	  proto.creationData = creationData;
	  proto.year = getSetYear;
	  proto.isLeapYear = getIsLeapYear;
	  proto.weekYear = getSetWeekYear;
	  proto.isoWeekYear = getSetISOWeekYear;
	  proto.quarter = proto.quarters = getSetQuarter;
	  proto.month = getSetMonth;
	  proto.daysInMonth = getDaysInMonth;
	  proto.week = proto.weeks = getSetWeek;
	  proto.isoWeek = proto.isoWeeks = getSetISOWeek;
	  proto.weeksInYear = getWeeksInYear;
	  proto.isoWeeksInYear = getISOWeeksInYear;
	  proto.date = getSetDayOfMonth;
	  proto.day = proto.days = getSetDayOfWeek;
	  proto.weekday = getSetLocaleDayOfWeek;
	  proto.isoWeekday = getSetISODayOfWeek;
	  proto.dayOfYear = getSetDayOfYear;
	  proto.hour = proto.hours = getSetHour;
	  proto.minute = proto.minutes = getSetMinute;
	  proto.second = proto.seconds = getSetSecond;
	  proto.millisecond = proto.milliseconds = getSetMillisecond;
	  proto.utcOffset = getSetOffset;
	  proto.utc = setOffsetToUTC;
	  proto.local = setOffsetToLocal;
	  proto.parseZone = setOffsetToParsedOffset;
	  proto.hasAlignedHourOffset = hasAlignedHourOffset;
	  proto.isDST = isDaylightSavingTime;
	  proto.isLocal = isLocal;
	  proto.isUtcOffset = isUtcOffset;
	  proto.isUtc = isUtc;
	  proto.isUTC = isUtc;
	  proto.zoneAbbr = getZoneAbbr;
	  proto.zoneName = getZoneName;
	  proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
	  proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
	  proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
	  proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
	  proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

	  function createUnix(input) {
	    return createLocal(input * 1000);
	  }

	  function createInZone() {
	    return createLocal.apply(null, arguments).parseZone();
	  }

	  function preParsePostFormat(string) {
	    return string;
	  }

	  var proto$1 = Locale.prototype;
	  proto$1.calendar = calendar;
	  proto$1.longDateFormat = longDateFormat;
	  proto$1.invalidDate = invalidDate;
	  proto$1.ordinal = ordinal;
	  proto$1.preparse = preParsePostFormat;
	  proto$1.postformat = preParsePostFormat;
	  proto$1.relativeTime = relativeTime;
	  proto$1.pastFuture = pastFuture;
	  proto$1.set = set;
	  proto$1.months = localeMonths;
	  proto$1.monthsShort = localeMonthsShort;
	  proto$1.monthsParse = localeMonthsParse;
	  proto$1.monthsRegex = monthsRegex;
	  proto$1.monthsShortRegex = monthsShortRegex;
	  proto$1.week = localeWeek;
	  proto$1.firstDayOfYear = localeFirstDayOfYear;
	  proto$1.firstDayOfWeek = localeFirstDayOfWeek;
	  proto$1.weekdays = localeWeekdays;
	  proto$1.weekdaysMin = localeWeekdaysMin;
	  proto$1.weekdaysShort = localeWeekdaysShort;
	  proto$1.weekdaysParse = localeWeekdaysParse;
	  proto$1.weekdaysRegex = weekdaysRegex;
	  proto$1.weekdaysShortRegex = weekdaysShortRegex;
	  proto$1.weekdaysMinRegex = weekdaysMinRegex;
	  proto$1.isPM = localeIsPM;
	  proto$1.meridiem = localeMeridiem;

	  function get$1(format, index, field, setter) {
	    var locale = getLocale();
	    var utc = createUTC().set(setter, index);
	    return locale[field](utc, format);
	  }

	  function listMonthsImpl(format, index, field) {
	    if (isNumber(format)) {
	      index = format;
	      format = undefined;
	    }

	    format = format || '';

	    if (index != null) {
	      return get$1(format, index, field, 'month');
	    }

	    var i;
	    var out = [];

	    for (i = 0; i < 12; i++) {
	      out[i] = get$1(format, i, field, 'month');
	    }

	    return out;
	  } // ()
	  // (5)
	  // (fmt, 5)
	  // (fmt)
	  // (true)
	  // (true, 5)
	  // (true, fmt, 5)
	  // (true, fmt)


	  function listWeekdaysImpl(localeSorted, format, index, field) {
	    if (typeof localeSorted === 'boolean') {
	      if (isNumber(format)) {
	        index = format;
	        format = undefined;
	      }

	      format = format || '';
	    } else {
	      format = localeSorted;
	      index = format;
	      localeSorted = false;

	      if (isNumber(format)) {
	        index = format;
	        format = undefined;
	      }

	      format = format || '';
	    }

	    var locale = getLocale(),
	        shift = localeSorted ? locale._week.dow : 0;

	    if (index != null) {
	      return get$1(format, (index + shift) % 7, field, 'day');
	    }

	    var i;
	    var out = [];

	    for (i = 0; i < 7; i++) {
	      out[i] = get$1(format, (i + shift) % 7, field, 'day');
	    }

	    return out;
	  }

	  function listMonths(format, index) {
	    return listMonthsImpl(format, index, 'months');
	  }

	  function listMonthsShort(format, index) {
	    return listMonthsImpl(format, index, 'monthsShort');
	  }

	  function listWeekdays(localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
	  }

	  function listWeekdaysShort(localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
	  }

	  function listWeekdaysMin(localeSorted, format, index) {
	    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
	  }

	  getSetGlobalLocale('en', {
	    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
	    ordinal: function (number) {
	      var b = number % 10,
	          output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
	      return number + output;
	    }
	  }); // Side effect imports

	  hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
	  hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
	  var mathAbs = Math.abs;

	  function abs() {
	    var data = this._data;
	    this._milliseconds = mathAbs(this._milliseconds);
	    this._days = mathAbs(this._days);
	    this._months = mathAbs(this._months);
	    data.milliseconds = mathAbs(data.milliseconds);
	    data.seconds = mathAbs(data.seconds);
	    data.minutes = mathAbs(data.minutes);
	    data.hours = mathAbs(data.hours);
	    data.months = mathAbs(data.months);
	    data.years = mathAbs(data.years);
	    return this;
	  }

	  function addSubtract$1(duration, input, value, direction) {
	    var other = createDuration(input, value);
	    duration._milliseconds += direction * other._milliseconds;
	    duration._days += direction * other._days;
	    duration._months += direction * other._months;
	    return duration._bubble();
	  } // supports only 2.0-style add(1, 's') or add(duration)


	  function add$1(input, value) {
	    return addSubtract$1(this, input, value, 1);
	  } // supports only 2.0-style subtract(1, 's') or subtract(duration)


	  function subtract$1(input, value) {
	    return addSubtract$1(this, input, value, -1);
	  }

	  function absCeil(number) {
	    if (number < 0) {
	      return Math.floor(number);
	    } else {
	      return Math.ceil(number);
	    }
	  }

	  function bubble() {
	    var milliseconds = this._milliseconds;
	    var days = this._days;
	    var months = this._months;
	    var data = this._data;
	    var seconds, minutes, hours, years, monthsFromDays; // if we have a mix of positive and negative values, bubble down first
	    // check: https://github.com/moment/moment/issues/2166

	    if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
	      milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
	      days = 0;
	      months = 0;
	    } // The following code bubbles up values, see the tests for
	    // examples of what that means.


	    data.milliseconds = milliseconds % 1000;
	    seconds = absFloor(milliseconds / 1000);
	    data.seconds = seconds % 60;
	    minutes = absFloor(seconds / 60);
	    data.minutes = minutes % 60;
	    hours = absFloor(minutes / 60);
	    data.hours = hours % 24;
	    days += absFloor(hours / 24); // convert days to months

	    monthsFromDays = absFloor(daysToMonths(days));
	    months += monthsFromDays;
	    days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year

	    years = absFloor(months / 12);
	    months %= 12;
	    data.days = days;
	    data.months = months;
	    data.years = years;
	    return this;
	  }

	  function daysToMonths(days) {
	    // 400 years have 146097 days (taking into account leap year rules)
	    // 400 years have 12 months === 4800
	    return days * 4800 / 146097;
	  }

	  function monthsToDays(months) {
	    // the reverse of daysToMonths
	    return months * 146097 / 4800;
	  }

	  function as(units) {
	    if (!this.isValid()) {
	      return NaN;
	    }

	    var days;
	    var months;
	    var milliseconds = this._milliseconds;
	    units = normalizeUnits(units);

	    if (units === 'month' || units === 'quarter' || units === 'year') {
	      days = this._days + milliseconds / 864e5;
	      months = this._months + daysToMonths(days);

	      switch (units) {
	        case 'month':
	          return months;

	        case 'quarter':
	          return months / 3;

	        case 'year':
	          return months / 12;
	      }
	    } else {
	      // handle milliseconds separately because of floating point math errors (issue #1867)
	      days = this._days + Math.round(monthsToDays(this._months));

	      switch (units) {
	        case 'week':
	          return days / 7 + milliseconds / 6048e5;

	        case 'day':
	          return days + milliseconds / 864e5;

	        case 'hour':
	          return days * 24 + milliseconds / 36e5;

	        case 'minute':
	          return days * 1440 + milliseconds / 6e4;

	        case 'second':
	          return days * 86400 + milliseconds / 1000;
	        // Math.floor prevents floating point math errors here

	        case 'millisecond':
	          return Math.floor(days * 864e5) + milliseconds;

	        default:
	          throw new Error('Unknown unit ' + units);
	      }
	    }
	  } // TODO: Use this.as('ms')?


	  function valueOf$1() {
	    if (!this.isValid()) {
	      return NaN;
	    }

	    return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
	  }

	  function makeAs(alias) {
	    return function () {
	      return this.as(alias);
	    };
	  }

	  var asMilliseconds = makeAs('ms');
	  var asSeconds = makeAs('s');
	  var asMinutes = makeAs('m');
	  var asHours = makeAs('h');
	  var asDays = makeAs('d');
	  var asWeeks = makeAs('w');
	  var asMonths = makeAs('M');
	  var asQuarters = makeAs('Q');
	  var asYears = makeAs('y');

	  function clone$1() {
	    return createDuration(this);
	  }

	  function get$2(units) {
	    units = normalizeUnits(units);
	    return this.isValid() ? this[units + 's']() : NaN;
	  }

	  function makeGetter(name) {
	    return function () {
	      return this.isValid() ? this._data[name] : NaN;
	    };
	  }

	  var milliseconds = makeGetter('milliseconds');
	  var seconds = makeGetter('seconds');
	  var minutes = makeGetter('minutes');
	  var hours = makeGetter('hours');
	  var days = makeGetter('days');
	  var months = makeGetter('months');
	  var years = makeGetter('years');

	  function weeks() {
	    return absFloor(this.days() / 7);
	  }

	  var round = Math.round;
	  var thresholds = {
	    ss: 44,
	    // a few seconds to seconds
	    s: 45,
	    // seconds to minute
	    m: 45,
	    // minutes to hour
	    h: 22,
	    // hours to day
	    d: 26,
	    // days to month
	    M: 11 // months to year

	  }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

	  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
	    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
	  }

	  function relativeTime$1(posNegDuration, withoutSuffix, locale) {
	    var duration = createDuration(posNegDuration).abs();
	    var seconds = round(duration.as('s'));
	    var minutes = round(duration.as('m'));
	    var hours = round(duration.as('h'));
	    var days = round(duration.as('d'));
	    var months = round(duration.as('M'));
	    var years = round(duration.as('y'));
	    var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
	    a[2] = withoutSuffix;
	    a[3] = +posNegDuration > 0;
	    a[4] = locale;
	    return substituteTimeAgo.apply(null, a);
	  } // This function allows you to set the rounding function for relative time strings


	  function getSetRelativeTimeRounding(roundingFunction) {
	    if (roundingFunction === undefined) {
	      return round;
	    }

	    if (typeof roundingFunction === 'function') {
	      round = roundingFunction;
	      return true;
	    }

	    return false;
	  } // This function allows you to set a threshold for relative time strings


	  function getSetRelativeTimeThreshold(threshold, limit) {
	    if (thresholds[threshold] === undefined) {
	      return false;
	    }

	    if (limit === undefined) {
	      return thresholds[threshold];
	    }

	    thresholds[threshold] = limit;

	    if (threshold === 's') {
	      thresholds.ss = limit - 1;
	    }

	    return true;
	  }

	  function humanize(withSuffix) {
	    if (!this.isValid()) {
	      return this.localeData().invalidDate();
	    }

	    var locale = this.localeData();
	    var output = relativeTime$1(this, !withSuffix, locale);

	    if (withSuffix) {
	      output = locale.pastFuture(+this, output);
	    }

	    return locale.postformat(output);
	  }

	  var abs$1 = Math.abs;

	  function sign(x) {
	    return (x > 0) - (x < 0) || +x;
	  }

	  function toISOString$1() {
	    // for ISO strings we do not use the normal bubbling rules:
	    //  * milliseconds bubble up until they become hours
	    //  * days do not bubble at all
	    //  * months bubble up until they become years
	    // This is because there is no context-free conversion between hours and days
	    // (think of clock changes)
	    // and also not between days and months (28-31 days per month)
	    if (!this.isValid()) {
	      return this.localeData().invalidDate();
	    }

	    var seconds = abs$1(this._milliseconds) / 1000;
	    var days = abs$1(this._days);
	    var months = abs$1(this._months);
	    var minutes, hours, years; // 3600 seconds -> 60 minutes -> 1 hour

	    minutes = absFloor(seconds / 60);
	    hours = absFloor(minutes / 60);
	    seconds %= 60;
	    minutes %= 60; // 12 months -> 1 year

	    years = absFloor(months / 12);
	    months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js

	    var Y = years;
	    var M = months;
	    var D = days;
	    var h = hours;
	    var m = minutes;
	    var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
	    var total = this.asSeconds();

	    if (!total) {
	      // this is the same as C#'s (Noda) and python (isodate)...
	      // but not other JS (goog.date)
	      return 'P0D';
	    }

	    var totalSign = total < 0 ? '-' : '';
	    var ymSign = sign(this._months) !== sign(total) ? '-' : '';
	    var daysSign = sign(this._days) !== sign(total) ? '-' : '';
	    var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
	    return totalSign + 'P' + (Y ? ymSign + Y + 'Y' : '') + (M ? ymSign + M + 'M' : '') + (D ? daysSign + D + 'D' : '') + (h || m || s ? 'T' : '') + (h ? hmsSign + h + 'H' : '') + (m ? hmsSign + m + 'M' : '') + (s ? hmsSign + s + 'S' : '');
	  }

	  var proto$2 = Duration.prototype;
	  proto$2.isValid = isValid$1;
	  proto$2.abs = abs;
	  proto$2.add = add$1;
	  proto$2.subtract = subtract$1;
	  proto$2.as = as;
	  proto$2.asMilliseconds = asMilliseconds;
	  proto$2.asSeconds = asSeconds;
	  proto$2.asMinutes = asMinutes;
	  proto$2.asHours = asHours;
	  proto$2.asDays = asDays;
	  proto$2.asWeeks = asWeeks;
	  proto$2.asMonths = asMonths;
	  proto$2.asQuarters = asQuarters;
	  proto$2.asYears = asYears;
	  proto$2.valueOf = valueOf$1;
	  proto$2._bubble = bubble;
	  proto$2.clone = clone$1;
	  proto$2.get = get$2;
	  proto$2.milliseconds = milliseconds;
	  proto$2.seconds = seconds;
	  proto$2.minutes = minutes;
	  proto$2.hours = hours;
	  proto$2.days = days;
	  proto$2.weeks = weeks;
	  proto$2.months = months;
	  proto$2.years = years;
	  proto$2.humanize = humanize;
	  proto$2.toISOString = toISOString$1;
	  proto$2.toString = toISOString$1;
	  proto$2.toJSON = toISOString$1;
	  proto$2.locale = locale;
	  proto$2.localeData = localeData;
	  proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
	  proto$2.lang = lang; // Side effect imports
	  // FORMATTING

	  addFormatToken('X', 0, 0, 'unix');
	  addFormatToken('x', 0, 0, 'valueOf'); // PARSING

	  addRegexToken('x', matchSigned);
	  addRegexToken('X', matchTimestamp);
	  addParseToken('X', function (input, array, config) {
	    config._d = new Date(parseFloat(input, 10) * 1000);
	  });
	  addParseToken('x', function (input, array, config) {
	    config._d = new Date(toInt(input));
	  }); // Side effect imports

	  hooks.version = '2.24.0';
	  setHookCallback(createLocal);
	  hooks.fn = proto;
	  hooks.min = min;
	  hooks.max = max;
	  hooks.now = now;
	  hooks.utc = createUTC;
	  hooks.unix = createUnix;
	  hooks.months = listMonths;
	  hooks.isDate = isDate;
	  hooks.locale = getSetGlobalLocale;
	  hooks.invalid = createInvalid;
	  hooks.duration = createDuration;
	  hooks.isMoment = isMoment;
	  hooks.weekdays = listWeekdays;
	  hooks.parseZone = createInZone;
	  hooks.localeData = getLocale;
	  hooks.isDuration = isDuration;
	  hooks.monthsShort = listMonthsShort;
	  hooks.weekdaysMin = listWeekdaysMin;
	  hooks.defineLocale = defineLocale;
	  hooks.updateLocale = updateLocale;
	  hooks.locales = listLocales;
	  hooks.weekdaysShort = listWeekdaysShort;
	  hooks.normalizeUnits = normalizeUnits;
	  hooks.relativeTimeRounding = getSetRelativeTimeRounding;
	  hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
	  hooks.calendarFormat = getCalendarFormat;
	  hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats

	  hooks.HTML5_FMT = {
	    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
	    // <input type="datetime-local" />
	    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
	    // <input type="datetime-local" step="1" />
	    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
	    // <input type="datetime-local" step="0.001" />
	    DATE: 'YYYY-MM-DD',
	    // <input type="date" />
	    TIME: 'HH:mm',
	    // <input type="time" />
	    TIME_SECONDS: 'HH:mm:ss',
	    // <input type="time" step="1" />
	    TIME_MS: 'HH:mm:ss.SSS',
	    // <input type="time" step="0.001" />
	    WEEK: 'GGGG-[W]WW',
	    // <input type="week" />
	    MONTH: 'YYYY-MM' // <input type="month" />

	  };
	  return hooks;
	});
	});

	var flatpickr = createCommonjsModule(function (module, exports) {
	/* flatpickr v4.6.3, @license MIT */
	(function (global, factory) {
	   module.exports = factory() ;
	})(commonjsGlobal, function () {
	  /*! *****************************************************************************
	  Copyright (c) Microsoft Corporation. All rights reserved.
	  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	  this file except in compliance with the License. You may obtain a copy of the
	  License at http://www.apache.org/licenses/LICENSE-2.0
	    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	  MERCHANTABLITY OR NON-INFRINGEMENT.
	    See the Apache Version 2.0 License for specific language governing permissions
	  and limitations under the License.
	  ***************************************************************************** */

	  var __assign = function () {
	    __assign = Object.assign || function __assign(t) {
	      for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];

	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	      }

	      return t;
	    };

	    return __assign.apply(this, arguments);
	  };

	  var HOOKS = ["onChange", "onClose", "onDayCreate", "onDestroy", "onKeyDown", "onMonthChange", "onOpen", "onParseConfig", "onReady", "onValueUpdate", "onYearChange", "onPreCalendarPosition"];
	  var defaults = {
	    _disable: [],
	    _enable: [],
	    allowInput: false,
	    altFormat: "F j, Y",
	    altInput: false,
	    altInputClass: "form-control input",
	    animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
	    ariaDateFormat: "F j, Y",
	    clickOpens: true,
	    closeOnSelect: true,
	    conjunction: ", ",
	    dateFormat: "Y-m-d",
	    defaultHour: 12,
	    defaultMinute: 0,
	    defaultSeconds: 0,
	    disable: [],
	    disableMobile: false,
	    enable: [],
	    enableSeconds: false,
	    enableTime: false,
	    errorHandler: function (err) {
	      return typeof console !== "undefined" && console.warn(err);
	    },
	    getWeek: function (givenDate) {
	      var date = new Date(givenDate.getTime());
	      date.setHours(0, 0, 0, 0); // Thursday in current week decides the year.

	      date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7); // January 4 is always in week 1.

	      var week1 = new Date(date.getFullYear(), 0, 4); // Adjust to Thursday in week 1 and count number of weeks from date to week1.

	      return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
	    },
	    hourIncrement: 1,
	    ignoredFocusElements: [],
	    inline: false,
	    locale: "default",
	    minuteIncrement: 5,
	    mode: "single",
	    monthSelectorType: "dropdown",
	    nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
	    noCalendar: false,
	    now: new Date(),
	    onChange: [],
	    onClose: [],
	    onDayCreate: [],
	    onDestroy: [],
	    onKeyDown: [],
	    onMonthChange: [],
	    onOpen: [],
	    onParseConfig: [],
	    onReady: [],
	    onValueUpdate: [],
	    onYearChange: [],
	    onPreCalendarPosition: [],
	    plugins: [],
	    position: "auto",
	    positionElement: undefined,
	    prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
	    shorthandCurrentMonth: false,
	    showMonths: 1,
	    static: false,
	    time_24hr: false,
	    weekNumbers: false,
	    wrap: false
	  };
	  var english = {
	    weekdays: {
	      shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	      longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
	    },
	    months: {
	      shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
	      longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
	    },
	    daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
	    firstDayOfWeek: 0,
	    ordinal: function (nth) {
	      var s = nth % 100;
	      if (s > 3 && s < 21) return "th";

	      switch (s % 10) {
	        case 1:
	          return "st";

	        case 2:
	          return "nd";

	        case 3:
	          return "rd";

	        default:
	          return "th";
	      }
	    },
	    rangeSeparator: " to ",
	    weekAbbreviation: "Wk",
	    scrollTitle: "Scroll to increment",
	    toggleTitle: "Click to toggle",
	    amPM: ["AM", "PM"],
	    yearAriaLabel: "Year",
	    hourAriaLabel: "Hour",
	    minuteAriaLabel: "Minute",
	    time_24hr: false
	  };

	  var pad = function (number) {
	    return ("0" + number).slice(-2);
	  };

	  var int = function (bool) {
	    return bool === true ? 1 : 0;
	  };
	  /* istanbul ignore next */


	  function debounce(func, wait, immediate) {
	    if (immediate === void 0) {
	      immediate = false;
	    }

	    var timeout;
	    return function () {
	      var context = this,
	          args = arguments;
	      timeout !== null && clearTimeout(timeout);
	      timeout = window.setTimeout(function () {
	        timeout = null;
	        if (!immediate) func.apply(context, args);
	      }, wait);
	      if (immediate && !timeout) func.apply(context, args);
	    };
	  }

	  var arrayify = function (obj) {
	    return obj instanceof Array ? obj : [obj];
	  };

	  function toggleClass(elem, className, bool) {
	    if (bool === true) return elem.classList.add(className);
	    elem.classList.remove(className);
	  }

	  function createElement(tag, className, content) {
	    var e = window.document.createElement(tag);
	    className = className || "";
	    content = content || "";
	    e.className = className;
	    if (content !== undefined) e.textContent = content;
	    return e;
	  }

	  function clearNode(node) {
	    while (node.firstChild) node.removeChild(node.firstChild);
	  }

	  function findParent(node, condition) {
	    if (condition(node)) return node;else if (node.parentNode) return findParent(node.parentNode, condition);
	    return undefined; // nothing found
	  }

	  function createNumberInput(inputClassName, opts) {
	    var wrapper = createElement("div", "numInputWrapper"),
	        numInput = createElement("input", "numInput " + inputClassName),
	        arrowUp = createElement("span", "arrowUp"),
	        arrowDown = createElement("span", "arrowDown");

	    if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
	      numInput.type = "number";
	    } else {
	      numInput.type = "text";
	      numInput.pattern = "\\d*";
	    }

	    if (opts !== undefined) for (var key in opts) numInput.setAttribute(key, opts[key]);
	    wrapper.appendChild(numInput);
	    wrapper.appendChild(arrowUp);
	    wrapper.appendChild(arrowDown);
	    return wrapper;
	  }

	  function getEventTarget(event) {
	    if (typeof event.composedPath === "function") {
	      var path = event.composedPath();
	      return path[0];
	    }

	    return event.target;
	  }

	  var doNothing = function () {
	    return undefined;
	  };

	  var monthToStr = function (monthNumber, shorthand, locale) {
	    return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
	  };

	  var revFormat = {
	    D: doNothing,
	    F: function (dateObj, monthName, locale) {
	      dateObj.setMonth(locale.months.longhand.indexOf(monthName));
	    },
	    G: function (dateObj, hour) {
	      dateObj.setHours(parseFloat(hour));
	    },
	    H: function (dateObj, hour) {
	      dateObj.setHours(parseFloat(hour));
	    },
	    J: function (dateObj, day) {
	      dateObj.setDate(parseFloat(day));
	    },
	    K: function (dateObj, amPM, locale) {
	      dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
	    },
	    M: function (dateObj, shortMonth, locale) {
	      dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
	    },
	    S: function (dateObj, seconds) {
	      dateObj.setSeconds(parseFloat(seconds));
	    },
	    U: function (_, unixSeconds) {
	      return new Date(parseFloat(unixSeconds) * 1000);
	    },
	    W: function (dateObj, weekNum, locale) {
	      var weekNumber = parseInt(weekNum);
	      var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
	      date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
	      return date;
	    },
	    Y: function (dateObj, year) {
	      dateObj.setFullYear(parseFloat(year));
	    },
	    Z: function (_, ISODate) {
	      return new Date(ISODate);
	    },
	    d: function (dateObj, day) {
	      dateObj.setDate(parseFloat(day));
	    },
	    h: function (dateObj, hour) {
	      dateObj.setHours(parseFloat(hour));
	    },
	    i: function (dateObj, minutes) {
	      dateObj.setMinutes(parseFloat(minutes));
	    },
	    j: function (dateObj, day) {
	      dateObj.setDate(parseFloat(day));
	    },
	    l: doNothing,
	    m: function (dateObj, month) {
	      dateObj.setMonth(parseFloat(month) - 1);
	    },
	    n: function (dateObj, month) {
	      dateObj.setMonth(parseFloat(month) - 1);
	    },
	    s: function (dateObj, seconds) {
	      dateObj.setSeconds(parseFloat(seconds));
	    },
	    u: function (_, unixMillSeconds) {
	      return new Date(parseFloat(unixMillSeconds));
	    },
	    w: doNothing,
	    y: function (dateObj, year) {
	      dateObj.setFullYear(2000 + parseFloat(year));
	    }
	  };
	  var tokenRegex = {
	    D: "(\\w+)",
	    F: "(\\w+)",
	    G: "(\\d\\d|\\d)",
	    H: "(\\d\\d|\\d)",
	    J: "(\\d\\d|\\d)\\w+",
	    K: "",
	    M: "(\\w+)",
	    S: "(\\d\\d|\\d)",
	    U: "(.+)",
	    W: "(\\d\\d|\\d)",
	    Y: "(\\d{4})",
	    Z: "(.+)",
	    d: "(\\d\\d|\\d)",
	    h: "(\\d\\d|\\d)",
	    i: "(\\d\\d|\\d)",
	    j: "(\\d\\d|\\d)",
	    l: "(\\w+)",
	    m: "(\\d\\d|\\d)",
	    n: "(\\d\\d|\\d)",
	    s: "(\\d\\d|\\d)",
	    u: "(.+)",
	    w: "(\\d\\d|\\d)",
	    y: "(\\d{2})"
	  };
	  var formats = {
	    // get the date in UTC
	    Z: function (date) {
	      return date.toISOString();
	    },
	    // weekday name, short, e.g. Thu
	    D: function (date, locale, options) {
	      return locale.weekdays.shorthand[formats.w(date, locale, options)];
	    },
	    // full month name e.g. January
	    F: function (date, locale, options) {
	      return monthToStr(formats.n(date, locale, options) - 1, false, locale);
	    },
	    // padded hour 1-12
	    G: function (date, locale, options) {
	      return pad(formats.h(date, locale, options));
	    },
	    // hours with leading zero e.g. 03
	    H: function (date) {
	      return pad(date.getHours());
	    },
	    // day (1-30) with ordinal suffix e.g. 1st, 2nd
	    J: function (date, locale) {
	      return locale.ordinal !== undefined ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
	    },
	    // AM/PM
	    K: function (date, locale) {
	      return locale.amPM[int(date.getHours() > 11)];
	    },
	    // shorthand month e.g. Jan, Sep, Oct, etc
	    M: function (date, locale) {
	      return monthToStr(date.getMonth(), true, locale);
	    },
	    // seconds 00-59
	    S: function (date) {
	      return pad(date.getSeconds());
	    },
	    // unix timestamp
	    U: function (date) {
	      return date.getTime() / 1000;
	    },
	    W: function (date, _, options) {
	      return options.getWeek(date);
	    },
	    // full year e.g. 2016
	    Y: function (date) {
	      return date.getFullYear();
	    },
	    // day in month, padded (01-30)
	    d: function (date) {
	      return pad(date.getDate());
	    },
	    // hour from 1-12 (am/pm)
	    h: function (date) {
	      return date.getHours() % 12 ? date.getHours() % 12 : 12;
	    },
	    // minutes, padded with leading zero e.g. 09
	    i: function (date) {
	      return pad(date.getMinutes());
	    },
	    // day in month (1-30)
	    j: function (date) {
	      return date.getDate();
	    },
	    // weekday name, full, e.g. Thursday
	    l: function (date, locale) {
	      return locale.weekdays.longhand[date.getDay()];
	    },
	    // padded month number (01-12)
	    m: function (date) {
	      return pad(date.getMonth() + 1);
	    },
	    // the month number (1-12)
	    n: function (date) {
	      return date.getMonth() + 1;
	    },
	    // seconds 0-59
	    s: function (date) {
	      return date.getSeconds();
	    },
	    // Unix Milliseconds
	    u: function (date) {
	      return date.getTime();
	    },
	    // number of the day of the week
	    w: function (date) {
	      return date.getDay();
	    },
	    // last two digits of year e.g. 16 for 2016
	    y: function (date) {
	      return String(date.getFullYear()).substring(2);
	    }
	  };

	  var createDateFormatter = function (_a) {
	    var _b = _a.config,
	        config = _b === void 0 ? defaults : _b,
	        _c = _a.l10n,
	        l10n = _c === void 0 ? english : _c;
	    return function (dateObj, frmt, overrideLocale) {
	      var locale = overrideLocale || l10n;

	      if (config.formatDate !== undefined) {
	        return config.formatDate(dateObj, frmt, locale);
	      }

	      return frmt.split("").map(function (c, i, arr) {
	        return formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale, config) : c !== "\\" ? c : "";
	      }).join("");
	    };
	  };

	  var createDateParser = function (_a) {
	    var _b = _a.config,
	        config = _b === void 0 ? defaults : _b,
	        _c = _a.l10n,
	        l10n = _c === void 0 ? english : _c;
	    return function (date, givenFormat, timeless, customLocale) {
	      if (date !== 0 && !date) return undefined;
	      var locale = customLocale || l10n;
	      var parsedDate;
	      var dateOrig = date;
	      if (date instanceof Date) parsedDate = new Date(date.getTime());else if (typeof date !== "string" && date.toFixed !== undefined // timestamp
	      ) // create a copy
	        parsedDate = new Date(date);else if (typeof date === "string") {
	        // date string
	        var format = givenFormat || (config || defaults).dateFormat;
	        var datestr = String(date).trim();

	        if (datestr === "today") {
	          parsedDate = new Date();
	          timeless = true;
	        } else if (/Z$/.test(datestr) || /GMT$/.test(datestr) // datestrings w/ timezone
	        ) parsedDate = new Date(date);else if (config && config.parseDate) parsedDate = config.parseDate(date, format);else {
	          parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
	          var matched = void 0,
	              ops = [];

	          for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
	            var token_1 = format[i];
	            var isBackSlash = token_1 === "\\";
	            var escaped = format[i - 1] === "\\" || isBackSlash;

	            if (tokenRegex[token_1] && !escaped) {
	              regexStr += tokenRegex[token_1];
	              var match = new RegExp(regexStr).exec(date);

	              if (match && (matched = true)) {
	                ops[token_1 !== "Y" ? "push" : "unshift"]({
	                  fn: revFormat[token_1],
	                  val: match[++matchIndex]
	                });
	              }
	            } else if (!isBackSlash) regexStr += "."; // don't really care


	            ops.forEach(function (_a) {
	              var fn = _a.fn,
	                  val = _a.val;
	              return parsedDate = fn(parsedDate, val, locale) || parsedDate;
	            });
	          }

	          parsedDate = matched ? parsedDate : undefined;
	        }
	      }
	      /* istanbul ignore next */

	      if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
	        config.errorHandler(new Error("Invalid date provided: " + dateOrig));
	        return undefined;
	      }

	      if (timeless === true) parsedDate.setHours(0, 0, 0, 0);
	      return parsedDate;
	    };
	  };
	  /**
	   * Compute the difference in dates, measured in ms
	   */


	  function compareDates(date1, date2, timeless) {
	    if (timeless === void 0) {
	      timeless = true;
	    }

	    if (timeless !== false) {
	      return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
	    }

	    return date1.getTime() - date2.getTime();
	  }

	  var isBetween = function (ts, ts1, ts2) {
	    return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
	  };

	  var duration = {
	    DAY: 86400000
	  };

	  if (typeof Object.assign !== "function") {
	    Object.assign = function (target) {
	      var args = [];

	      for (var _i = 1; _i < arguments.length; _i++) {
	        args[_i - 1] = arguments[_i];
	      }

	      if (!target) {
	        throw TypeError("Cannot convert undefined or null to object");
	      }

	      var _loop_1 = function (source) {
	        if (source) {
	          Object.keys(source).forEach(function (key) {
	            return target[key] = source[key];
	          });
	        }
	      };

	      for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
	        var source = args_1[_a];

	        _loop_1(source);
	      }

	      return target;
	    };
	  }

	  var DEBOUNCED_CHANGE_MS = 300;

	  function FlatpickrInstance(element, instanceConfig) {
	    var self = {
	      config: __assign({}, defaults, flatpickr.defaultConfig),
	      l10n: english
	    };
	    self.parseDate = createDateParser({
	      config: self.config,
	      l10n: self.l10n
	    });
	    self._handlers = [];
	    self.pluginElements = [];
	    self.loadedPlugins = [];
	    self._bind = bind;
	    self._setHoursFromDate = setHoursFromDate;
	    self._positionCalendar = positionCalendar;
	    self.changeMonth = changeMonth;
	    self.changeYear = changeYear;
	    self.clear = clear;
	    self.close = close;
	    self._createElement = createElement;
	    self.destroy = destroy;
	    self.isEnabled = isEnabled;
	    self.jumpToDate = jumpToDate;
	    self.open = open;
	    self.redraw = redraw;
	    self.set = set;
	    self.setDate = setDate;
	    self.toggle = toggle;

	    function setupHelperFunctions() {
	      self.utils = {
	        getDaysInMonth: function (month, yr) {
	          if (month === void 0) {
	            month = self.currentMonth;
	          }

	          if (yr === void 0) {
	            yr = self.currentYear;
	          }

	          if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;
	          return self.l10n.daysInMonth[month];
	        }
	      };
	    }

	    function init() {
	      self.element = self.input = element;
	      self.isOpen = false;
	      parseConfig();
	      setupLocale();
	      setupInputs();
	      setupDates();
	      setupHelperFunctions();
	      if (!self.isMobile) build();
	      bindEvents();

	      if (self.selectedDates.length || self.config.noCalendar) {
	        if (self.config.enableTime) {
	          setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj || self.config.minDate : undefined);
	        }

	        updateValue(false);
	      }

	      setCalendarWidth();
	      self.showTimeInput = self.selectedDates.length > 0 || self.config.noCalendar;
	      var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
	      /* TODO: investigate this further
	                 Currently, there is weird positioning behavior in safari causing pages
	        to scroll up. https://github.com/chmln/flatpickr/issues/563
	                 However, most browsers are not Safari and positioning is expensive when used
	        in scale. https://github.com/chmln/flatpickr/issues/1096
	      */

	      if (!self.isMobile && isSafari) {
	        positionCalendar();
	      }

	      triggerEvent("onReady");
	    }

	    function bindToInstance(fn) {
	      return fn.bind(self);
	    }

	    function setCalendarWidth() {
	      var config = self.config;
	      if (config.weekNumbers === false && config.showMonths === 1) return;else if (config.noCalendar !== true) {
	        window.requestAnimationFrame(function () {
	          if (self.calendarContainer !== undefined) {
	            self.calendarContainer.style.visibility = "hidden";
	            self.calendarContainer.style.display = "block";
	          }

	          if (self.daysContainer !== undefined) {
	            var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
	            self.daysContainer.style.width = daysWidth + "px";
	            self.calendarContainer.style.width = daysWidth + (self.weekWrapper !== undefined ? self.weekWrapper.offsetWidth : 0) + "px";
	            self.calendarContainer.style.removeProperty("visibility");
	            self.calendarContainer.style.removeProperty("display");
	          }
	        });
	      }
	    }
	    /**
	     * The handler for all events targeting the time inputs
	     */


	    function updateTime(e) {
	      if (self.selectedDates.length === 0) {
	        setDefaultTime();
	      }

	      if (e !== undefined && e.type !== "blur") {
	        timeWrapper(e);
	      }

	      var prevValue = self._input.value;
	      setHoursFromInputs();
	      updateValue();

	      if (self._input.value !== prevValue) {
	        self._debouncedChange();
	      }
	    }

	    function ampm2military(hour, amPM) {
	      return hour % 12 + 12 * int(amPM === self.l10n.amPM[1]);
	    }

	    function military2ampm(hour) {
	      switch (hour % 24) {
	        case 0:
	        case 12:
	          return 12;

	        default:
	          return hour % 12;
	      }
	    }
	    /**
	     * Syncs the selected date object time with user's time input
	     */


	    function setHoursFromInputs() {
	      if (self.hourElement === undefined || self.minuteElement === undefined) return;
	      var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24,
	          minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60,
	          seconds = self.secondElement !== undefined ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;

	      if (self.amPM !== undefined) {
	        hours = ampm2military(hours, self.amPM.textContent);
	      }

	      var limitMinHours = self.config.minTime !== undefined || self.config.minDate && self.minDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.minDate, true) === 0;
	      var limitMaxHours = self.config.maxTime !== undefined || self.config.maxDate && self.maxDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.maxDate, true) === 0;

	      if (limitMaxHours) {
	        var maxTime = self.config.maxTime !== undefined ? self.config.maxTime : self.config.maxDate;
	        hours = Math.min(hours, maxTime.getHours());
	        if (hours === maxTime.getHours()) minutes = Math.min(minutes, maxTime.getMinutes());
	        if (minutes === maxTime.getMinutes()) seconds = Math.min(seconds, maxTime.getSeconds());
	      }

	      if (limitMinHours) {
	        var minTime = self.config.minTime !== undefined ? self.config.minTime : self.config.minDate;
	        hours = Math.max(hours, minTime.getHours());
	        if (hours === minTime.getHours()) minutes = Math.max(minutes, minTime.getMinutes());
	        if (minutes === minTime.getMinutes()) seconds = Math.max(seconds, minTime.getSeconds());
	      }

	      setHours(hours, minutes, seconds);
	    }
	    /**
	     * Syncs time input values with a date
	     */


	    function setHoursFromDate(dateObj) {
	      var date = dateObj || self.latestSelectedDateObj;
	      if (date) setHours(date.getHours(), date.getMinutes(), date.getSeconds());
	    }

	    function setDefaultHours() {
	      var hours = self.config.defaultHour;
	      var minutes = self.config.defaultMinute;
	      var seconds = self.config.defaultSeconds;

	      if (self.config.minDate !== undefined) {
	        var minHr = self.config.minDate.getHours();
	        var minMinutes = self.config.minDate.getMinutes();
	        hours = Math.max(hours, minHr);
	        if (hours === minHr) minutes = Math.max(minMinutes, minutes);
	        if (hours === minHr && minutes === minMinutes) seconds = self.config.minDate.getSeconds();
	      }

	      if (self.config.maxDate !== undefined) {
	        var maxHr = self.config.maxDate.getHours();
	        var maxMinutes = self.config.maxDate.getMinutes();
	        hours = Math.min(hours, maxHr);
	        if (hours === maxHr) minutes = Math.min(maxMinutes, minutes);
	        if (hours === maxHr && minutes === maxMinutes) seconds = self.config.maxDate.getSeconds();
	      }

	      setHours(hours, minutes, seconds);
	    }
	    /**
	     * Sets the hours, minutes, and optionally seconds
	     * of the latest selected date object and the
	     * corresponding time inputs
	     * @param {Number} hours the hour. whether its military
	     *                 or am-pm gets inferred from config
	     * @param {Number} minutes the minutes
	     * @param {Number} seconds the seconds (optional)
	     */


	    function setHours(hours, minutes, seconds) {
	      if (self.latestSelectedDateObj !== undefined) {
	        self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
	      }

	      if (!self.hourElement || !self.minuteElement || self.isMobile) return;
	      self.hourElement.value = pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
	      self.minuteElement.value = pad(minutes);
	      if (self.amPM !== undefined) self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
	      if (self.secondElement !== undefined) self.secondElement.value = pad(seconds);
	    }
	    /**
	     * Handles the year input and incrementing events
	     * @param {Event} event the keyup or increment event
	     */


	    function onYearInput(event) {
	      var year = parseInt(event.target.value) + (event.delta || 0);

	      if (year / 1000 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
	        changeYear(year);
	      }
	    }
	    /**
	     * Essentially addEventListener + tracking
	     * @param {Element} element the element to addEventListener to
	     * @param {String} event the event name
	     * @param {Function} handler the event handler
	     */


	    function bind(element, event, handler, options) {
	      if (event instanceof Array) return event.forEach(function (ev) {
	        return bind(element, ev, handler, options);
	      });
	      if (element instanceof Array) return element.forEach(function (el) {
	        return bind(el, event, handler, options);
	      });
	      element.addEventListener(event, handler, options);

	      self._handlers.push({
	        element: element,
	        event: event,
	        handler: handler,
	        options: options
	      });
	    }
	    /**
	     * A mousedown handler which mimics click.
	     * Minimizes latency, since we don't need to wait for mouseup in most cases.
	     * Also, avoids handling right clicks.
	     *
	     * @param {Function} handler the event handler
	     */


	    function onClick(handler) {
	      return function (evt) {
	        evt.which === 1 && handler(evt);
	      };
	    }

	    function triggerChange() {
	      triggerEvent("onChange");
	    }
	    /**
	     * Adds all the necessary event listeners
	     */


	    function bindEvents() {
	      if (self.config.wrap) {
	        ["open", "close", "toggle", "clear"].forEach(function (evt) {
	          Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
	            return bind(el, "click", self[evt]);
	          });
	        });
	      }

	      if (self.isMobile) {
	        setupMobile();
	        return;
	      }

	      var debouncedResize = debounce(onResize, 50);
	      self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
	      if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent)) bind(self.daysContainer, "mouseover", function (e) {
	        if (self.config.mode === "range") onMouseOver(e.target);
	      });
	      bind(window.document.body, "keydown", onKeyDown);
	      if (!self.config.inline && !self.config.static) bind(window, "resize", debouncedResize);
	      if (window.ontouchstart !== undefined) bind(window.document, "touchstart", documentClick);else bind(window.document, "mousedown", onClick(documentClick));
	      bind(window.document, "focus", documentClick, {
	        capture: true
	      });

	      if (self.config.clickOpens === true) {
	        bind(self._input, "focus", self.open);
	        bind(self._input, "mousedown", onClick(self.open));
	      }

	      if (self.daysContainer !== undefined) {
	        bind(self.monthNav, "mousedown", onClick(onMonthNavClick));
	        bind(self.monthNav, ["keyup", "increment"], onYearInput);
	        bind(self.daysContainer, "mousedown", onClick(selectDate));
	      }

	      if (self.timeContainer !== undefined && self.minuteElement !== undefined && self.hourElement !== undefined) {
	        var selText = function (e) {
	          return e.target.select();
	        };

	        bind(self.timeContainer, ["increment"], updateTime);
	        bind(self.timeContainer, "blur", updateTime, {
	          capture: true
	        });
	        bind(self.timeContainer, "mousedown", onClick(timeIncrement));
	        bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
	        if (self.secondElement !== undefined) bind(self.secondElement, "focus", function () {
	          return self.secondElement && self.secondElement.select();
	        });

	        if (self.amPM !== undefined) {
	          bind(self.amPM, "mousedown", onClick(function (e) {
	            updateTime(e);
	            triggerChange();
	          }));
	        }
	      }
	    }
	    /**
	     * Set the calendar view to a particular date.
	     * @param {Date} jumpDate the date to set the view to
	     * @param {boolean} triggerChange if change events should be triggered
	     */


	    function jumpToDate(jumpDate, triggerChange) {
	      var jumpTo = jumpDate !== undefined ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate && self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);
	      var oldYear = self.currentYear;
	      var oldMonth = self.currentMonth;

	      try {
	        if (jumpTo !== undefined) {
	          self.currentYear = jumpTo.getFullYear();
	          self.currentMonth = jumpTo.getMonth();
	        }
	      } catch (e) {
	        /* istanbul ignore next */
	        e.message = "Invalid date supplied: " + jumpTo;
	        self.config.errorHandler(e);
	      }

	      if (triggerChange && self.currentYear !== oldYear) {
	        triggerEvent("onYearChange");
	        buildMonthSwitch();
	      }

	      if (triggerChange && (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
	        triggerEvent("onMonthChange");
	      }

	      self.redraw();
	    }
	    /**
	     * The up/down arrow handler for time inputs
	     * @param {Event} e the click event
	     */


	    function timeIncrement(e) {
	      if (~e.target.className.indexOf("arrow")) incrementNumInput(e, e.target.classList.contains("arrowUp") ? 1 : -1);
	    }
	    /**
	     * Increments/decrements the value of input associ-
	     * ated with the up/down arrow by dispatching an
	     * "increment" event on the input.
	     *
	     * @param {Event} e the click event
	     * @param {Number} delta the diff (usually 1 or -1)
	     * @param {Element} inputElem the input element
	     */


	    function incrementNumInput(e, delta, inputElem) {
	      var target = e && e.target;
	      var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
	      var event = createEvent("increment");
	      event.delta = delta;
	      input && input.dispatchEvent(event);
	    }

	    function build() {
	      var fragment = window.document.createDocumentFragment();
	      self.calendarContainer = createElement("div", "flatpickr-calendar");
	      self.calendarContainer.tabIndex = -1;

	      if (!self.config.noCalendar) {
	        fragment.appendChild(buildMonthNav());
	        self.innerContainer = createElement("div", "flatpickr-innerContainer");

	        if (self.config.weekNumbers) {
	          var _a = buildWeeks(),
	              weekWrapper = _a.weekWrapper,
	              weekNumbers = _a.weekNumbers;

	          self.innerContainer.appendChild(weekWrapper);
	          self.weekNumbers = weekNumbers;
	          self.weekWrapper = weekWrapper;
	        }

	        self.rContainer = createElement("div", "flatpickr-rContainer");
	        self.rContainer.appendChild(buildWeekdays());

	        if (!self.daysContainer) {
	          self.daysContainer = createElement("div", "flatpickr-days");
	          self.daysContainer.tabIndex = -1;
	        }

	        buildDays();
	        self.rContainer.appendChild(self.daysContainer);
	        self.innerContainer.appendChild(self.rContainer);
	        fragment.appendChild(self.innerContainer);
	      }

	      if (self.config.enableTime) {
	        fragment.appendChild(buildTime());
	      }

	      toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
	      toggleClass(self.calendarContainer, "animate", self.config.animate === true);
	      toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
	      self.calendarContainer.appendChild(fragment);
	      var customAppend = self.config.appendTo !== undefined && self.config.appendTo.nodeType !== undefined;

	      if (self.config.inline || self.config.static) {
	        self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");

	        if (self.config.inline) {
	          if (!customAppend && self.element.parentNode) self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);else if (self.config.appendTo !== undefined) self.config.appendTo.appendChild(self.calendarContainer);
	        }

	        if (self.config.static) {
	          var wrapper = createElement("div", "flatpickr-wrapper");
	          if (self.element.parentNode) self.element.parentNode.insertBefore(wrapper, self.element);
	          wrapper.appendChild(self.element);
	          if (self.altInput) wrapper.appendChild(self.altInput);
	          wrapper.appendChild(self.calendarContainer);
	        }
	      }

	      if (!self.config.static && !self.config.inline) (self.config.appendTo !== undefined ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);
	    }

	    function createDay(className, date, dayNumber, i) {
	      var dateIsEnabled = isEnabled(date, true),
	          dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
	      dayElement.dateObj = date;
	      dayElement.$i = i;
	      dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));

	      if (className.indexOf("hidden") === -1 && compareDates(date, self.now) === 0) {
	        self.todayDateElem = dayElement;
	        dayElement.classList.add("today");
	        dayElement.setAttribute("aria-current", "date");
	      }

	      if (dateIsEnabled) {
	        dayElement.tabIndex = -1;

	        if (isDateSelected(date)) {
	          dayElement.classList.add("selected");
	          self.selectedDateElem = dayElement;

	          if (self.config.mode === "range") {
	            toggleClass(dayElement, "startRange", self.selectedDates[0] && compareDates(date, self.selectedDates[0], true) === 0);
	            toggleClass(dayElement, "endRange", self.selectedDates[1] && compareDates(date, self.selectedDates[1], true) === 0);
	            if (className === "nextMonthDay") dayElement.classList.add("inRange");
	          }
	        }
	      } else {
	        dayElement.classList.add("flatpickr-disabled");
	      }

	      if (self.config.mode === "range") {
	        if (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add("inRange");
	      }

	      if (self.weekNumbers && self.config.showMonths === 1 && className !== "prevMonthDay" && dayNumber % 7 === 1) {
	        self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
	      }

	      triggerEvent("onDayCreate", dayElement);
	      return dayElement;
	    }

	    function focusOnDayElem(targetNode) {
	      targetNode.focus();
	      if (self.config.mode === "range") onMouseOver(targetNode);
	    }

	    function getFirstAvailableDay(delta) {
	      var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
	      var endMonth = delta > 0 ? self.config.showMonths : -1;

	      for (var m = startMonth; m != endMonth; m += delta) {
	        var month = self.daysContainer.children[m];
	        var startIndex = delta > 0 ? 0 : month.children.length - 1;
	        var endIndex = delta > 0 ? month.children.length : -1;

	        for (var i = startIndex; i != endIndex; i += delta) {
	          var c = month.children[i];
	          if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj)) return c;
	        }
	      }

	      return undefined;
	    }

	    function getNextAvailableDay(current, delta) {
	      var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self.currentMonth;
	      var endMonth = delta > 0 ? self.config.showMonths : -1;
	      var loopDelta = delta > 0 ? 1 : -1;

	      for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
	        var month = self.daysContainer.children[m];
	        var startIndex = givenMonth - self.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
	        var numMonthDays = month.children.length;

	        for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
	          var c = month.children[i];
	          if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta)) return focusOnDayElem(c);
	        }
	      }

	      self.changeMonth(loopDelta);
	      focusOnDay(getFirstAvailableDay(loopDelta), 0);
	      return undefined;
	    }

	    function focusOnDay(current, offset) {
	      var dayFocused = isInView(document.activeElement || document.body);
	      var startElem = current !== undefined ? current : dayFocused ? document.activeElement : self.selectedDateElem !== undefined && isInView(self.selectedDateElem) ? self.selectedDateElem : self.todayDateElem !== undefined && isInView(self.todayDateElem) ? self.todayDateElem : getFirstAvailableDay(offset > 0 ? 1 : -1);
	      if (startElem === undefined) return self._input.focus();
	      if (!dayFocused) return focusOnDayElem(startElem);
	      getNextAvailableDay(startElem, offset);
	    }

	    function buildMonthDays(year, month) {
	      var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
	      var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12);
	      var daysInMonth = self.utils.getDaysInMonth(month),
	          days = window.document.createDocumentFragment(),
	          isMultiMonth = self.config.showMonths > 1,
	          prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay",
	          nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
	      var dayNumber = prevMonthDays + 1 - firstOfMonth,
	          dayIndex = 0; // prepend days from the ending of previous month

	      for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
	        days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
	      } // Start at 1 since there is no 0th day


	      for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
	        days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
	      } // append days from the next month


	      for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
	        days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
	      } //updateNavigationCurrentMonth();


	      var dayContainer = createElement("div", "dayContainer");
	      dayContainer.appendChild(days);
	      return dayContainer;
	    }

	    function buildDays() {
	      if (self.daysContainer === undefined) {
	        return;
	      }

	      clearNode(self.daysContainer); // TODO: week numbers for each month

	      if (self.weekNumbers) clearNode(self.weekNumbers);
	      var frag = document.createDocumentFragment();

	      for (var i = 0; i < self.config.showMonths; i++) {
	        var d = new Date(self.currentYear, self.currentMonth, 1);
	        d.setMonth(self.currentMonth + i);
	        frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
	      }

	      self.daysContainer.appendChild(frag);
	      self.days = self.daysContainer.firstChild;

	      if (self.config.mode === "range" && self.selectedDates.length === 1) {
	        onMouseOver();
	      }
	    }

	    function buildMonthSwitch() {
	      if (self.config.showMonths > 1 || self.config.monthSelectorType !== "dropdown") return;

	      var shouldBuildMonth = function (month) {
	        if (self.config.minDate !== undefined && self.currentYear === self.config.minDate.getFullYear() && month < self.config.minDate.getMonth()) {
	          return false;
	        }

	        return !(self.config.maxDate !== undefined && self.currentYear === self.config.maxDate.getFullYear() && month > self.config.maxDate.getMonth());
	      };

	      self.monthsDropdownContainer.tabIndex = -1;
	      self.monthsDropdownContainer.innerHTML = "";

	      for (var i = 0; i < 12; i++) {
	        if (!shouldBuildMonth(i)) continue;
	        var month = createElement("option", "flatpickr-monthDropdown-month");
	        month.value = new Date(self.currentYear, i).getMonth().toString();
	        month.textContent = monthToStr(i, self.config.shorthandCurrentMonth, self.l10n);
	        month.tabIndex = -1;

	        if (self.currentMonth === i) {
	          month.selected = true;
	        }

	        self.monthsDropdownContainer.appendChild(month);
	      }
	    }

	    function buildMonth() {
	      var container = createElement("div", "flatpickr-month");
	      var monthNavFragment = window.document.createDocumentFragment();
	      var monthElement;

	      if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
	        monthElement = createElement("span", "cur-month");
	      } else {
	        self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
	        bind(self.monthsDropdownContainer, "change", function (e) {
	          var target = e.target;
	          var selectedMonth = parseInt(target.value, 10);
	          self.changeMonth(selectedMonth - self.currentMonth);
	          triggerEvent("onMonthChange");
	        });
	        buildMonthSwitch();
	        monthElement = self.monthsDropdownContainer;
	      }

	      var yearInput = createNumberInput("cur-year", {
	        tabindex: "-1"
	      });
	      var yearElement = yearInput.getElementsByTagName("input")[0];
	      yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);

	      if (self.config.minDate) {
	        yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
	      }

	      if (self.config.maxDate) {
	        yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
	        yearElement.disabled = !!self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
	      }

	      var currentMonth = createElement("div", "flatpickr-current-month");
	      currentMonth.appendChild(monthElement);
	      currentMonth.appendChild(yearInput);
	      monthNavFragment.appendChild(currentMonth);
	      container.appendChild(monthNavFragment);
	      return {
	        container: container,
	        yearElement: yearElement,
	        monthElement: monthElement
	      };
	    }

	    function buildMonths() {
	      clearNode(self.monthNav);
	      self.monthNav.appendChild(self.prevMonthNav);

	      if (self.config.showMonths) {
	        self.yearElements = [];
	        self.monthElements = [];
	      }

	      for (var m = self.config.showMonths; m--;) {
	        var month = buildMonth();
	        self.yearElements.push(month.yearElement);
	        self.monthElements.push(month.monthElement);
	        self.monthNav.appendChild(month.container);
	      }

	      self.monthNav.appendChild(self.nextMonthNav);
	    }

	    function buildMonthNav() {
	      self.monthNav = createElement("div", "flatpickr-months");
	      self.yearElements = [];
	      self.monthElements = [];
	      self.prevMonthNav = createElement("span", "flatpickr-prev-month");
	      self.prevMonthNav.innerHTML = self.config.prevArrow;
	      self.nextMonthNav = createElement("span", "flatpickr-next-month");
	      self.nextMonthNav.innerHTML = self.config.nextArrow;
	      buildMonths();
	      Object.defineProperty(self, "_hidePrevMonthArrow", {
	        get: function () {
	          return self.__hidePrevMonthArrow;
	        },
	        set: function (bool) {
	          if (self.__hidePrevMonthArrow !== bool) {
	            toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
	            self.__hidePrevMonthArrow = bool;
	          }
	        }
	      });
	      Object.defineProperty(self, "_hideNextMonthArrow", {
	        get: function () {
	          return self.__hideNextMonthArrow;
	        },
	        set: function (bool) {
	          if (self.__hideNextMonthArrow !== bool) {
	            toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
	            self.__hideNextMonthArrow = bool;
	          }
	        }
	      });
	      self.currentYearElement = self.yearElements[0];
	      updateNavigationCurrentMonth();
	      return self.monthNav;
	    }

	    function buildTime() {
	      self.calendarContainer.classList.add("hasTime");
	      if (self.config.noCalendar) self.calendarContainer.classList.add("noCalendar");
	      self.timeContainer = createElement("div", "flatpickr-time");
	      self.timeContainer.tabIndex = -1;
	      var separator = createElement("span", "flatpickr-time-separator", ":");
	      var hourInput = createNumberInput("flatpickr-hour", {
	        "aria-label": self.l10n.hourAriaLabel
	      });
	      self.hourElement = hourInput.getElementsByTagName("input")[0];
	      var minuteInput = createNumberInput("flatpickr-minute", {
	        "aria-label": self.l10n.minuteAriaLabel
	      });
	      self.minuteElement = minuteInput.getElementsByTagName("input")[0];
	      self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
	      self.hourElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.time_24hr ? self.config.defaultHour : military2ampm(self.config.defaultHour));
	      self.minuteElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : self.config.defaultMinute);
	      self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
	      self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
	      self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
	      self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
	      self.minuteElement.setAttribute("min", "0");
	      self.minuteElement.setAttribute("max", "59");
	      self.timeContainer.appendChild(hourInput);
	      self.timeContainer.appendChild(separator);
	      self.timeContainer.appendChild(minuteInput);
	      if (self.config.time_24hr) self.timeContainer.classList.add("time24hr");

	      if (self.config.enableSeconds) {
	        self.timeContainer.classList.add("hasSeconds");
	        var secondInput = createNumberInput("flatpickr-second");
	        self.secondElement = secondInput.getElementsByTagName("input")[0];
	        self.secondElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : self.config.defaultSeconds);
	        self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
	        self.secondElement.setAttribute("min", "0");
	        self.secondElement.setAttribute("max", "59");
	        self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
	        self.timeContainer.appendChild(secondInput);
	      }

	      if (!self.config.time_24hr) {
	        // add self.amPM if appropriate
	        self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour) > 11)]);
	        self.amPM.title = self.l10n.toggleTitle;
	        self.amPM.tabIndex = -1;
	        self.timeContainer.appendChild(self.amPM);
	      }

	      return self.timeContainer;
	    }

	    function buildWeekdays() {
	      if (!self.weekdayContainer) self.weekdayContainer = createElement("div", "flatpickr-weekdays");else clearNode(self.weekdayContainer);

	      for (var i = self.config.showMonths; i--;) {
	        var container = createElement("div", "flatpickr-weekdaycontainer");
	        self.weekdayContainer.appendChild(container);
	      }

	      updateWeekdays();
	      return self.weekdayContainer;
	    }

	    function updateWeekdays() {
	      if (!self.weekdayContainer) {
	        return;
	      }

	      var firstDayOfWeek = self.l10n.firstDayOfWeek;
	      var weekdays = self.l10n.weekdays.shorthand.slice();

	      if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
	        weekdays = weekdays.splice(firstDayOfWeek, weekdays.length).concat(weekdays.splice(0, firstDayOfWeek));
	      }

	      for (var i = self.config.showMonths; i--;) {
	        self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
	      }
	    }
	    /* istanbul ignore next */


	    function buildWeeks() {
	      self.calendarContainer.classList.add("hasWeeks");
	      var weekWrapper = createElement("div", "flatpickr-weekwrapper");
	      weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
	      var weekNumbers = createElement("div", "flatpickr-weeks");
	      weekWrapper.appendChild(weekNumbers);
	      return {
	        weekWrapper: weekWrapper,
	        weekNumbers: weekNumbers
	      };
	    }

	    function changeMonth(value, isOffset) {
	      if (isOffset === void 0) {
	        isOffset = true;
	      }

	      var delta = isOffset ? value : value - self.currentMonth;
	      if (delta < 0 && self._hidePrevMonthArrow === true || delta > 0 && self._hideNextMonthArrow === true) return;
	      self.currentMonth += delta;

	      if (self.currentMonth < 0 || self.currentMonth > 11) {
	        self.currentYear += self.currentMonth > 11 ? 1 : -1;
	        self.currentMonth = (self.currentMonth + 12) % 12;
	        triggerEvent("onYearChange");
	        buildMonthSwitch();
	      }

	      buildDays();
	      triggerEvent("onMonthChange");
	      updateNavigationCurrentMonth();
	    }

	    function clear(triggerChangeEvent, toInitial) {
	      if (triggerChangeEvent === void 0) {
	        triggerChangeEvent = true;
	      }

	      if (toInitial === void 0) {
	        toInitial = true;
	      }

	      self.input.value = "";
	      if (self.altInput !== undefined) self.altInput.value = "";
	      if (self.mobileInput !== undefined) self.mobileInput.value = "";
	      self.selectedDates = [];
	      self.latestSelectedDateObj = undefined;

	      if (toInitial === true) {
	        self.currentYear = self._initialDate.getFullYear();
	        self.currentMonth = self._initialDate.getMonth();
	      }

	      self.showTimeInput = false;

	      if (self.config.enableTime === true) {
	        setDefaultHours();
	      }

	      self.redraw();
	      if (triggerChangeEvent) // triggerChangeEvent is true (default) or an Event
	        triggerEvent("onChange");
	    }

	    function close() {
	      self.isOpen = false;

	      if (!self.isMobile) {
	        if (self.calendarContainer !== undefined) {
	          self.calendarContainer.classList.remove("open");
	        }

	        if (self._input !== undefined) {
	          self._input.classList.remove("active");
	        }
	      }

	      triggerEvent("onClose");
	    }

	    function destroy() {
	      if (self.config !== undefined) triggerEvent("onDestroy");

	      for (var i = self._handlers.length; i--;) {
	        var h = self._handlers[i];
	        h.element.removeEventListener(h.event, h.handler, h.options);
	      }

	      self._handlers = [];

	      if (self.mobileInput) {
	        if (self.mobileInput.parentNode) self.mobileInput.parentNode.removeChild(self.mobileInput);
	        self.mobileInput = undefined;
	      } else if (self.calendarContainer && self.calendarContainer.parentNode) {
	        if (self.config.static && self.calendarContainer.parentNode) {
	          var wrapper = self.calendarContainer.parentNode;
	          wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);

	          if (wrapper.parentNode) {
	            while (wrapper.firstChild) wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);

	            wrapper.parentNode.removeChild(wrapper);
	          }
	        } else self.calendarContainer.parentNode.removeChild(self.calendarContainer);
	      }

	      if (self.altInput) {
	        self.input.type = "text";
	        if (self.altInput.parentNode) self.altInput.parentNode.removeChild(self.altInput);
	        delete self.altInput;
	      }

	      if (self.input) {
	        self.input.type = self.input._type;
	        self.input.classList.remove("flatpickr-input");
	        self.input.removeAttribute("readonly");
	        self.input.value = "";
	      }

	      ["_showTimeInput", "latestSelectedDateObj", "_hideNextMonthArrow", "_hidePrevMonthArrow", "__hideNextMonthArrow", "__hidePrevMonthArrow", "isMobile", "isOpen", "selectedDateElem", "minDateHasTime", "maxDateHasTime", "days", "daysContainer", "_input", "_positionElement", "innerContainer", "rContainer", "monthNav", "todayDateElem", "calendarContainer", "weekdayContainer", "prevMonthNav", "nextMonthNav", "monthsDropdownContainer", "currentMonthElement", "currentYearElement", "navigationCurrentMonth", "selectedDateElem", "config"].forEach(function (k) {
	        try {
	          delete self[k];
	        } catch (_) {}
	      });
	    }

	    function isCalendarElem(elem) {
	      if (self.config.appendTo && self.config.appendTo.contains(elem)) return true;
	      return self.calendarContainer.contains(elem);
	    }

	    function documentClick(e) {
	      if (self.isOpen && !self.config.inline) {
	        var eventTarget_1 = getEventTarget(e);
	        var isCalendarElement = isCalendarElem(eventTarget_1);
	        var isInput = eventTarget_1 === self.input || eventTarget_1 === self.altInput || self.element.contains(eventTarget_1) || // web components
	        // e.path is not present in all browsers. circumventing typechecks
	        e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));
	        var lostFocus = e.type === "blur" ? isInput && e.relatedTarget && !isCalendarElem(e.relatedTarget) : !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
	        var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
	          return elem.contains(eventTarget_1);
	        });

	        if (lostFocus && isIgnored) {
	          if (self.timeContainer !== undefined && self.minuteElement !== undefined && self.hourElement !== undefined) {
	            updateTime();
	          }

	          self.close();

	          if (self.config.mode === "range" && self.selectedDates.length === 1) {
	            self.clear(false);
	            self.redraw();
	          }
	        }
	      }
	    }

	    function changeYear(newYear) {
	      if (!newYear || self.config.minDate && newYear < self.config.minDate.getFullYear() || self.config.maxDate && newYear > self.config.maxDate.getFullYear()) return;
	      var newYearNum = newYear,
	          isNewYear = self.currentYear !== newYearNum;
	      self.currentYear = newYearNum || self.currentYear;

	      if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {
	        self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
	      } else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {
	        self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
	      }

	      if (isNewYear) {
	        self.redraw();
	        triggerEvent("onYearChange");
	        buildMonthSwitch();
	      }
	    }

	    function isEnabled(date, timeless) {
	      if (timeless === void 0) {
	        timeless = true;
	      }

	      var dateToCheck = self.parseDate(date, undefined, timeless); // timeless

	      if (self.config.minDate && dateToCheck && compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && dateToCheck && compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0) return false;
	      if (self.config.enable.length === 0 && self.config.disable.length === 0) return true;
	      if (dateToCheck === undefined) return false;
	      var bool = self.config.enable.length > 0,
	          array = bool ? self.config.enable : self.config.disable;

	      for (var i = 0, d = void 0; i < array.length; i++) {
	        d = array[i];
	        if (typeof d === "function" && d(dateToCheck) // disabled by function
	        ) return bool;else if (d instanceof Date && dateToCheck !== undefined && d.getTime() === dateToCheck.getTime()) // disabled by date
	          return bool;else if (typeof d === "string" && dateToCheck !== undefined) {
	          // disabled by date string
	          var parsed = self.parseDate(d, undefined, true);
	          return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
	        } else if ( // disabled by range
	        typeof d === "object" && dateToCheck !== undefined && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime()) return bool;
	      }

	      return !bool;
	    }

	    function isInView(elem) {
	      if (self.daysContainer !== undefined) return elem.className.indexOf("hidden") === -1 && self.daysContainer.contains(elem);
	      return false;
	    }

	    function onKeyDown(e) {
	      // e.key                      e.keyCode
	      // "Backspace"                        8
	      // "Tab"                              9
	      // "Enter"                           13
	      // "Escape"     (IE "Esc")           27
	      // "ArrowLeft"  (IE "Left")          37
	      // "ArrowUp"    (IE "Up")            38
	      // "ArrowRight" (IE "Right")         39
	      // "ArrowDown"  (IE "Down")          40
	      // "Delete"     (IE "Del")           46
	      var isInput = e.target === self._input;
	      var allowInput = self.config.allowInput;
	      var allowKeydown = self.isOpen && (!allowInput || !isInput);
	      var allowInlineKeydown = self.config.inline && isInput && !allowInput;

	      if (e.keyCode === 13 && isInput) {
	        if (allowInput) {
	          self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);
	          return e.target.blur();
	        } else {
	          self.open();
	        }
	      } else if (isCalendarElem(e.target) || allowKeydown || allowInlineKeydown) {
	        var isTimeObj = !!self.timeContainer && self.timeContainer.contains(e.target);

	        switch (e.keyCode) {
	          case 13:
	            if (isTimeObj) {
	              e.preventDefault();
	              updateTime();
	              focusAndClose();
	            } else selectDate(e);

	            break;

	          case 27:
	            // escape
	            e.preventDefault();
	            focusAndClose();
	            break;

	          case 8:
	          case 46:
	            if (isInput && !self.config.allowInput) {
	              e.preventDefault();
	              self.clear();
	            }

	            break;

	          case 37:
	          case 39:
	            if (!isTimeObj && !isInput) {
	              e.preventDefault();

	              if (self.daysContainer !== undefined && (allowInput === false || document.activeElement && isInView(document.activeElement))) {
	                var delta_1 = e.keyCode === 39 ? 1 : -1;
	                if (!e.ctrlKey) focusOnDay(undefined, delta_1);else {
	                  e.stopPropagation();
	                  changeMonth(delta_1);
	                  focusOnDay(getFirstAvailableDay(1), 0);
	                }
	              }
	            } else if (self.hourElement) self.hourElement.focus();

	            break;

	          case 38:
	          case 40:
	            e.preventDefault();
	            var delta = e.keyCode === 40 ? 1 : -1;

	            if (self.daysContainer && e.target.$i !== undefined || e.target === self.input || e.target === self.altInput) {
	              if (e.ctrlKey) {
	                e.stopPropagation();
	                changeYear(self.currentYear - delta);
	                focusOnDay(getFirstAvailableDay(1), 0);
	              } else if (!isTimeObj) focusOnDay(undefined, delta * 7);
	            } else if (e.target === self.currentYearElement) {
	              changeYear(self.currentYear - delta);
	            } else if (self.config.enableTime) {
	              if (!isTimeObj && self.hourElement) self.hourElement.focus();
	              updateTime(e);

	              self._debouncedChange();
	            }

	            break;

	          case 9:
	            if (isTimeObj) {
	              var elems = [self.hourElement, self.minuteElement, self.secondElement, self.amPM].concat(self.pluginElements).filter(function (x) {
	                return x;
	              });
	              var i = elems.indexOf(e.target);

	              if (i !== -1) {
	                var target = elems[i + (e.shiftKey ? -1 : 1)];
	                e.preventDefault();

	                (target || self._input).focus();
	              }
	            } else if (!self.config.noCalendar && self.daysContainer && self.daysContainer.contains(e.target) && e.shiftKey) {
	              e.preventDefault();

	              self._input.focus();
	            }

	            break;
	        }
	      }

	      if (self.amPM !== undefined && e.target === self.amPM) {
	        switch (e.key) {
	          case self.l10n.amPM[0].charAt(0):
	          case self.l10n.amPM[0].charAt(0).toLowerCase():
	            self.amPM.textContent = self.l10n.amPM[0];
	            setHoursFromInputs();
	            updateValue();
	            break;

	          case self.l10n.amPM[1].charAt(0):
	          case self.l10n.amPM[1].charAt(0).toLowerCase():
	            self.amPM.textContent = self.l10n.amPM[1];
	            setHoursFromInputs();
	            updateValue();
	            break;
	        }
	      }

	      if (isInput || isCalendarElem(e.target)) {
	        triggerEvent("onKeyDown", e);
	      }
	    }

	    function onMouseOver(elem) {
	      if (self.selectedDates.length !== 1 || elem && (!elem.classList.contains("flatpickr-day") || elem.classList.contains("flatpickr-disabled"))) return;
	      var hoverDate = elem ? elem.dateObj.getTime() : self.days.firstElementChild.dateObj.getTime(),
	          initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(),
	          rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()),
	          rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
	      var containsDisabled = false;
	      var minRange = 0,
	          maxRange = 0;

	      for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
	        if (!isEnabled(new Date(t), true)) {
	          containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
	          if (t < initialDate && (!minRange || t > minRange)) minRange = t;else if (t > initialDate && (!maxRange || t < maxRange)) maxRange = t;
	        }
	      }

	      for (var m = 0; m < self.config.showMonths; m++) {
	        var month = self.daysContainer.children[m];

	        var _loop_1 = function (i, l) {
	          var dayElem = month.children[i],
	              date = dayElem.dateObj;
	          var timestamp = date.getTime();
	          var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;

	          if (outOfRange) {
	            dayElem.classList.add("notAllowed");
	            ["inRange", "startRange", "endRange"].forEach(function (c) {
	              dayElem.classList.remove(c);
	            });
	            return "continue";
	          } else if (containsDisabled && !outOfRange) return "continue";

	          ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
	            dayElem.classList.remove(c);
	          });

	          if (elem !== undefined) {
	            elem.classList.add(hoverDate <= self.selectedDates[0].getTime() ? "startRange" : "endRange");
	            if (initialDate < hoverDate && timestamp === initialDate) dayElem.classList.add("startRange");else if (initialDate > hoverDate && timestamp === initialDate) dayElem.classList.add("endRange");
	            if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate)) dayElem.classList.add("inRange");
	          }
	        };

	        for (var i = 0, l = month.children.length; i < l; i++) {
	          _loop_1(i, l);
	        }
	      }
	    }

	    function onResize() {
	      if (self.isOpen && !self.config.static && !self.config.inline) positionCalendar();
	    }

	    function setDefaultTime() {
	      self.setDate(self.config.minDate !== undefined ? new Date(self.config.minDate.getTime()) : new Date(), true);
	      setDefaultHours();
	      updateValue();
	    }

	    function open(e, positionElement) {
	      if (positionElement === void 0) {
	        positionElement = self._positionElement;
	      }

	      if (self.isMobile === true) {
	        if (e) {
	          e.preventDefault();
	          e.target && e.target.blur();
	        }

	        if (self.mobileInput !== undefined) {
	          self.mobileInput.focus();
	          self.mobileInput.click();
	        }

	        triggerEvent("onOpen");
	        return;
	      }

	      if (self._input.disabled || self.config.inline) return;
	      var wasOpen = self.isOpen;
	      self.isOpen = true;

	      if (!wasOpen) {
	        self.calendarContainer.classList.add("open");

	        self._input.classList.add("active");

	        triggerEvent("onOpen");
	        positionCalendar(positionElement);
	      }

	      if (self.config.enableTime === true && self.config.noCalendar === true) {
	        if (self.selectedDates.length === 0) {
	          setDefaultTime();
	        }

	        if (self.config.allowInput === false && (e === undefined || !self.timeContainer.contains(e.relatedTarget))) {
	          setTimeout(function () {
	            return self.hourElement.select();
	          }, 50);
	        }
	      }
	    }

	    function minMaxDateSetter(type) {
	      return function (date) {
	        var dateObj = self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat);
	        var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];

	        if (dateObj !== undefined) {
	          self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
	        }

	        if (self.selectedDates) {
	          self.selectedDates = self.selectedDates.filter(function (d) {
	            return isEnabled(d);
	          });
	          if (!self.selectedDates.length && type === "min") setHoursFromDate(dateObj);
	          updateValue();
	        }

	        if (self.daysContainer) {
	          redraw();
	          if (dateObj !== undefined) self.currentYearElement[type] = dateObj.getFullYear().toString();else self.currentYearElement.removeAttribute(type);
	          self.currentYearElement.disabled = !!inverseDateObj && dateObj !== undefined && inverseDateObj.getFullYear() === dateObj.getFullYear();
	        }
	      };
	    }

	    function parseConfig() {
	      var boolOpts = ["wrap", "weekNumbers", "allowInput", "clickOpens", "time_24hr", "enableTime", "noCalendar", "altInput", "shorthandCurrentMonth", "inline", "static", "enableSeconds", "disableMobile"];

	      var userConfig = __assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));

	      var formats = {};
	      self.config.parseDate = userConfig.parseDate;
	      self.config.formatDate = userConfig.formatDate;
	      Object.defineProperty(self.config, "enable", {
	        get: function () {
	          return self.config._enable;
	        },
	        set: function (dates) {
	          self.config._enable = parseDateRules(dates);
	        }
	      });
	      Object.defineProperty(self.config, "disable", {
	        get: function () {
	          return self.config._disable;
	        },
	        set: function (dates) {
	          self.config._disable = parseDateRules(dates);
	        }
	      });
	      var timeMode = userConfig.mode === "time";

	      if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
	        var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
	        formats.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
	      }

	      if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
	        var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
	        formats.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
	      }

	      if (!userConfig.altInputClass) {
	        self.config.altInputClass = self.input.className + " " + self.config.altInputClass;
	      }

	      Object.defineProperty(self.config, "minDate", {
	        get: function () {
	          return self.config._minDate;
	        },
	        set: minMaxDateSetter("min")
	      });
	      Object.defineProperty(self.config, "maxDate", {
	        get: function () {
	          return self.config._maxDate;
	        },
	        set: minMaxDateSetter("max")
	      });

	      var minMaxTimeSetter = function (type) {
	        return function (val) {
	          self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i:S");
	        };
	      };

	      Object.defineProperty(self.config, "minTime", {
	        get: function () {
	          return self.config._minTime;
	        },
	        set: minMaxTimeSetter("min")
	      });
	      Object.defineProperty(self.config, "maxTime", {
	        get: function () {
	          return self.config._maxTime;
	        },
	        set: minMaxTimeSetter("max")
	      });

	      if (userConfig.mode === "time") {
	        self.config.noCalendar = true;
	        self.config.enableTime = true;
	      }

	      Object.assign(self.config, formats, userConfig);

	      for (var i = 0; i < boolOpts.length; i++) self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === "true";

	      HOOKS.filter(function (hook) {
	        return self.config[hook] !== undefined;
	      }).forEach(function (hook) {
	        self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
	      });
	      self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === "single" && !self.config.disable.length && !self.config.enable.length && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

	      for (var i = 0; i < self.config.plugins.length; i++) {
	        var pluginConf = self.config.plugins[i](self) || {};

	        for (var key in pluginConf) {
	          if (HOOKS.indexOf(key) > -1) {
	            self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);
	          } else if (typeof userConfig[key] === "undefined") self.config[key] = pluginConf[key];
	        }
	      }

	      triggerEvent("onParseConfig");
	    }

	    function setupLocale() {
	      if (typeof self.config.locale !== "object" && typeof flatpickr.l10ns[self.config.locale] === "undefined") self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
	      self.l10n = __assign({}, flatpickr.l10ns["default"], typeof self.config.locale === "object" ? self.config.locale : self.config.locale !== "default" ? flatpickr.l10ns[self.config.locale] : undefined);
	      tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";

	      var userConfig = __assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));

	      if (userConfig.time_24hr === undefined && flatpickr.defaultConfig.time_24hr === undefined) {
	        self.config.time_24hr = self.l10n.time_24hr;
	      }

	      self.formatDate = createDateFormatter(self);
	      self.parseDate = createDateParser({
	        config: self.config,
	        l10n: self.l10n
	      });
	    }

	    function positionCalendar(customPositionElement) {
	      if (self.calendarContainer === undefined) return;
	      triggerEvent("onPreCalendarPosition");
	      var positionElement = customPositionElement || self._positionElement;
	      var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, function (acc, child) {
	        return acc + child.offsetHeight;
	      }, 0),
	          calendarWidth = self.calendarContainer.offsetWidth,
	          configPos = self.config.position.split(" "),
	          configPosVertical = configPos[0],
	          configPosHorizontal = configPos.length > 1 ? configPos[1] : null,
	          inputBounds = positionElement.getBoundingClientRect(),
	          distanceFromBottom = window.innerHeight - inputBounds.bottom,
	          showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
	      var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
	      toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
	      toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
	      if (self.config.inline) return;
	      var left = window.pageXOffset + inputBounds.left - (configPosHorizontal != null && configPosHorizontal === "center" ? (calendarWidth - inputBounds.width) / 2 : 0);
	      var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
	      var rightMost = left + calendarWidth > window.document.body.offsetWidth;
	      var centerMost = right + calendarWidth > window.document.body.offsetWidth;
	      toggleClass(self.calendarContainer, "rightMost", rightMost);
	      if (self.config.static) return;
	      self.calendarContainer.style.top = top + "px";

	      if (!rightMost) {
	        self.calendarContainer.style.left = left + "px";
	        self.calendarContainer.style.right = "auto";
	      } else if (!centerMost) {
	        self.calendarContainer.style.left = "auto";
	        self.calendarContainer.style.right = right + "px";
	      } else {
	        var doc = document.styleSheets[0]; // some testing environments don't have css support

	        if (doc === undefined) return;
	        var bodyWidth = window.document.body.offsetWidth;
	        var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
	        var centerBefore = ".flatpickr-calendar.centerMost:before";
	        var centerAfter = ".flatpickr-calendar.centerMost:after";
	        var centerIndex = doc.cssRules.length;
	        var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
	        toggleClass(self.calendarContainer, "rightMost", false);
	        toggleClass(self.calendarContainer, "centerMost", true);
	        doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
	        self.calendarContainer.style.left = centerLeft + "px";
	        self.calendarContainer.style.right = "auto";
	      }
	    }

	    function redraw() {
	      if (self.config.noCalendar || self.isMobile) return;
	      updateNavigationCurrentMonth();
	      buildDays();
	    }

	    function focusAndClose() {
	      self._input.focus();

	      if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== undefined) {
	        // hack - bugs in the way IE handles focus keeps the calendar open
	        setTimeout(self.close, 0);
	      } else {
	        self.close();
	      }
	    }

	    function selectDate(e) {
	      e.preventDefault();
	      e.stopPropagation();

	      var isSelectable = function (day) {
	        return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
	      };

	      var t = findParent(e.target, isSelectable);
	      if (t === undefined) return;
	      var target = t;
	      var selectedDate = self.latestSelectedDateObj = new Date(target.dateObj.getTime());
	      var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth || selectedDate.getMonth() > self.currentMonth + self.config.showMonths - 1) && self.config.mode !== "range";
	      self.selectedDateElem = target;
	      if (self.config.mode === "single") self.selectedDates = [selectedDate];else if (self.config.mode === "multiple") {
	        var selectedIndex = isDateSelected(selectedDate);
	        if (selectedIndex) self.selectedDates.splice(parseInt(selectedIndex), 1);else self.selectedDates.push(selectedDate);
	      } else if (self.config.mode === "range") {
	        if (self.selectedDates.length === 2) {
	          self.clear(false, false);
	        }

	        self.latestSelectedDateObj = selectedDate;
	        self.selectedDates.push(selectedDate); // unless selecting same date twice, sort ascendingly

	        if (compareDates(selectedDate, self.selectedDates[0], true) !== 0) self.selectedDates.sort(function (a, b) {
	          return a.getTime() - b.getTime();
	        });
	      }
	      setHoursFromInputs();

	      if (shouldChangeMonth) {
	        var isNewYear = self.currentYear !== selectedDate.getFullYear();
	        self.currentYear = selectedDate.getFullYear();
	        self.currentMonth = selectedDate.getMonth();

	        if (isNewYear) {
	          triggerEvent("onYearChange");
	          buildMonthSwitch();
	        }

	        triggerEvent("onMonthChange");
	      }

	      updateNavigationCurrentMonth();
	      buildDays();
	      updateValue();
	      if (self.config.enableTime) setTimeout(function () {
	        return self.showTimeInput = true;
	      }, 50); // maintain focus

	      if (!shouldChangeMonth && self.config.mode !== "range" && self.config.showMonths === 1) focusOnDayElem(target);else if (self.selectedDateElem !== undefined && self.hourElement === undefined) {
	        self.selectedDateElem && self.selectedDateElem.focus();
	      }
	      if (self.hourElement !== undefined) self.hourElement !== undefined && self.hourElement.focus();

	      if (self.config.closeOnSelect) {
	        var single = self.config.mode === "single" && !self.config.enableTime;
	        var range = self.config.mode === "range" && self.selectedDates.length === 2 && !self.config.enableTime;

	        if (single || range) {
	          focusAndClose();
	        }
	      }

	      triggerChange();
	    }

	    var CALLBACKS = {
	      locale: [setupLocale, updateWeekdays],
	      showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
	      minDate: [jumpToDate],
	      maxDate: [jumpToDate]
	    };

	    function set(option, value) {
	      if (option !== null && typeof option === "object") {
	        Object.assign(self.config, option);

	        for (var key in option) {
	          if (CALLBACKS[key] !== undefined) CALLBACKS[key].forEach(function (x) {
	            return x();
	          });
	        }
	      } else {
	        self.config[option] = value;
	        if (CALLBACKS[option] !== undefined) CALLBACKS[option].forEach(function (x) {
	          return x();
	        });else if (HOOKS.indexOf(option) > -1) self.config[option] = arrayify(value);
	      }

	      self.redraw();
	      updateValue(false);
	    }

	    function setSelectedDate(inputDate, format) {
	      var dates = [];
	      if (inputDate instanceof Array) dates = inputDate.map(function (d) {
	        return self.parseDate(d, format);
	      });else if (inputDate instanceof Date || typeof inputDate === "number") dates = [self.parseDate(inputDate, format)];else if (typeof inputDate === "string") {
	        switch (self.config.mode) {
	          case "single":
	          case "time":
	            dates = [self.parseDate(inputDate, format)];
	            break;

	          case "multiple":
	            dates = inputDate.split(self.config.conjunction).map(function (date) {
	              return self.parseDate(date, format);
	            });
	            break;

	          case "range":
	            dates = inputDate.split(self.l10n.rangeSeparator).map(function (date) {
	              return self.parseDate(date, format);
	            });
	            break;
	        }
	      } else self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
	      self.selectedDates = dates.filter(function (d) {
	        return d instanceof Date && isEnabled(d, false);
	      });
	      if (self.config.mode === "range") self.selectedDates.sort(function (a, b) {
	        return a.getTime() - b.getTime();
	      });
	    }

	    function setDate(date, triggerChange, format) {
	      if (triggerChange === void 0) {
	        triggerChange = false;
	      }

	      if (format === void 0) {
	        format = self.config.dateFormat;
	      }

	      if (date !== 0 && !date || date instanceof Array && date.length === 0) return self.clear(triggerChange);
	      setSelectedDate(date, format);
	      self.showTimeInput = self.selectedDates.length > 0;
	      self.latestSelectedDateObj = self.selectedDates[self.selectedDates.length - 1];
	      self.redraw();
	      jumpToDate();
	      setHoursFromDate();

	      if (self.selectedDates.length === 0) {
	        self.clear(false);
	      }

	      updateValue(triggerChange);
	      if (triggerChange) triggerEvent("onChange");
	    }

	    function parseDateRules(arr) {
	      return arr.slice().map(function (rule) {
	        if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
	          return self.parseDate(rule, undefined, true);
	        } else if (rule && typeof rule === "object" && rule.from && rule.to) return {
	          from: self.parseDate(rule.from, undefined),
	          to: self.parseDate(rule.to, undefined)
	        };

	        return rule;
	      }).filter(function (x) {
	        return x;
	      }); // remove falsy values
	    }

	    function setupDates() {
	      self.selectedDates = [];
	      self.now = self.parseDate(self.config.now) || new Date(); // Workaround IE11 setting placeholder as the input's value

	      var preloadedDate = self.config.defaultDate || ((self.input.nodeName === "INPUT" || self.input.nodeName === "TEXTAREA") && self.input.placeholder && self.input.value === self.input.placeholder ? null : self.input.value);
	      if (preloadedDate) setSelectedDate(preloadedDate, self.config.dateFormat);
	      self._initialDate = self.selectedDates.length > 0 ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now.getTime() ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now.getTime() ? self.config.maxDate : self.now;
	      self.currentYear = self._initialDate.getFullYear();
	      self.currentMonth = self._initialDate.getMonth();
	      if (self.selectedDates.length > 0) self.latestSelectedDateObj = self.selectedDates[0];
	      if (self.config.minTime !== undefined) self.config.minTime = self.parseDate(self.config.minTime, "H:i");
	      if (self.config.maxTime !== undefined) self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
	      self.minDateHasTime = !!self.config.minDate && (self.config.minDate.getHours() > 0 || self.config.minDate.getMinutes() > 0 || self.config.minDate.getSeconds() > 0);
	      self.maxDateHasTime = !!self.config.maxDate && (self.config.maxDate.getHours() > 0 || self.config.maxDate.getMinutes() > 0 || self.config.maxDate.getSeconds() > 0);
	      Object.defineProperty(self, "showTimeInput", {
	        get: function () {
	          return self._showTimeInput;
	        },
	        set: function (bool) {
	          self._showTimeInput = bool;
	          if (self.calendarContainer) toggleClass(self.calendarContainer, "showTimeInput", bool);
	          self.isOpen && positionCalendar();
	        }
	      });
	    }

	    function setupInputs() {
	      self.input = self.config.wrap ? element.querySelector("[data-input]") : element;
	      /* istanbul ignore next */

	      if (!self.input) {
	        self.config.errorHandler(new Error("Invalid input element specified"));
	        return;
	      } // hack: store previous type to restore it after destroy()


	      self.input._type = self.input.type;
	      self.input.type = "text";
	      self.input.classList.add("flatpickr-input");
	      self._input = self.input;

	      if (self.config.altInput) {
	        // replicate self.element
	        self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
	        self._input = self.altInput;
	        self.altInput.placeholder = self.input.placeholder;
	        self.altInput.disabled = self.input.disabled;
	        self.altInput.required = self.input.required;
	        self.altInput.tabIndex = self.input.tabIndex;
	        self.altInput.type = "text";
	        self.input.setAttribute("type", "hidden");
	        if (!self.config.static && self.input.parentNode) self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
	      }

	      if (!self.config.allowInput) self._input.setAttribute("readonly", "readonly");
	      self._positionElement = self.config.positionElement || self._input;
	    }

	    function setupMobile() {
	      var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";
	      self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
	      self.mobileInput.step = self.input.getAttribute("step") || "any";
	      self.mobileInput.tabIndex = 1;
	      self.mobileInput.type = inputType;
	      self.mobileInput.disabled = self.input.disabled;
	      self.mobileInput.required = self.input.required;
	      self.mobileInput.placeholder = self.input.placeholder;
	      self.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";

	      if (self.selectedDates.length > 0) {
	        self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
	      }

	      if (self.config.minDate) self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
	      if (self.config.maxDate) self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
	      self.input.type = "hidden";
	      if (self.altInput !== undefined) self.altInput.type = "hidden";

	      try {
	        if (self.input.parentNode) self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
	      } catch (_a) {}

	      bind(self.mobileInput, "change", function (e) {
	        self.setDate(e.target.value, false, self.mobileFormatStr);
	        triggerEvent("onChange");
	        triggerEvent("onClose");
	      });
	    }

	    function toggle(e) {
	      if (self.isOpen === true) return self.close();
	      self.open(e);
	    }

	    function triggerEvent(event, data) {
	      // If the instance has been destroyed already, all hooks have been removed
	      if (self.config === undefined) return;
	      var hooks = self.config[event];

	      if (hooks !== undefined && hooks.length > 0) {
	        for (var i = 0; hooks[i] && i < hooks.length; i++) hooks[i](self.selectedDates, self.input.value, self, data);
	      }

	      if (event === "onChange") {
	        self.input.dispatchEvent(createEvent("change")); // many front-end frameworks bind to the input event

	        self.input.dispatchEvent(createEvent("input"));
	      }
	    }

	    function createEvent(name) {
	      var e = document.createEvent("Event");
	      e.initEvent(name, true, true);
	      return e;
	    }

	    function isDateSelected(date) {
	      for (var i = 0; i < self.selectedDates.length; i++) {
	        if (compareDates(self.selectedDates[i], date) === 0) return "" + i;
	      }

	      return false;
	    }

	    function isDateInRange(date) {
	      if (self.config.mode !== "range" || self.selectedDates.length < 2) return false;
	      return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;
	    }

	    function updateNavigationCurrentMonth() {
	      if (self.config.noCalendar || self.isMobile || !self.monthNav) return;
	      self.yearElements.forEach(function (yearElement, i) {
	        var d = new Date(self.currentYear, self.currentMonth, 1);
	        d.setMonth(self.currentMonth + i);

	        if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
	          self.monthElements[i].textContent = monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
	        } else {
	          self.monthsDropdownContainer.value = d.getMonth().toString();
	        }

	        yearElement.value = d.getFullYear().toString();
	      });
	      self._hidePrevMonthArrow = self.config.minDate !== undefined && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());
	      self._hideNextMonthArrow = self.config.maxDate !== undefined && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());
	    }

	    function getDateStr(format) {
	      return self.selectedDates.map(function (dObj) {
	        return self.formatDate(dObj, format);
	      }).filter(function (d, i, arr) {
	        return self.config.mode !== "range" || self.config.enableTime || arr.indexOf(d) === i;
	      }).join(self.config.mode !== "range" ? self.config.conjunction : self.l10n.rangeSeparator);
	    }
	    /**
	     * Updates the values of inputs associated with the calendar
	     */


	    function updateValue(triggerChange) {
	      if (triggerChange === void 0) {
	        triggerChange = true;
	      }

	      if (self.mobileInput !== undefined && self.mobileFormatStr) {
	        self.mobileInput.value = self.latestSelectedDateObj !== undefined ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : "";
	      }

	      self.input.value = getDateStr(self.config.dateFormat);

	      if (self.altInput !== undefined) {
	        self.altInput.value = getDateStr(self.config.altFormat);
	      }

	      if (triggerChange !== false) triggerEvent("onValueUpdate");
	    }

	    function onMonthNavClick(e) {
	      var isPrevMonth = self.prevMonthNav.contains(e.target);
	      var isNextMonth = self.nextMonthNav.contains(e.target);

	      if (isPrevMonth || isNextMonth) {
	        changeMonth(isPrevMonth ? -1 : 1);
	      } else if (self.yearElements.indexOf(e.target) >= 0) {
	        e.target.select();
	      } else if (e.target.classList.contains("arrowUp")) {
	        self.changeYear(self.currentYear + 1);
	      } else if (e.target.classList.contains("arrowDown")) {
	        self.changeYear(self.currentYear - 1);
	      }
	    }

	    function timeWrapper(e) {
	      e.preventDefault();
	      var isKeyDown = e.type === "keydown",
	          input = e.target;

	      if (self.amPM !== undefined && e.target === self.amPM) {
	        self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
	      }

	      var min = parseFloat(input.getAttribute("min")),
	          max = parseFloat(input.getAttribute("max")),
	          step = parseFloat(input.getAttribute("step")),
	          curValue = parseInt(input.value, 10),
	          delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
	      var newValue = curValue + step * delta;

	      if (typeof input.value !== "undefined" && input.value.length === 2) {
	        var isHourElem = input === self.hourElement,
	            isMinuteElem = input === self.minuteElement;

	        if (newValue < min) {
	          newValue = max + newValue + int(!isHourElem) + (int(isHourElem) && int(!self.amPM));
	          if (isMinuteElem) incrementNumInput(undefined, -1, self.hourElement);
	        } else if (newValue > max) {
	          newValue = input === self.hourElement ? newValue - max - int(!self.amPM) : min;
	          if (isMinuteElem) incrementNumInput(undefined, 1, self.hourElement);
	        }

	        if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
	          self.amPM.textContent = self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
	        }

	        input.value = pad(newValue);
	      }
	    }

	    init();
	    return self;
	  }
	  /* istanbul ignore next */


	  function _flatpickr(nodeList, config) {
	    // static list
	    var nodes = Array.prototype.slice.call(nodeList).filter(function (x) {
	      return x instanceof HTMLElement;
	    });
	    var instances = [];

	    for (var i = 0; i < nodes.length; i++) {
	      var node = nodes[i];

	      try {
	        if (node.getAttribute("data-fp-omit") !== null) continue;

	        if (node._flatpickr !== undefined) {
	          node._flatpickr.destroy();

	          node._flatpickr = undefined;
	        }

	        node._flatpickr = FlatpickrInstance(node, config || {});
	        instances.push(node._flatpickr);
	      } catch (e) {
	        console.error(e);
	      }
	    }

	    return instances.length === 1 ? instances[0] : instances;
	  }
	  /* istanbul ignore next */


	  if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
	    // browser env
	    HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
	      return _flatpickr(this, config);
	    };

	    HTMLElement.prototype.flatpickr = function (config) {
	      return _flatpickr([this], config);
	    };
	  }
	  /* istanbul ignore next */


	  var flatpickr = function (selector, config) {
	    if (typeof selector === "string") {
	      return _flatpickr(window.document.querySelectorAll(selector), config);
	    } else if (selector instanceof Node) {
	      return _flatpickr([selector], config);
	    } else {
	      return _flatpickr(selector, config);
	    }
	  };
	  /* istanbul ignore next */


	  flatpickr.defaultConfig = {};
	  flatpickr.l10ns = {
	    en: __assign({}, english),
	    "default": __assign({}, english)
	  };

	  flatpickr.localize = function (l10n) {
	    flatpickr.l10ns["default"] = __assign({}, flatpickr.l10ns["default"], l10n);
	  };

	  flatpickr.setDefaults = function (config) {
	    flatpickr.defaultConfig = __assign({}, flatpickr.defaultConfig, config);
	  };

	  flatpickr.parseDate = createDateParser({});
	  flatpickr.formatDate = createDateFormatter({});
	  flatpickr.compareDates = compareDates;
	  /* istanbul ignore next */

	  if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
	    jQuery.fn.flatpickr = function (config) {
	      return _flatpickr(this, config);
	    };
	  } // eslint-disable-next-line @typescript-eslint/camelcase


	  Date.prototype.fp_incr = function (days) {
	    return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
	  };

	  if (typeof window !== "undefined") {
	    window.flatpickr = flatpickr;
	  }

	  return flatpickr;
	});
	});

	function triggerEvent(el, eventName, options) {
	  let event;

	  if (window.CustomEvent) {
	    event = new CustomEvent(eventName, options);
	  } else {
	    event = document.createEvent('CustomEvent');
	    event.initCustomEvent(eventName, true, true, options);
	  }

	  return el.dispatchEvent(event);
	}
	function setCookie(name, value, minutes) {
	  let expires;

	  if (minutes) {
	    const date = new Date();
	    date.setTime(date.getTime() + minutes * 60 * 1000);
	    expires = "; expires=" + date.toGMTString();
	  } else {
	    expires = "";
	  }

	  document.cookie = name + "=" + value + expires + "; path=/";
	}
	function getCookie(name) {
	  const nameEQ = name + "=";
	  const ca = document.cookie.split(';');

	  for (let i = 0; i < ca.length; i++) {
	    let c = ca[i];

	    while (c.charAt(0) === ' ') {
	      c = c.substring(1, c.length);
	    }

	    if (c.indexOf(nameEQ) === 0) {
	      return c.substring(nameEQ.length, c.length);
	    }
	  }

	  return null;
	}
	function changeWoocommerceStep(nextStep, previousStep) {
	  const currentStep = document.querySelector(`[data-step="${nextStep}"]`);
	  const prevStep = document.querySelector(`[data-step="${previousStep}"]`);

	  if (currentStep && prevStep) {
	    currentStep.classList.add('steps__step--active');
	    prevStep.classList.remove('steps__step--active');
	    prevStep.classList.add('steps__step--done');
	    jQuery('.woocommerce-notices-wrapper').empty();
	    let prevStepImg = prevStep.querySelector('img');
	    prevStepImg.src = prevStepImg.src.replace(previousStep, 'done');
	  }
	}
	jQuery('.center-dropdown-menu li').hover(function () {
	  const dataTermValue = jQuery(this).attr('data-term');
	  jQuery('.submenu_image_right').hide();
	  jQuery('.img-container img[data-term=' + dataTermValue + ']').toggleClass('showImg');
	}, function () {
	  jQuery('.submenu_image_right').show();
	  jQuery('.img-container img[data-term]').removeClass('showImg');
	});
	jQuery('.search-link').click(function () {
	  jQuery('.search-container').addClass('search-container--open');
	});
	jQuery('.search-container__close').click(function () {
	  jQuery('.search-container').removeClass('search-container--open');
	});

	(function ($) {
	  // Set favorites products cookie if not exists
	  if (!getCookie('favoritesProducts')) {
	    setCookie('favoritesProducts', '', '525600');
	  }

	  $('.order__heading [data-collapse]').on('click', function () {
	    $(this).parents('tr').toggleClass('active');
	  });
	  $('.menu-item-has-children span.arrow').on('click', function (e) {
	    e.preventDefault();
	    $(this).parent().next().toggle();
	  });
	  $(document).on('click', '.cwginstock-subscribe-form h4', function () {
	    $('.cwginstock-panel-body').slideToggle();
	  }); // Save favorite product in cookies

	  $(document).on('click', '.favourites', function (e) {
	    var _this = $(this),
	        productId = _this.attr('data-id'),
	        favoritesProducts = getCookie('favoritesProducts'),
	        favoritesProducts = favoritesProducts ? favoritesProducts.split(',') : [];

	    if (!_this.hasClass('favourites-added')) {
	      _this.find('.empty-heart').addClass('full-heart');

	      if (!favoritesProducts.includes(productId)) {
	        favoritesProducts.push(productId);
	        setCookie('favoritesProducts', favoritesProducts.toString(), '525600');
	      }
	    } else {
	      _this.find('.empty-heart').removeClass('full-heart');

	      if (favoritesProducts.includes(productId)) {
	        var index = favoritesProducts.indexOf(productId);
	        if (index !== -1) favoritesProducts.splice(index, 1);
	        setCookie('favoritesProducts', favoritesProducts.toString(), '525600');
	      }
	    }

	    _this.toggleClass('favourites-added');
	  });
	})(jQuery); // Gallery carousel 3d


	if (jQuery('#gallery__carousel').length > 0) {
	  var galleryCarousel = jQuery('#gallery__carousel').waterwheelCarousel({
	    'activeClassName': 'active',
	    'separation': 355,
	    'horizonOffset': 0,
	    'forcedImageWidth': 425,
	    'forcedImageHeight': 280,
	    'flankingItems': 5,
	    'sizeMultiplier': 0.5
	  });
	  jQuery('.gallery__carousel__nav--next').on('click', function (e) {
	    e.preventDefault();
	    galleryCarousel.next();
	  });
	  jQuery('.gallery__carousel__nav--prev').on('click', function (e) {
	    e.preventDefault();
	    galleryCarousel.prev();
	  });
	} // Show hide alert email


	jQuery('.subscribe_for_interest_text').on('click', function () {
	  jQuery('.notify__email').attr('style', 'display: block');
	});
	jQuery('.stock_alert_button, .stock_alert_email').wrapAll('<div class="notify__email">');
	jQuery('.stock_alert_button').on('click', function () {
	  jQuery('.stock_alert_email').wrapAll('<div class="notify__email">');
	}); // Fb news share

	function fbShare(url, title, descr) {
	  var windowHeight = 350,
	      windowWidth = 520,
	      alignTop = screen.height / 2 - windowHeight / 2,
	      alignLeft = screen.width / 2 - windowWidth / 2,
	      facebookShareUrl = 'https://www.facebook.com/sharer.php?s=100&p[title]=' + title + '&p[summary]=' + descr + '&p[url]=' + url;
	  window.open(facebookShareUrl, "", "top=" + alignTop + ",left=" + alignLeft + ",width=" + windowWidth + ",height=" + windowHeight);
	}
	jQuery('.fb__share a').on('click', function (e) {
	  e.preventDefault();

	  let _title = jQuery(this).parent().attr('data-title'),
	      _url = jQuery(this).parent().attr('data-url'),
	      _description = jQuery(this).parent().attr('data-description');

	  fbShare(_url, _title, _description);
	}); // Remove empty paragraphs

	jQuery('p').each(function () {
	  var $this = jQuery(this);

	  if ($this.html().replace(/\s|&nbsp;/g, '').length == 0) {
	    $this.remove();
	  }
	}); // 404 page history back

	if (window.history.length > 1) {
	  jQuery('.historyBack').on('click', function () {
	    window.history.go(-1);
	    return false;
	  });
	} else {
	  jQuery('.section__404--content__links--back').hide();
	} // Trigger click on product image - go to product details


	jQuery('.product__overlay--full').click(function (e) {
	  var _this = jQuery(this),
	      _link = _this.find('.product__functional-buttons a').attr('href');

	  if (jQuery(e.target).is('.product__ekstra-info') || jQuery(e.target).is('.product__overlay')) {
	    window.location.href = _link;
	  }
	});

	const Polish = pl.default.pl;

	const execute$2 = () => {
	  const shippingRadio = document.querySelectorAll('input.shipping_method');
	  const locationRadio = document.querySelectorAll('input[name="location"]');
	  const userRadio = document.querySelectorAll('input[name="user_type"]');
	  const paymentsRadio = document.querySelectorAll('input[name="payment_method"]');
	  const userType = document.querySelectorAll('input[name="user_type"]');
	  const postalCodeInput = document.querySelector('input[name="postal_code"]');
	  const billingPostalCode = document.querySelector('input[name="billing_postcode"]'); //const shippingPostalCode  = document.querySelector('input[name="shipping_postcode"]');

	  const checkoutCoupon = document.querySelector('input[name="coupon"]');
	  const companyName = document.querySelector('input[name="billing_company"]');
	  const companyNip = document.querySelector('input[name="billing_nip"]');
	  const checkoutCouponBtn = document.querySelector('button[name="add_coupon"]');
	  const coupon = document.querySelector('input[name="coupon_code"]');
	  const couponBtn = document.querySelector('button[name="apply_coupon"]');
	  const registerButton = document.querySelector('#register-button');
	  const guestButton = document.querySelector('#guest-button');
	  const stepContentShipping = document.querySelector('.step__content--shipping');
	  const stepContentLogin = document.querySelector('.step__content--login');
	  const calendarConfig = document.getElementById('calendar');
	  const now = moment();
	  let init = false;
	  let currentOpeningTime;
	  let disabledDates;
	  let currentShippingMethod;
	  moment.locale('pl'); // if (getCookie('checkout_step') === '3') {
	  //     changeWoocommerceStep('shipping', 'login')
	  // }
	  // if (getCookie('checkout_step') === '3-register') {
	  //     changeWoocommerceStep('shipping', 'login')
	  //     const createAccount = document.querySelector('input[name="createaccount"]')
	  //     createAccount.setAttribute('checked', 'checked')
	  //     jQuery('.shipping__account').slideDown()
	  // }
	  // DatePicker config

	  let minDate = now.hour() < 18 ? new Date().fp_incr(1) : new Date().fp_incr(2);
	  let datePickerConfig = {
	    inline: true,
	    dateFormat: 'd-m-Y',
	    monthSelectorType: 'static',
	    yearSelectorType: 'static',
	    defaultDate: 'today',
	    minDate: calendarConfig.getAttribute('data-delayed') ? new Date().fp_incr(5) : minDate,
	    locale: Polish,
	    onChange: selectedDates => {
	      if (!currentShippingMethod.includes('pickpack') && currentOpeningTime) {
	        fillTimeSelect(currentOpeningTime.availability[moment(selectedDates[0]).isoWeekday() - 1].range);
	      }

	      if (selectedDates) {
	        triggerEvent(document.body, 'update_checkout');
	      }
	    }
	  };
	  const datePicker = flatpickr('input[name="shipping_date"]', datePickerConfig); // Functions

	  const clearCalendar = () => {
	    datePicker.clear();
	    datePicker.set('disable', []);
	    datePicker.set('minDate', calendarConfig.getAttribute('data-delayed') ? new Date().fp_incr(5) : minDate);
	    datePicker.set('maxDate', '');
	  };

	  const configCalendarForLocalPickup = inputValue => {
	    currentOpeningTime = getLocationOpeningTime(inputValue);
	    disabledDates = getDisabledDates(currentOpeningTime.availability);
	    datePicker.set('disable', [function (date) {
	      return disabledDates && disabledDates.includes(moment(date).isoWeekday() - 1);
	    }]);

	    if (currentOpeningTime.is_new && currentOpeningTime.days_range) {
	      let dateTo = '';
	      let dateFrom = minDate;

	      if (currentOpeningTime.days_range.date_from) {
	        let openingFrom = moment(currentOpeningTime.days_range.date_from);
	        dateFrom = openingFrom > minDate ? openingFrom.toDate() : minDate;
	      }

	      if (currentOpeningTime.days_range.date_to) {
	        dateTo = moment(currentOpeningTime.days_range.date_to).toDate();
	      }

	      datePicker.set('minDate', dateFrom);
	      datePicker.set('maxDate', dateTo);
	    }
	  };

	  const handleLocationRadioChange = event => {
	    clearCalendar();
	    clearTimeSelect();
	    configCalendarForLocalPickup(event.target.value);
	    hideTimeRangeSelectForNewLocation(event.target.getAttribute('data-new'));
	    triggerEvent(document.body, 'updated_checkout');
	  };

	  const initCalendarConfigForLocalPickup = () => {
	    locationRadio.forEach(radio => {
	      if (radio.checked) {
	        configCalendarForLocalPickup(radio.value);
	      }

	      radio.removeEventListener('change', handleLocationRadioChange);
	      radio.addEventListener('change', handleLocationRadioChange);
	    });
	  };

	  const changeUserFieldsVisibility = val => {
	    if (val == 'company') {
	      jQuery('.checkout-company, .checkout-nip').removeClass('uk-hidden');
	    } else {
	      jQuery('.checkout-company, .checkout-nip').addClass('uk-hidden');
	    }
	  };

	  initCalendarConfigForLocalPickup();
	  document.addEventListener('click', event => {
	    let element = event.target;

	    if (element.classList.contains('shipping_method')) {
	      let inputValue = element.value;
	      clearCalendar();
	      changeVisibilityForShippingElements(inputValue);
	    }
	  });
	  userRadio.forEach(radio => {
	    radio.addEventListener('change', event => {
	      changeUserFieldsVisibility(event.target.value);
	    });
	  });
	  shippingRadio.forEach(radio => {
	    if (radio.checked) {
	      changeVisibilityForShippingElements(radio.value);
	      currentShippingMethod = radio.value;
	    }

	    radio.addEventListener('change', event => {
	      clearCalendar();
	      clearTimeSelect();
	      jQuery('input[name="postal_code"]').val('');
	      currentShippingMethod = event.target.value;
	      jQuery('.woocommerce-checkout').submit();
	      jQuery('.woocommerce-NoticeGroup-checkout').empty();

	      if (event.target.value.includes('local_pickup')) {
	        initCalendarConfigForLocalPickup();
	      }
	    });
	  });
	  paymentsRadio.forEach(radio => {
	    radio.addEventListener('change', event => {
	      let inputValue = event.target.value;
	      jQuery('.options').slideUp();
	      jQuery('.options[data-payment="' + inputValue + '"]').slideDown();
	    });
	  });
	  checkoutCouponBtn.addEventListener('click', () => {
	    coupon.value = checkoutCoupon.value;
	    jQuery(couponBtn).trigger('click');
	    jQuery('#coupon-form-to-submit').slideDown();
	    jQuery.scroll_to_notices(jQuery('#coupon-form-to-submit'));
	  });
	  postalCodeInput.addEventListener('input', () => {
	    if (postalCodeInput.value.length === 6) {
	      billingPostalCode.value = postalCodeInput.value;
	      init = true;
	      jQuery('.checkout__postcode__info').fadeIn(); //triggerEvent(document.body, 'update_checkout');

	      triggerEvent(document.body, 'update_checkout'); //jQuery('.woocommerce-checkout').submit();
	    }
	  });
	  userType.forEach(radio => {
	    radio.addEventListener('change', event => {
	      let inputValue = event.target.value;
	      console.log(inputValue);

	      if (inputValue == 'company') {
	        if (companyName.value == '' || companyNip.value == '') {
	          jQuery('p#billing_company_field, p#billing_nip_field').addClass('error');
	        } else {
	          jQuery('p#billing_company_field, p#billing_nip_field').removeClass('error');
	        }
	      }
	    });
	  });
	  billingPostalCode.addEventListener('change', () => {
	    postalCodeInput.value = billingPostalCode.value;
	    triggerEvent(document.body, 'updated_checkout');
	  }); // shippingPostalCode.addEventListener('change', () => {
	  //     postalCodeInput.value = shippingPostalCode.value;
	  //     triggerEvent(document.body, 'update_checkout')
	  // });

	  jQuery(document.body).on('updated_checkout', function () {
	    jQuery('.checkout__postcode__info').fadeOut();
	    jQuery('#checkout-validator').val('true');
	    const shippingRadio = document.querySelectorAll('input.shipping_method');
	    const checkedShippingRadio = document.querySelectorAll('input.shipping_method:checked');

	    if (init) {
	      jQuery('.shipping__options, .shipping__local-pickup, .shipping__calendar, .shipping__time').removeClass('uk-hidden');
	    }

	    if (!postalCodeInput.value.length) {
	      jQuery('input[name="postal_code"]').addClass('error');
	    } else {
	      jQuery('input[name="postal_code"]').removeClass('error');
	    }

	    shippingRadio.forEach(radio => {
	      if (radio.checked) {
	        changeVisibilityForShippingElements(radio.value);
	        currentShippingMethod = radio.value;
	      }

	      radio.addEventListener('change', event => {
	        clearCalendar();
	        clearTimeSelect();
	        currentShippingMethod = event.target.value;
	        jQuery('.woocommerce-checkout').submit();
	        jQuery('.woocommerce-NoticeGroup-checkout').empty();

	        if (event.target.value.includes('local_pickup')) {
	          initCalendarConfigForLocalPickup();
	        }
	      });
	    });
	  });
	  registerButton.addEventListener('click', () => {
	    stepContentLogin.classList.remove('step__content--active');
	    stepContentShipping.classList.add('step__content--active');
	    const createAccount = document.querySelector('input[name="createaccount"]');
	    createAccount.setAttribute('checked', 'checked');
	    jQuery('.shipping__account').slideDown();
	    changeWoocommerceStep('shipping', 'login'); // setCookie('checkout_step', '3-register', 20)
	  });
	  guestButton.addEventListener('click', () => {
	    stepContentLogin.classList.remove('step__content--active');
	    stepContentShipping.classList.add('step__content--active');
	    changeWoocommerceStep('shipping', 'login'); // setCookie('checkout_step', '3', 20)
	  });
	  window.addEventListener('keydown', function (e) {
	    if (e.keyIdentifier == 'U+000A' || e.keyIdentifier == 'Enter' || e.keyCode == 13) {
	      if (e.target.nodeName == 'INPUT' && e.target.type == 'text' && e.target.id == 'postal_code') {
	        triggerEvent(document.body, 'updated_checkout');
	        e.preventDefault();
	        return false;
	      } else if (e.target.nodeName == 'INPUT' && e.target.type == 'text') {
	        e.preventDefault();
	        return false;
	      }
	    }
	  }, true);
	};

	let locationOpeningTimeCache = {};

	const getLocationOpeningTime = location_id => {
	  let result = false;

	  if (locationOpeningTimeCache.hasOwnProperty(location_id)) {
	    return locationOpeningTimeCache[location_id];
	  }

	  jQuery.ajax({
	    type: 'post',
	    dataType: 'json',
	    url: ajaxurl,
	    async: false,
	    data: {
	      action: 'wctheme_get_location_opening_time',
	      location_id: location_id
	    },
	    success: response => {
	      result = response;
	    }
	  });
	  locationOpeningTimeCache[location_id] = result;
	  return result;
	};

	const getPickPackTimeRange = () => {
	  let result = false;
	  jQuery.ajax({
	    type: 'post',
	    dataType: 'json',
	    url: ajaxurl,
	    async: false,
	    data: {
	      action: 'wctheme_get_pickpack_time_range'
	    },
	    success: response => {
	      result = response;
	    }
	  });
	  return result;
	};

	const getDisabledDates = dates => {
	  return Object.keys(dates).filter(key => dates[key].is_open === false).reduce((obj, key) => {
	    obj.push(parseInt(key));
	    return obj;
	  }, []);
	};

	const fillTimeSelect = dates => {
	  let select = document.getElementById('shipping_time');
	  select.innerHTML = '';

	  if (dates) {
	    dates.forEach(date => {
	      let opt = document.createElement('option');
	      opt.innerHTML = date;
	      if (!date.includes('Wybierz')) opt.value = date;else {
	        opt.disabled = true;
	        opt.selected = true;
	      }
	      select.appendChild(opt);
	    });
	  }
	};

	const clearTimeSelect = () => {
	  let select = document.getElementById('shipping_time');
	  select.innerHTML = '';
	};

	const changeVisibilityForShippingElements = inputValue => {
	  jQuery('.checkout__delivery__info').hide();

	  if (inputValue.includes('local_pickup')) {
	    // jQuery('.shipping__flat-rate').hide();
	    jQuery('.shipping__shipping').hide();
	    jQuery('.shipping__time').slideDown();
	    jQuery('.shipping__local-pickup').slideDown();
	    jQuery('.shipping__calendar').slideDown();
	  } else if (inputValue.includes('pickpack')) {
	    const pickPackTimeRange = getPickPackTimeRange();
	    fillTimeSelect(pickPackTimeRange.availability.range);
	    jQuery('.shipping__local-pickup').hide();
	    jQuery('.shipping__time').slideDown();
	    jQuery('.shipping__shipping').slideDown(); // jQuery('.shipping__flat-rate').slideDown();

	    jQuery('.shipping__calendar').slideDown();
	  } else if (inputValue.includes('wctheme_free_shipping')) {
	    jQuery('.shipping__time').hide();
	    jQuery('.shipping__local-pickup').hide();
	    jQuery('.shipping__shipping').slideDown(); // jQuery('.shipping__flat-rate').slideDown();

	    jQuery('.shipping__calendar').slideDown();
	  } else if (inputValue.includes('flat_rate')) {
	    jQuery('.shipping__time').hide();
	    jQuery('.shipping__local-pickup').hide();
	    jQuery('.shipping__calendar').hide(); // jQuery('.shipping__flat-rate').slideDown();

	    jQuery('.shipping__shipping').slideDown();
	  } else {
	    jQuery('.shipping__local-pickup').hide();
	    jQuery('.shipping__shipping').slideDown(); // jQuery('.shipping__flat-rate').slideDown();

	    jQuery('.shipping__time').slideDown();
	    jQuery('.shipping__calendar').slideDown();
	  }

	  if (inputValue.includes('pickpack:3')) {
	    jQuery('.checkout__delivery__info--zone1').slideDown();
	  }

	  if (inputValue.includes('pickpack:5')) {
	    jQuery('.checkout__delivery__info--zone2').slideDown();
	  }
	};

	const hideTimeRangeSelectForNewLocation = isNew => {
	  if (isNew) jQuery('.shipping__time').hide();else jQuery('.shipping__time').slideDown();
	};

	const execute$3 = () => {
	  const cartLink = document.querySelector('.cart-link');

	  const mobileAndTabletCheck = () => {
	    let check = false;

	    (function (a) {
	      if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true;
	    })(navigator.userAgent || navigator.vendor || window.opera);

	    return check;
	  };

	  cartLink.addEventListener('click', event => {
	    event.preventDefault();
	    let miniCart = document.querySelector('.links-container .widget_shopping_cart_content');
	    miniCart.classList.add('widget_shopping_cart_content--open');
	  });
	  document.addEventListener('click', event => {
	    let element = event.target;

	    if (element.classList.contains('mini-cart__close')) {
	      let miniCart = document.querySelector('.links-container .widget_shopping_cart_content');
	      miniCart.classList.remove('widget_shopping_cart_content--open');
	    }
	  });

	  if (!mobileAndTabletCheck()) {
	    document.addEventListener('scroll', e => {
	      let miniCart = document.querySelector('.links-container .widget_shopping_cart_content');

	      if (miniCart.classList.contains('widget_shopping_cart_content--open')) {
	        miniCart.classList.remove('widget_shopping_cart_content--open');
	      }
	    });
	  } // Scrollbar


	  jQuery(document).ready(function () {
	    const cart = document.querySelector('.woocommerce-mini-cart');

	    if (cart) {
	      const cartScroll = new PerfectScrollbar(cart, {
	        wheelSpeed: 0.5,
	        wheelPropagation: false
	      });
	    }

	    if (jQuery('body').hasClass('home') || jQuery('body').hasClass('page-template-page-favourites')) {
	      if (jQuery('.woocommerce-error').length > 0) {
	        jQuery('.custom__alerts').addClass('error');
	        setTimeout(function () {
	          jQuery('.custom__alerts').hide();
	        }, 4000);
	      }

	      if (jQuery('.woocommerce-message').length > 0) {
	        jQuery('.custom__alerts').addClass('success');
	        setTimeout(function () {
	          jQuery('.custom__alerts').hide();
	        }, 4000);
	      }
	    }
	  });
	};

	const scrollTo = () => {
	  setTimeout(function () {
	    jQuery("html, body").animate({
	      scrollTop: jQuery("body").offset().top
	    }, 1000);
	  }, 800);
	};

	const execute$4 = () => {
	  const registerButton = document.getElementById('register-button');
	  const backBtn = document.querySelector('#go-back');
	  const contentLogin = document.querySelector('.step__content--login');
	  const contentRegister = document.querySelector('.step__content--register');
	  const registerEmail = document.querySelector('#reg_email');
	  const registerUsername = document.querySelector('#reg_username');
	  registerButton.addEventListener('click', () => {
	    contentLogin.classList.remove('step__content--active');
	    contentRegister.classList.add('step__content--active');
	    scrollTo();
	  });
	  backBtn.addEventListener('click', () => {
	    contentLogin.classList.add('step__content--active');
	    contentRegister.classList.remove('step__content--active');
	  });
	  registerEmail.addEventListener('change', () => {
	    registerUsername.value = registerEmail.value;
	  });
	};

	// UIKit
	execute(); // WooCommerce Components
	execute$1();
	execute$3();

	if (document.querySelector('.woocommerce-account')) {
	  execute$4();
	}

	if (document.querySelector('form.woocommerce-checkout')) {
	  execute$2();
	} // loads the Icon plugin


	uikit.use(uikitIcons);

}());
//# sourceMappingURL=scripts.min.js.map
